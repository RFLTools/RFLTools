;
;
;   Program written by Robert Livingston, 99/12/14
;
;   CORNER is a routine for drawing corner elements by selecting two tangents
;
;
(defun C:CORNER (/ CMDECHO ANGBASE ANGDIR C CALC CL DELTATOTAL DIMZIN DOWN ENT1 ENT1LIST ENT2 ENT2LIST
                   ACCEPTCORNER ANG ANG1 ANG2 ANGLE3P CANCEL CANCELCORNER D DCL_ID DIR DX DY
                   FIXRIN FIXROUT FIXV OSMODE
                   NODE NODEMAX P1 P2 P3 P4 P PA PB PLIST RIN ROUT SETCALC STANDARD TMP
                   UP UPDATEDIALOG XYLIST TAN X1 X2 Y1 X2)
;(defun C:CORNER ()

 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (defun TAN (ANG)
  (/ (sin ANG) (cos ANG))
 )

 (defun ANGLE3P (P1 P2 P3 / ANG)
  (setq ANG (- (angle P2 P1) (angle P2 P3)))
  (if (< ANG 0.0) (setq ANG (* -1.0 ANG)))
  (if (> ANG pi) (setq ANG (- (* 2.0 pi) ANG)))
  (eval ANG)
 )

 (defun ACCEPTCORNER ()
  (setq CANCEL 0)
  (done_dialog)
 )

 (defun CANCELCORNER ()
  (setq CANCEL 1)
  (done_dialog)
 )

 (defun FIXV ()
  (setq CL (subst (list NODE
                        (if (= (get_tile "A") "1") "A" "S")
                        (abs (atof (get_tile "RIN")))
                        (abs (atof (get_tile "ROUT")))
                        (if (= (get_tile "A") "1")
                         (if (= (atof (get_tile "RIN")) 0.0)
                          0.0
                          (if (= (get_tile "D") "1")
                           (angtof (get_tile "V"))
                           (/ (abs (atof (get_tile "V"))) (abs (atof (get_tile "RIN"))))
                          )
                         )
                         0.0
                        )
                        (if (= NODE CALC) "CALC" "")
                  )
                  (assoc NODE CL)
                  CL
           )
  )
  (UPDATEDIALOG)
 )

 (defun FIXLIST (/ C DELTA)
  (setq C 0)
  (setq DELTA 0.0)
  (while (< C (length CL))
   (if (/= (last (nth C CL)) "CALC")
    (setq DELTA (+ DELTA (nth 4 (nth C CL))))
   )
   (setq C (+ C 1))
  )
  (setq DELTA (- DELTATOTAL DELTA))
  (setq CL (subst (list CALC
                        (nth 1 (assoc CALC CL))
                        (nth 2 (assoc CALC CL))
                        (nth 3 (assoc CALC CL))
                        DELTA
                        "CALC"
                  )
                  (assoc CALC CL)
                  CL
           )
  )
 )

 (defun UPDATEDIALOG ()
  (FIXLIST)
  (set_tile "RIN" (rtos (nth 2 (nth NODE CL)) 2 6))
  (set_tile "ROUT" (rtos (nth 3 (nth NODE CL)) 2 6))
  (if (= (get_tile "D") "1")
   (set_tile "V" (angtos (nth 4 (nth NODE CL)) 1 8))
   (if (= (get_tile "A") "1")
    (set_tile "V" (rtos (* (nth 2 (nth NODE CL)) (nth 4 (nth NODE CL))) 2 6))
    0.0
   )
  )
  (if (> NODE 0)
   (mode_tile "DOWN" 0)
   (mode_tile "DOWN" 1)
  )
  (if (= NODE CALC)
   (progn
    (set_tile "CALC" "1")
    (mode_tile "DELETE" 1)
   )
   (progn
    (set_tile "CALC" "0")
    (if (> NODEMAX 0)
     (mode_tile "DELETE" 0)
     (mode_tile "DELETE" 1)
    )
   )
  )
  (set_tile "NODE" (itoa (+ NODE 1)))
 )

 (defun DOWN ()
  (setq NODE (- NODE 1))
  (if (< NODE 0)
   (setq NODE 0)
  )
  (UPDATEDIALOG)
 )

 (defun UP ()
  (setq NODE (+ NODE 1))
  (if (> NODE NODEMAX)
   (progn
    (setq NODEMAX NODE)
    (setq CL (append CL (list (list NODE "A" 0.0 0.0 0.0 ""))))
    (alert "New node inserted!")
   )
  )
  (UPDATEDIALOG)
 )

 (defun SETCALC (/ C)
  (setq CALC NODE)
  (setq C 0)
  (while (< C (length CL))
   (setq CL (subst (list C
                         (nth 1 (nth C CL))
                         (nth 2 (nth C CL))
                         (nth 3 (nth C CL))
                         (nth 4 (nth C CL))
                         (if (= C CALC) "CALC" "")
                   )
                   (assoc C CL)
                   CL
            )
   )
   (setq C (+ C 1))
  )
  (UPDATEDIALOG)
 )

 (defun DELETE (/ C C2 TMP)
  (setq NODEMAX (- NODEMAX 1))
  (if (< NODE CALC)
   (setq CALC (- CALC 1))
  )
  (setq TMP CL)
  (setq CL nil)
  (setq C 0)
  (setq C2 0)
  (while (< C (length TMP))
   (if (/= C NODE)
    (progn
     (setq CL (append CL
                      (list (list C2
                                  (nth 1 (nth C TMP))
                                  (nth 2 (nth C TMP))
                                  (nth 3 (nth C TMP))
                                  (nth 4 (nth C TMP))
                                  (nth 5 (nth C TMP))
                            )
                      )
              )
     )
     (setq C2 (+ C2 1))
    )
   )
   (setq C (+ C 1))
  )
  (DOWN)
 )

 (defun STANDARD (/ S)
  (setq S (get_tile "STANDARD"))
  (if (= S "0")
   (progn
    (setq CL CORNERLIST)
    (setq NODE 0)
    (if (= CL nil)
     (progn
      (setq NODEMAX 0)
      (setq CALC 0)
      (setq CL (list (list 0 "A" 0.0 0.0 0.0 "CALC")))
     )
     (progn
      (setq NODEMAX (- (length CL) 1))
      (setq C 0)
      (while (and (< C (length CL)) (/= (last (nth C CL)) "CALC"))
       (setq C (+ C 1))
      )
      (setq CALC C)
     )
    )
   )
  )
  (if (= S "1")
   (progn
    (setq CL (list (list 0 "A" 440.0 0.0 (angtof "8d41'00\"") "")
                   (list 1 "A" 50.0 0.0 (angtof "16d50'05.93\"") "")
                   (list 2 "A" 15.0 0.0 0.0 "CALC")
                   (list 3 "A" 50.0 0.0 (angtof "16d50'05.93\"") "")
             )
    )
    (setq NODE 0)
    (setq NODEMAX 3)
    (setq CALC 2)
   )
  )
  (if (= S "2")
   (progn
    (setq CL (list (list 0 "A" 50.0 0.0 (angtof "16d50'05.93\"") "")
                   (list 1 "A" 15.0 0.0 0.0 "CALC")
                   (list 2 "A" 50.0 0.0 (angtof "16d50'05.93\"") "")
                   (list 3 "A" 440.0 0.0 (angtof "8d41'00\"") "")
             )
    )
    (setq NODE 0)
    (setq NODEMAX 3)
    (setq CALC 1)
   )
  )
  (if (= S "3")
   (progn
    (setq CL (list (list 0 "A" 36.0 0.0 (angtof "14d21'41.44\"") "")
                   (list 1 "A" 12.0 0.0 0.0 "CALC")
                   (list 2 "A" 36.0 0.0 (angtof "14d21'41.44\"") "")
             )
    )
    (setq NODE 0)
    (setq NODEMAX 2)
    (setq CALC 1)
   )
  )
  (if (= S "4")
   (progn
    (setq CL (list (list 0 "A" 50.0 0.0 (angtof "16d50'05.93\"") "")
                   (list 1 "A" 15.0 0.0 0.0 "CALC")
                   (list 2 "A" 50.0 0.0 (angtof "16d50'05.93\"") "")
             )
    )
    (setq NODE 0)
    (setq NODEMAX 2)
    (setq CALC 1)
   )
  )
  (if (= S "5")
   (progn
    (setq CL (list (list 0 "A" 55.0 0.0 (angtof "18d55'28.72\"") "")
                   (list 1 "A" 18.0 0.0 0.0 "CALC")
                   (list 2 "A" 55.0 0.0 (angtof "18d55'28.72\"") "")
             )
    )
    (setq NODE 0)
    (setq NODEMAX 2)
    (setq CALC 1)
   )
  )
  (UPDATEDIALOG)
 )

 (if (/= (setq ENT1 (car (entsel "\nSelect first tangent :"))) nil)
  (progn
   (setq ENTLIST1 (entget ENT1))
   (if (= (cdr (assoc 0 ENTLIST1)) "LINE")
    (progn
     (setq P1 (cdr (assoc 10 ENTLIST1)))
     (setq P1 (list (nth 0 P1) (nth 1 P1) 0.0))
     (setq P2 (cdr (assoc 11 ENTLIST1)))
     (setq P2 (list (nth 0 P2) (nth 1 P2) 0.0))
     (if (/= (setq ENT2 (car (entsel "\nSelect second tangent :"))) nil)
      (progn
       (setq ENTLIST2 (entget ENT2))
       (if (= (cdr (assoc 0 ENTLIST2)) "LINE")
        (progn
         (setq P3 (cdr (assoc 10 ENTLIST2)))
         (setq P3 (list (nth 0 P3) (nth 1 P3) 0.0))
         (setq P4 (cdr (assoc 11 ENTLIST2)))
         (setq P4 (list (nth 0 P4) (nth 1 P4) 0.0))

         (setq P (inters P1 P2 P3 P4 nil))

         (if (/= P nil)
          (progn
           (if (> (distance P2 P) (distance P1 P))
            (progn
             (setq TMP P1)
             (setq P1 P2)
             (setq P2 TMP)
            )
           )
           (if (> (distance P3 P) (distance P4 P))
            (progn
             (setq TMP P3)
             (setq P3 P4)
             (setq P4 TMP)
            )
           )

           (setq ANG1 (angle P1 P))
           (setq ANG2 (angle P P4))
           (if (> (sin (- ANG2 ANG1)) 0.0)
            (setq DIR 1.0)
            (setq DIR -1.0)
           )
           (setq ANG (angle P1 P))

           (setq DELTATOTAL (- pi (ANGLE3P P1 P P4)))


           (if (= CORNERDCLNAME nil)
            (progn
             (setq CORNERDCLNAME (vl-filename-mktemp "rfl.dcl"))
             (RFL:MAKEDCL CORNERDCLNAME "CORNER")
            )
            (if (= nil (findfile CORNERDCLNAME))
             (progn
              (setq CORNERDCLNAME (vl-filename-mktemp "rfl.dcl"))
              (RFL:MAKEDCL CORNERDCLNAME "CORNER")
             )
            )
           )
           (setq DCL_ID (load_dialog CORNERDCLNAME))
           (if (not (new_dialog "CORNER" DCL_ID)) (exit))

           (set_tile "DELTA" (strcat "Delta : " (angtos DELTATOTAL 1 6)))

           (STANDARD)

           (action_tile "DOWN" "(DOWN)")
           (action_tile "UP" "(UP)")
           (action_tile "CALC" "(SETCALC)")
           (action_tile "RIN" "(FIXV)")
           (action_tile "ROUT" "(FIXV)")
           (action_tile "A" "(UPDATEDIALOG)")
           (action_tile "S" "(UPDATEDIALOG)")
           (action_tile "L" "(UPDATEDIALOG)")
           (action_tile "D" "(UPDATEDIALOG)")
           (action_tile "V" "(FIXV)")
           (action_tile "SET" "(STANDARD)")
           (action_tile "DELETE" "(DELETE)")
           (action_tile "OK" "(ACCEPTCORNER)")
           (action_tile "CANCEL" "(CANCELCORNER)")

           (start_dialog)
           (unload_dialog DCL_ID)

           (if (= CANCEL 0)
            (progn
             (setq CORNERLIST CL)
             (setq XYLIST nil)
             (setq C 0)
             (while (< C (length CORNERLIST))
              (setq RIN (nth 2 (nth C CORNERLIST)))
              (setq ROUT (nth 3 (nth C CORNERLIST)))
              (setq D (nth 4 (nth C CORNERLIST)))
              (if (= (nth 1 (nth C CORNERLIST)) "A")
               (progn
                (setq DX (* RIN (sin D)))
                (setq DY (* DIR RIN (- 1.0 (cos D))))
                (setq XYLIST (append XYLIST (list (list (- (* DX (cos ANG)) (* DY (sin ANG)))
                                                        (+ (* DX (sin ANG)) (* DY (cos ANG)))
                                                  )
                                            )
                             )
                )
               )
               (progn
               )
              )
              (setq ANG (+ ANG (* DIR D)))
              (setq C (+ C 1))
             )
             (setq C 0)
             (setq DX 0.0)
             (setq DY 0.0)
             (while (< C (length XYLIST))
              (setq DX (+ DX (nth 0 (nth C XYLIST))))
              (setq DY (+ DY (nth 1 (nth C XYLIST))))
              (setq C (+ C 1))
             )
             (if (< (abs (cos ANG1)) 0.0000000001)
              (progn
               (setq X1 0.0)
               (setq X2 DX)
              )
              (progn
               (if (< (abs (cos ANG2)) 0.0000000001)
                (progn
                 (setq X1 DX)
                 (setq X2 0.0)
                )
                (progn
                 (setq X1 (/ (- DY (* DX (TAN ANG2))) (- (TAN ANG1) (TAN ANG2))))
                 (setq X2 (- DX X1))
                )
               )
              )
             )
             (if (< (abs (cos ANG1)) 0.0000000001)
              (progn
               (setq Y1 (- DY (* DX (TAN ANG2))))
               (setq Y2 (- DY Y1))
              )
              (progn
               (if (< (abs (cos ANG2)) 0.0000000001)
                (progn
                 (setq Y1 (* DX (TAN ANG1)))
                 (setq Y2 (- DY Y1))
                )
                (progn
                 (setq Y1 (/ (- (* DX (TAN ANG1) (TAN ANG2)) (* DY (TAN ANG1))) (- (TAN ANG2) (TAN ANG1))))
                 (setq Y2 (- DY Y1))
                )
               )
              )
             )
             (setq PA (list (- (nth 0 P) X1) (- (nth 1 P) Y1)))
             (setq C 0)
             (while (< C (length CORNERLIST))
              (setq PB (list (+ (nth 0 PA) (nth 0 (nth C XYLIST)))
                             (+ (nth 1 PA) (nth 1 (nth C XYLIST)))
                       )
              )
              (if (= (nth 1 (nth C CORNERLIST)) "A")
               (progn
                (if (and (> (nth 2 (nth C CORNERLIST)) 0.0000000001)
                         (> (nth 4 (nth C CORNERLIST)) 0.0000000001))
                 (progn
                  (command "._ARC"
                           (if (> DIR 0.0) PA PB)
                           "E"
                           (if (> DIR 0.0) PB PA)
                           "R"
                           (nth 2 (nth C CORNERLIST))
                  )
                 )
                )
               )
               (progn
               )
              )
              (setq C (+ C 1))
              (setq PA PB)
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "DIMZIN" DIMZIN)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)