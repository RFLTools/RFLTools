;
;
;     Program written by Robert Livingston, 2017-09-18
;
;     ROUNDABOUT is a collection of utilities for grading roundabouts
;
;
(setq RFL:ROUNDABOUTLIST nil)
(setq RFL:ROUNDABOUTP nil)
(setq RFL:ROUNDABOUTOCLIST nil)
(setq RFL:ROUNDABOUTICLIST nil)
(setq RFL:ROUNDABOUTMCLIST nil)
(setq RFL:ROUNDABOUTCCLIST nil)
(defun RFL:GETROUNDABOUTLIST (ENT / CENTERGRADE CUT CUTDITCHDEPTH CUTDITCHSLOPE CUTDITCHWIDTH ELEV ENTLIST FILL INNERGRADE GRADE NAME RCENTER RIN ROUT SLOPE)
 (setq RFL:ROUNDABOUTLIST nil)
 (setq CENTERGRADE nil
       CUT nil
       CUTDITCHDEPTH nil
       CUTDITCHSLOPE nil
       CUTDITCHWIDTH nil
       ELEV nil
       FILL nil
       INNERGRADE nil
       GRADE nil
       NAME nil
       RCENTER nil
       RIN nil
       ROUT nil
       SLOPE nil
 )
 (if (and (/= nil (setq ENTLIST (entget ENT))) (= "INSERT" (cdr (assoc 0 ENTLIST))) (= 1 (cdr (assoc 66 ENTLIST))))
  (progn
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
    (cond ((= "NAME" (strcase (cdr (assoc 2 ENTLIST))))
           (setq NAME (cdr (assoc 1 ENTLIST)))
          )
          ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq SLOPE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
           (setq ELEV (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "GRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq GRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "INNERGRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq INNERGRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CENTERGRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CENTERGRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "ROUT" (strcase (cdr (assoc 2 ENTLIST))))
           (setq ROUT (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "RIN" (strcase (cdr (assoc 2 ENTLIST))))
           (setq RIN (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "RCENTER" (strcase (cdr (assoc 2 ENTLIST))))
           (setq RCENTER (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "FILL" (strcase (cdr (assoc 2 ENTLIST))))
           (setq FILL (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUT" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUT (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHSLOPE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHSLOPE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHDEPTH" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHDEPTH (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHWIDTH" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHWIDTH (atof (cdr (assoc 1 ENTLIST))))
          )
    )
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
   (if (or (= CENTERGRADE nil)
           (= CUT nil)
           (= CUTDITCHDEPTH nil)
           (= CUTDITCHSLOPE nil)
           (= CUTDITCHWIDTH nil)
           (= ELEV nil)
           (= FILL nil)
           (= INNERGRADE nil)
           (= GRADE nil)
           (= NAME nil)
           (= RCENTER nil)
           (= RIN nil)
           (= ROUT nil)
           (= SLOPE nil)
       )
    nil
    (progn
     (setq RFL:ROUNDABOUTLIST (list (cons "NAME" NAME)
                                    (cons "SLOPE" SLOPE)
                                    (cons "ELEV" ELEV)
                                    (cons "GRADE" GRADE)
                                    (cons "INNERGRADE" INNERGRADE)
                                    (cons "CENTERGRADE" CENTERGRADE)
                                    (cons "RCENTER" RCENTER)
                                    (cons "ROUT" ROUT)
                                    (cons "RIN" RIN)
                                    (cons "CUT" CUT)
                                    (cons "FILL" FILL)
                                    (cons "CUTDITCHSLOPE" CUTDITCHSLOPE)
                                    (cons "CUTDITCHDEPTH" CUTDITCHDEPTH)
                                    (cons "CUTDITCHWIDTH" CUTDITCHWIDTH)
                              )
     )
     T
    )
   )
  )
  nil
 )
)
(defun RFL:CALCROUNDABOUT (ENT NMAX / A ANG ELEV ENTLIST N RCENTER RIN ROUT SLOPE X Y Z)
 (if (= nil (RFL:GETROUNDABOUTLIST ENT))
  (princ "\nProblem accessing roundabout data!")
  (progn
   (setq ENTLIST (entget ENT))
   (setq ELEV (cdr (assoc "ELEV" RFL:ROUNDABOUTLIST)))
   (setq ANG (cdr (assoc 50 ENTLIST)))
   (setq RFL:ROUNDABOUTP (cdr (assoc 10 ENTLIST)))
   (setq RFL:ROUNDABOUTP (list (car RFL:ROUNDABOUTP) (cadr RFL:ROUNDABOUTP) ELEV))
   
   ; Compute outer circle elevations
   (setq SLOPE (cdr (assoc "SLOPE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTOCLIST nil)
   (setq ROUT (cdr (assoc "ROUT" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car RFL:ROUNDABOUTP) (* ROUT (cos (+ A ANG)))))
    (setq Y (+ (cadr RFL:ROUNDABOUTP) (* ROUT (sin (+ A ANG)))))
    (setq Z (- ELEV (* (/ SLOPE 100.0) (* ROUT (cos A)))))
    (setq RFL:ROUNDABOUTOCLIST (append RFL:ROUNDABOUTOCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute inner circle elevations
   (setq SLOPE (cdr (assoc "GRADE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTICLIST nil)
   (setq RIN (cdr (assoc "RIN" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car RFL:ROUNDABOUTP) (* RIN (cos (+ A ANG)))))
    (setq Y (+ (cadr RFL:ROUNDABOUTP) (* RIN (sin (+ A ANG)))))
    (setq Z (+ (caddr (nth N RFL:ROUNDABOUTOCLIST)) (* (/ SLOPE 100.0) (- ROUT RIN))))
    (setq RFL:ROUNDABOUTICLIST (append RFL:ROUNDABOUTICLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute mount circle elevations
   (setq SLOPE (cdr (assoc "INNERGRADE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTMCLIST nil)
   (setq RCENTER (cdr (assoc "RCENTER" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car RFL:ROUNDABOUTP) (* RCENTER (cos (+ A ANG)))))
    (setq Y (+ (cadr RFL:ROUNDABOUTP) (* RCENTER (sin (+ A ANG)))))
    (setq Z (+ (caddr (nth N RFL:ROUNDABOUTICLIST)) (* (/ SLOPE 100.0) (- RIN RCENTER))))
    (setq RFL:ROUNDABOUTMCLIST (append RFL:ROUNDABOUTMCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute center circle elevations
   (setq SLOPE (cdr (assoc "CENTERGRADE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTCCLIST nil)
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (car RFL:ROUNDABOUTP))
    (setq Y (cadr RFL:ROUNDABOUTP))
    (setq Z (+ (caddr (nth N RFL:ROUNDABOUTMCLIST)) (* (/ SLOPE 100.0) (- RCENTER 0.0))))
    (setq RFL:ROUNDABOUTCCLIST (append RFL:ROUNDABOUTCCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
  )
 )
)
(defun RFL:CALCROUNDABOUTZ (ENT P / A ANG ELEV ENTLIST PO PI RCENTER RIN ROUT SLOPE X Y Z ZOUT ZIN ZMOUNT ZCENTER)
 (setq Z nil)
 (if (= nil (RFL:GETROUNDABOUTLIST ENT))
  (princ "\nProblem accessing roundabout data!")
  (progn
   (setq ENTLIST (entget ENT))
   (setq ELEV (cdr (assoc "ELEV" RFL:ROUNDABOUTLIST)))
   (setq ANG (cdr (assoc 50 ENTLIST)))
   (setq RFL:ROUNDABOUTP (cdr (assoc 10 ENTLIST)))
   (setq RFL:ROUNDABOUTP (list (car RFL:ROUNDABOUTP) (cadr RFL:ROUNDABOUTP) ELEV))
   (setq D (distance RFL:ROUNDABOUTP P))
   (setq A (- (angle RFL:ROUNDABOUTP P) ANG))
   
   (setq ROUT (cdr (assoc "ROUT" RFL:ROUNDABOUTLIST)))
   (setq RIN (cdr (assoc "RIN" RFL:ROUNDABOUTLIST)))
   (setq RCENTER (cdr (assoc "RCENTER" RFL:ROUNDABOUTLIST)))
   
   ; Compute outer circle elevation
   (setq SLOPE (cdr (assoc "SLOPE" RFL:ROUNDABOUTLIST)))
   (setq ZOUT (- ELEV (* (/ SLOPE 100.0) (* ROUT (cos A)))))
   
   ; Compute inner circle elevation
   (setq SLOPE (cdr (assoc "GRADE" RFL:ROUNDABOUTLIST)))
   (setq ZIN (+ ZOUT (* (/ SLOPE 100.0) (- ROUT RIN))))

   ; Compute mount circle elevation
   (setq SLOPE (cdr (assoc "INNERGRADE" RFL:ROUNDABOUTLIST)))
   (setq ZMOUNT (+ ZIN (* (/ SLOPE 100.0) (- RIN RCENTER))))

   ; Compute center circle elevation
   (setq SLOPE (cdr (assoc "CENTERGRADE" RFL:ROUNDABOUTLIST)))
   (setq ZCENTER (+ ZMOUNT (* (/ SLOPE 100.0) (- RCENTER 0.0))))
   
   (cond ((>= D RIN)
          (setq Z (+ ZIN (* (/ (- D RIN) (- ROUT RIN)) (- ZOUT ZIN))))
         )
         ((>= D RCENTER)
          (setq Z (+ ZMOUNT (* (/ (- D RCENTER) (- RIN RCENTER)) (- ZIN ZMOUNT))))
         )
         ((>= D 0.0)
          (setq Z (+ ZCENTER (* (/ (- D 0.0) (- RCENTER 0.0)) (- ZMOUNT ZCENTER))))
         )
   )
  )
 )
 Z
)
(defun C:DRAWROUNDABOUT (/ *error* A ANG ANGBASE ANGDIR CCLIST CMDECHO CUT CUTOS DRAW3DP ELEV ENT ENTLIST FILL FIXLIST FLAG ICLIST MLIST N NMAX NODE NODE1 NODE2 OBSURFACE OGLINE OGOFFSETLIST ORTHOMODE OCLIST OSMODE P P1 P2 PLIST PLISTD PREVENT R RCENTER REP RIN ROUT SLOPE SWATH TOELIST X Y Z Z1 Z1CUT Z2)
 (command "._UNDO" "M")
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGBASE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "OSMODE" OSMODE)
  (princ msg)
  ;(setq *error* nil)
 )
 (defun DRAW3DP (PLIST CLOSED / P)
  (command "._3DPOLY")
  (foreach P PLIST
   (command P)
  )
  (if CLOSED
   (command "C")
   (command "")
  )
  T
 )
 (defun FIXLIST (PLIST MINMAX / P Z)
  (setq TMPLIST nil Z nil)
  (if (= "MINIMUM" MINMAX)
   (setq Z (apply 'min (mapcar '(lambda (P) (caddr P)) PLIST)))
   (if (= "MAXIMUM" MINMAX)
    (setq Z (apply 'max (mapcar '(lambda (P) (caddr P)) PLIST)))
   )
  )
  (if Z
   (apply 'list (mapcar '(lambda (P) (list (car P) (cadr P) Z)) PLIST))
   PLIST
  )
 )
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 
 (setq PREVENT nil)
 (if (= nil (RFL:GETROUNDABOUTLIST (setq ENT (car (entsel "\nSelect roundabout block : ")))))
  (princ "\nProblem accessing roundabout data!")
  (progn
   (setq ELEV (cdr (assoc "ELEV" RFL:ROUNDABOUTLIST)))
   (setq ENTLIST (entget ENT))
   (setq NMAX 0)
   (while (< NMAX 3)
    (if (= nil (setq NMAX (getint "\nEnter number of circulatory segments <60> : ")))
     (setq NMAX 60)
    )
    (if (< NMAX 3) (princ "\nMust be at least 3!"))
   )
   (RFL:CALCROUNDABOUT ENT NMAX)
   (setq P (cdr (assoc 10 ENTLIST)))
   (setq P (list (car P) (cadr P) ELEV))
   (setq ANG (cdr (assoc 50 ENTLIST)))
   (if RFL:ROUNDABOUTCCLIST
    (progn
     (initget "GRADE MINIMUM MAXIMUM")
     (if (= nil (setq REP (getkword "\nInner apron: Use fixed grade, minimum or maximum (Grade/Minimum/<Maximum>) : ")))
      (setq REP "MAXIMUM")
     )
     (if (/= "GRADE" REP) (setq RFL:ROUNDABOUTCCLIST (FIXLIST RFL:ROUNDABOUTCCLIST REP)))
    )
   )
   ; Draw closed 3D outer, inner, and center circle polyline
   (DRAW3DP RFL:ROUNDABOUTOCLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (DRAW3DP RFL:ROUNDABOUTICLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (DRAW3DP RFL:ROUNDABOUTMCLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   ;(DRAW3DP RFL:ROUNDABOUTCCLIST T)
   ;(setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   
   (setq TOELIST nil)
   (if (setq OBSURFACE (RFL:GETC3DSURFACE))
    (progn
     (setq SWATH 0.0)
     (while (<= SWATH 0.0)
      (if (= nil (setq SWATH (getdist "\nEnter swath distance <100.0> : ")))
       (setq SWATH 100.0)
       (if (<= SWATH 0.0) (princ "\nMust be greater then 0.0!"))
      )
     )
     (setq FILL (cdr (assoc "FILL" RFL:ROUNDABOUTLIST)))
     (setq CUT (cdr (assoc "CUT" RFL:ROUNDABOUTLIST)))
     (setq N 0)
     (while (< N NMAX)
      (setq A (/ (* 2.0 pi N) NMAX))
      (setq OGLINE nil)
      (setq P1 (nth N RFL:ROUNDABOUTOCLIST))
      (setq Z1 (caddr P1))
      (setq Z1CUT (- Z1 (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))))
      (setq CUTOS (+ (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                        (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                     )
                     (cdr (assoc "CUTDITCHWIDTH" RFL:ROUNDABOUTLIST))
                  )
      )
      (setq P1 (list (car P1) (cadr P1)))
      (setq P2 (list (+ (car P1) (* SWATH (cos (+ A ANG))))
                     (+ (cadr P1) (* SWATH (sin (+ A ANG))))
               )
      )
      (setq PLIST (list (nth N RFL:ROUNDABOUTCCLIST)
                        (nth N RFL:ROUNDABOUTMCLIST)
                        (nth N RFL:ROUNDABOUTICLIST)
                        (nth N RFL:ROUNDABOUTOCLIST)
                  )
      )
      (if (/= nil (setq OGLINE (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
       (progn
        (setq OGOFFSETLIST nil)
        (foreach NODE OGLINE
         (setq OGOFFSETLIST (append OGOFFSETLIST (list (list (distance P1 (list (car NODE) (cadr NODE))) (caddr NODE)))))
        )
        (setq NODE1 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
              NODE2 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
        )
        (setq FLAG T)
        (setq P2 nil)
        (setq PLISTD nil)
        (while (and FLAG NODE1 NODE2)
         (if (setq P2 (inters NODE1 NODE2 (list 0.0 Z1) (list SWATH (- Z1 (/ SWATH FILL)))))
          (progn
           (setq FLAG nil)
           (setq PLISTD (list (list (+ (car P1) (* (car P2) (cos (+ A ANG))))
                                    (+ (cadr P1) (* (car P2) (sin (+ A ANG))))
                                    (cadr P2)
                              )
                        )
           )
          )
         )
         (if (= nil P2)
          (if (and (setq P2 (inters NODE1 NODE2 (list CUTOS Z1CUT) (list SWATH (+ Z1CUT (/ (- SWATH CUTOS) CUT)))))
                   (<= CUTOS (car P2))
              )
           (progn
            (setq FLAG nil)
            (setq PLISTD (list (list (+ (car P1) 
                                        (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                                           (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                                           (cos (+ A ANG))
                                        )
                                     )
                                     (+ (cadr P1)
                                        (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                                           (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                                           (sin (+ A ANG))
                                        )
                                     )
                                     Z1CUT
                                )
                                (list (+ (car P1) 
                                         (* CUTOS
                                            (cos (+ A ANG))
                                         )
                                      )
                                      (+ (cadr P1)
                                         (* CUTOS
                                            (sin (+ A ANG))
                                         )
                                      )
                                      Z1CUT
                                )
                                (list (+ (car P1) (* (car P2) (cos (+ A ANG))))
                                      (+ (cadr P1) (* (car P2) (sin (+ A ANG))))
                                      (cadr P2)
                                )
                         )
            )
           )
          )
         )
         (setq NODE1 NODE2
               NODE2 (car OGOFFSETLIST)
               OGOFFSETLIST (cdr OGOFFSETLIST)
         )
        )
       )
      )
      (if PLISTD (setq PLIST (append PLIST PLISTD)))
      (if PLIST
       (progn
        (setq TOELIST (append TOELIST (list (last PLIST))))
        (DRAW3DP PLIST nil)
        (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
       )
      )
      (setq N (1+ N))
     )
     (if TOELIST
      (progn
       (DRAW3DP TOELIST T)
       (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      )
     )
    )
   )
  )
 )
 
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
 T
)
(defun C:FIXROUNDABOUT (/ *error* ACTIVEDOC ACTIVESPACE ANG ANGBASE ANGDIR D D1 D2 D3 ENT ENT2 ENTLIST ENTOBJ GRADE OBSURFACE P P1 P2 P3 Z Z1 Z2 Z3)
 (command "._UNDO" "M")
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (defun *error* (msg)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (princ msg)
  ;(setq *error* nil)
 )
 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )
 (if (setq ENT (car (entsel "\nSelect roundabout block : ")))
  (progn
   (setq ENTLIST (entget ENT))
   (if (and (= "INSERT" (cdr (assoc 0 ENTLIST)))
            (= "ROUNDABOUT" (strcase (cdr (assoc 2 ENTLIST))))
            (= 1 (cdr (assoc 66 ENTLIST)))
       )
    (progn
     (princ "\nNote: Selecting no surface will use elevation of selected points.")
     (setq OBSURFACE (RFL:GETC3DSURFACE))
     (princ "\nNote: 1 point  = roundabout elevation adjusted to elevation of point, slope set to 0.0%")
     (princ "\n      2 points = roundabout elevation adjusted to average elevation of points, slope and rotation adjusted")
     (princ "\n      3 points = roundabout elevation adjusted to elevation of point on plane, slope and rotation adjusted")
     (setq P1 nil P2 nil P3 nil)
     (if (/= nil (setq P1 (getpoint "\nSelect first point : ")))
      (if (= nil (setq P2 (getpoint "\nSelect second point (<return> for single point) : ")))
       (progn ; Single point
        (if OBSURFACE
         (setq P1 (list (car P1) (cadr P1))
               Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
         )
         (setq Z1 (caddr P1)
               P1 (list (car P1) (cadr P1))
         )
        )
        (if Z1
         (progn
          (setq ENT2 (entnext ENT))
          (setq ENTLIST (entget ENT2))
          (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
           (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                  (progn
                   (setq ENTLIST (subst (cons 1 (rtos Z1 2 8)) (assoc 1 ENTLIST) ENTLIST))
                   (entmod ENTLIST)
                   (entupd ENT2)
                   (entupd ENT)
                  )
                 )
           )
           (setq ENT2 (entnext ENT2))
           (setq ENTLIST (entget ENT2))
          )
         )
        )
       )
       (if (= nil (setq P3 (getpoint "\nSelect third point (<return> for two points) : ")))
        (progn ; Two points
         (if OBSURFACE
          (setq P1 (list (car P1) (cadr P1))
                Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
                P2 (list (car P2) (cadr P2))
                Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)
          )
          (setq Z1 (caddr P1)
                P1 (list (car P1) (cadr P1))
                Z2 (caddr P2)
                P2 (list (car P2) (cadr P2))
          )
         )
         (if (and Z1 Z2)
          (progn
           (setq ENTLIST (entget ENT))
           (setq P (cdr (assoc 10 ENTLIST)))
           (setq P (list (car P) (cadr P)))
           (if (< Z2 Z1)
            (setq ANG (angle P1 P2))
            (setq ANG (angle P2 P1))
           )
           (setq ENTOBJ (vlax-ename->vla-object ENT))
           (vlax-put-property ENTOBJ 'Rotation ANG)
           (setq D (distance P1 P2))
           (setq D1 (/ (+ (- (expt (distance P1 P) 2) (expt (distance P2 P) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P) 2) (expt (distance P1 P) 2)) (expt D 2)) (* 2 D)))
           (setq Z (+ Z1 (* (- Z2 Z1) (/ D1 D))))
           (setq GRADE (* 100.0 (/ (- (max Z1 Z2) (min Z1 Z2)) D)))
           (setq ENT2 (entnext ENT))
           (setq ENTLIST (entget ENT2))
           (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
            (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos Z 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
                  ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos GRADE 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
            )
            (setq ENT2 (entnext ENT2))
            (setq ENTLIST (entget ENT2))
           )
          )
         )
        )
        (progn ; Three points
         (if OBSURFACE
          (setq P1 (list (car P1) (cadr P1))
                Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
                P2 (list (car P2) (cadr P2))
                Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)
                P3 (list (car P3) (cadr P3))
                Z3 (RFL:GETSURFACEPOINT P3 OBSURFACE)
          )
          (setq Z1 (caddr P1)
                P1 (list (car P1) (cadr P1))
                Z2 (caddr P2)
                P2 (list (car P2) (cadr P2))
                Z3 (caddr P3)
                P3 (list (car P3) (cadr P3))
          )
         )
         (if (and Z1 Z2 Z3)
          (progn
           (setq D (distance P1 P2))
           (setq D1 (/ (+ (- (expt (distance P1 P3) 2) (expt (distance P2 P3) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P3) 2) (expt (distance P1 P3) 2)) (expt D 2)) (* 2 D)))
           (setq D3 (sqrt (- (expt (distance P1 P3) 2) (expt D1 2))))
           (if (< (sin (- (angle P1 P2) (angle P1 P3))) 0.0) (setq D3 (* -1.0 D3)))
           (setq G1 (/ (- Z2 Z1) D))
           (setq P (list (+ (car P1) (* D1 (cos (angle P1 P2))))
                         (+ (cadr P1) (* D1 (sin (angle P1 P2))))
                   )
           )
           (setq Z (+ Z1 (* (- Z2 Z1) (/ D1 D))))
           (setq G2 (/ (- Z3 Z) D3))
           (setq ENTLIST (entget ENT))
           (setq P (cdr (assoc 10 ENTLIST)))
           (setq P (list (car P) (cadr P)))
           (setq D1 (/ (+ (- (expt (distance P1 P) 2) (expt (distance P2 P) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P) 2) (expt (distance P1 P) 2)) (expt D 2)) (* 2 D)))
           (setq D3 (sqrt (- (expt (distance P1 P) 2) (expt D1 2))))
           (if (< (sin (- (angle P1 P2) (angle P1 P))) 0.0) (setq D3 (* -1.0 D3)))
           (setq Z (+ Z1 (* D1 G1) (* D3 G2)))
           (setq GRADE (* 100.0 (sqrt (+ (expt G1 2) (expt G2 2)))))
           (setq ANG (+ 0.0 (- (angle P1 P2) (atan (/ G2 G1)))))
           (setq ENTOBJ (vlax-ename->vla-object ENT))
           (vlax-put-property ENTOBJ 'Rotation ANG)
           (setq ENT2 (entnext ENT))
           (setq ENTLIST (entget ENT2))
           (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
            (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos Z 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
                  ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos GRADE 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
            )
            (setq ENT2 (entnext ENT2))
            (setq ENTLIST (entget ENT2))
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 T
)
(defun C:TPROFROUNDABOUT (/ *error* ANGBASE ANGDIR CMDECHO ENT INC ORTHOMODE OSMODE P STA STA1 STA2 TMP Z)
 (command "._UNDO" "M")
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGBASE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "OSMODE" OSMODE)
  (princ msg)
  ;(setq *error* nil)
 )
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (if (and RFL:ALIGNLIST (RFL:GETROUNDABOUTLIST (setq ENT (car (entsel "\nSelect roundabout block : ")))))
  (progn
   (RFL:PROFDEF)
   (setq STA1 nil)
   (while (= nil STA1)
    (if (setq P (getpoint "\nStart point : "))
     (if (= nil (setq STA1 (car (RFL:STAOFF P))))
      (if (< (distance P (cadr (car RFL:ALIGNLIST))) (distance P (caddr (last RFL:ALIGNLIST))))
       (setq STA1 (caar RFL:ALIGNLIST))
       (setq STA1 (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
      )
     )
    )
   )
   (setq STA2 nil)
   (while (= nil STA2)
    (if (setq P (getpoint "\nEnd point : "))
     (if (= nil (setq STA2 (car (RFL:STAOFF P))))
      (if (< (distance P (cadr (car RFL:ALIGNLIST))) (distance P (caddr (last RFL:ALIGNLIST))))
       (setq STA2 (caar RFL:ALIGNLIST))
       (setq STA2 (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
      )
     )
    )
   )
   (setq INC 0.0)
   (while (<= INC 0.0)
    (if (= nil (setq INC (getdist "\nEnter increment <1> : ")))
     (setq INC 1.0)
    )
   )
   (if (< STA2 STA1) (setq TMP STA1 STA1 STA2 STA2 TMP))
   (setq STA (float (+ INC (* INC (fix (+ 0.5 (/ STA1 INC)))))))
   (command "._PLINE")
   (while (<= STA STA2)
    (if (setq P (RFL:XY (list STA 0.0)))
     (if (setq Z (RFL:CALCROUNDABOUTZ ENT P))
      (command (RFL:PROFPOINT STA Z))
     )
    )
    (setq STA (+ STA INC))
   )
   (command "")
  )
 )
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
 T
)