;
;
;    Program Written by Robert Livingston 00/03/07
;
;    ASPIRAL is a utility for attaching a spiral
;
;
(defun C:ASPIRAL (/ *error* A ANG ANG1 ANG2 ANGBASE ANGDIR CMDECHO DIR ENT ENTLIST
                    GETR L L0 LR LS MSG OSMODE P P1 P2 PC R R1 R2 SR1 SR2 THETA TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (defun *error* (msg)
  (command "._UCS" "P")
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (princ msg)
  ;(setq *error* nil)
 )

 (command "._UCS" "W")

 (defun GETR (ENT P / ENTLIST)
  (setq ENTLIST (entget ENT))
  (if (= "LINE" (cdr (assoc 0 ENTLIST)))
   (eval 0.0)
   (if (= "ARC" (cdr (assoc 0 ENTLIST)))
    (eval (cdr (assoc 40 ENTLIST)))
    (if (/= (setq ENTLIST (RFL:GETSPIRALDATA ENT)) nil)
     (if (< (distance P (nth 0 ENTLIST)) (distance P (nth 2 ENTLIST)))
      (if (= 0.0 (last ENTLIST))
       (eval 0.0)
       (/ (* (RFL:GETSPIRALR ENT) (RFL:GETSPIRALLS ENT)) (last ENTLIST))
      )
      (RFL:GETSPIRALR ENT)
     )
     (eval 0.0)
    )
   )
  )
 )

 (setq ENT (entsel))
 (if (/= ENT nil)
  (progn
   (setq P (nth 1 ENT))
   (setq P (list (nth 0 P) (nth 1 P)))
   (setq ENT (car ENT))
   (setq ENTLIST (entget ENT))
   (setq SR1 (getreal (strcat "\nEnter start radius (enter 0 for tangent) <" (rtos (GETR ENT P)) "> :")))
   (if (= SR1 nil) (setq SR1 (GETR ENT P)))
   (if (/= (setq SR2 (getreal "\nEnter end radius (enter 0 for tangent) :")) nil)
    (if (= SR1 SR2)
     (princ "\n*** Both ends can not be same radius! ***")
     (progn
      (setq LS nil)
      (while (= LS nil)
       (if (= AL "L")
        (progn
         (setq LS (getreal "Spiral length <return for A>:"))
         (if (= LS nil)
          (progn
           (setq AL "A")
          )
          (if (or (= 0.0 SR1) (= 0.0 SR2))
           (setq A (sqrt (* LS (max SR1 SR2))))
           (setq A (sqrt (abs (/ (* LS SR1 SR2) (- SR2 SR1)))))
          )
         )
        )
        (progn
         (setq A (getreal "Spiral A <return for length>:"))
         (if (= A nil)
          (progn
           (setq AL "L")
          )
          (if (or (= 0.0 SR1) (= 0.0 SR2))
           (setq LS (/ (* A A) (max SR1 SR2)))
           (setq LS (abs (/ (* A A (- SR2 SR1)) SR1 SR2)))
          )
         )
        )
       )
      )
      (if (or (= 0.0 SR1) (= 0.0 SR2))
       (setq L0 0.0)
       (setq L0 (- (/ (* A A) (min SR1 SR2)) LS))
      )
      (setq LS (+ LS L0))
      (initget 1 "Left Right")
      (setq LR (getkword "\n Left or Right : "))
      (if (= LR "Left")
       (setq DIR -1.0)
       (setq DIR 1.0)
      )
      (setq P1 nil ANG nil)
      (if (= (cdr (assoc 0 ENTLIST)) "LINE")
       (progn
        (setq P1 (cdr (assoc 10 ENTLIST)))
        (setq P1 (list (nth 0 P1) (nth 1 P1)))
        (setq P2 (cdr (assoc 11 ENTLIST)))
        (setq P2 (list (nth 0 P2) (nth 1 P2)))
        (if (< (distance P P2) (distance P P1))
         (progn
          (setq TMP P1)
          (setq P1 P2)
          (setq P2 TMP)
         )
        )
        (setq ANG (angle P2 P1))
       )
       (if (= (cdr (assoc 0 ENTLIST)) "ARC")
        (progn
         (setq PC (cdr (assoc 10 ENTLIST)))
         (setq PC (list (nth 0 PC) (nth 1 PC)))
         (setq R2 (cdr (assoc 40 ENTLIST)))
         (setq ANG1 (cdr (assoc 50 ENTLIST)))
         (setq ANG2 (cdr (assoc 51 ENTLIST)))
         (setq P1 (list (+ (nth 0 PC) (* R2 (cos ANG1)))
                        (+ (nth 1 PC) (* R2 (sin ANG1)))))
         (setq ANG1 (- ANG1 (/ pi 2.0)))
         (setq P2 (list (+ (nth 0 PC) (* R2 (cos ANG2)))
                        (+ (nth 1 PC) (* R2 (sin ANG2)))))
         (setq ANG2 (+ ANG2 (/ pi 2.0)))
         (setq ANG ANG1)
         (if (< (distance P P2) (distance P P1))
          (progn
           (setq TMP P1)
           (setq P1 P2)
           (setq P2 TMP)
           (setq ANG ANG2)
          )
         )
        )
        (if (/= (setq ENTLIST (RFL:GETSPIRALDATA ENT)) nil)
         (progn
          (setq TMP (nth 0 (RFL:SPIRALSTAOFF P ENT)))
          (if (< (- TMP (nth 3 ENTLIST)) (- (RFL:GETSPIRALLS ENT) TMP))
           (progn
            (setq P1 (RFL:SPIRALXY (list (nth 3 ENTLIST) 0.0) ENT))
            (setq ANG (angle (nth 1 ENTLIST) (nth 0 ENTLIST)))
            (if (> (nth 3 ENTLIST) 0.0)
             (progn
              (if (> (sin (- (angle (nth 1 ENTLIST) (nth 0 ENTLIST)) (angle (nth 2 ENTLIST) (nth 1 ENTLIST)))) 0.0)
               (setq TMP -1.0)
               (setq TMP 1.0)
              )
              (setq ANG (+ ANG
                           (* TMP
                              (expt (nth 3 ENTLIST) 2)
                              (RFL:GETSPIRALTHETA ENT)
                              (/ 1.0 (expt (RFL:GETSPIRALLS ENT) 2))
                           )
                        )
              )
             )
            )
           )
           (progn
            (setq P1 (nth 2 ENTLIST))
            (setq ANG (angle (nth 1 ENTLIST) (nth 2 ENTLIST)))
           )
          )
         )
         (progn
          (princ "\n*** ENTITY NOT SPIRAL/ARC/LINE ***")
         )
        )
       )
      )
      (if (/= nil P)
       (if (or (= SR1 0.0) (and (/= SR2 0.0) (> SR1 SR2)))
        (progn
         (if (= L0 0.0)
          (progn
           (setq R (max SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
           (setq P P1)
          )
          (progn
           (setq R (min SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
           (setq ANG2 (/ L0 (* 2.0 (max SR1 SR2))))
           (setq ANG (+ ANG (* DIR ANG2)))
           (setq P (list (+ (nth 0 P1) (* -1.0 (max SR1 SR2) (RFL:SPIRALFXR ANG2) (cos ANG)) (* -1.0 DIR (max SR1 SR2) (RFL:SPIRALFYR ANG2) (sin ANG)))
                         (+ (nth 1 P1) (* -1.0 (max SR1 SR2) (RFL:SPIRALFXR ANG2) (sin ANG)) (* DIR (max SR1 SR2) (RFL:SPIRALFYR ANG2) (cos ANG)))
                   )
           )
          )
         )
         (setq PLT P)
         (setq PST (list (+ (nth 0 P) (* R (RFL:SPIRALFXR THETA) (cos ANG)) (* DIR R (RFL:SPIRALFYR THETA) (sin ANG)))
                         (+ (nth 1 P) (* R (RFL:SPIRALFXR THETA) (sin ANG)) (* -1.0 DIR R (RFL:SPIRALFYR THETA) (cos ANG)))
                   )
         )
         (setq TMP (- (* R (RFL:SPIRALFXR THETA)) (/ (* R (RFL:SPIRALFYR THETA)) (RFL:TAN THETA))))
         (setq PLTST (list (+ (nth 0 P) (* TMP (cos ANG)))
                           (+ (nth 1 P) (* TMP (sin ANG)))
                     )
         )
         (RFL:DRAWSPIRAL PLT PLTST PST L0 0.0)
        )
        (progn
         (if (= L0 0.0)
          (progn
           (setq R (max SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
          )
          (progn
           (setq R (min SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
          )
         )
         (setq PST P1)
         (setq TMP (/ (* R (RFL:SPIRALFYR THETA)) (sin THETA)))
         (setq PLTST (list (+ (nth 0 P1) (* TMP (cos ANG)))
                           (+ (nth 1 P1) (* TMP (sin ANG)))
                     )
         )
         (setq TMP (- (* R (RFL:SPIRALFXR THETA)) (/ (* R (RFL:SPIRALFYR THETA)) (RFL:TAN THETA))))
         (setq ANG (+ (* -1.0 DIR THETA) ANG))
         (setq PLT (list (+ (nth 0 PLTST) (* TMP (cos ANG)))
                         (+ (nth 1 PLTST) (* TMP (sin ANG)))
                   )
         )
         (RFL:DRAWSPIRAL PLT PLTST PST L0 0.0)
        )
       )
      )
     )
    )
   )
  )
 )



 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
)
