;
;
;     Program written by Robert Livingston, 2017-09-18
;
;     ROUNDABOUT is a collection of utilities for grading roundabouts
;
;
(setq RFL:ROUNDABOUTLIST nil)
(defun RFL:GETROUNDABOUTLIST (ENT / CENTERGRADE CUT CUTDITCHDEPTH CUTDITCHSLOPE CUTDITCHWIDTH ELEV ENTLIST FILL INNERGRADE GRADE NAME RCENTER RIN ROUT SLOPE)
 (setq RFL:ROUNDABOUTLIST nil)
 (setq CENTERGRADE nil
       CUT nil
       CUTDITCHDEPTH nil
       CUTDITCHSLOPE nil
       CUTDITCHWIDTH nil
       ELEV nil
       FILL nil
       INNERGRADE nil
       GRADE nil
       NAME nil
       RCENTER nil
       RIN nil
       ROUT nil
       SLOPE nil
 )
 (if (and (/= nil (setq ENTLIST (entget ENT))) (= "INSERT" (cdr (assoc 0 ENTLIST))) (= 1 (cdr (assoc 66 ENTLIST))))
  (progn
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
    (cond ((= "NAME" (strcase (cdr (assoc 2 ENTLIST))))
           (setq NAME (cdr (assoc 1 ENTLIST)))
          )
          ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq SLOPE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
           (setq ELEV (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "GRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq GRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "INNERGRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq INNERGRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CENTERGRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CENTERGRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "ROUT" (strcase (cdr (assoc 2 ENTLIST))))
           (setq ROUT (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "RIN" (strcase (cdr (assoc 2 ENTLIST))))
           (setq RIN (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "RCENTER" (strcase (cdr (assoc 2 ENTLIST))))
           (setq RCENTER (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "FILL" (strcase (cdr (assoc 2 ENTLIST))))
           (setq FILL (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUT" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUT (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHSLOPE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHSLOPE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHDEPTH" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHDEPTH (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHWIDTH" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHWIDTH (atof (cdr (assoc 1 ENTLIST))))
          )
    )
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
   (if (or (= CENTERGRADE nil)
           (= CUT nil)
           (= CUTDITCHDEPTH nil)
           (= CUTDITCHSLOPE nil)
           (= CUTDITCHWIDTH nil)
           (= ELEV nil)
           (= FILL nil)
           (= INNERGRADE nil)
           (= GRADE nil)
           (= NAME nil)
           (= RCENTER nil)
           (= RIN nil)
           (= ROUT nil)
           (= SLOPE nil)
       )
    nil
    (progn
     (setq RFL:ROUNDABOUTLIST (list (cons "NAME" NAME)
                                    (cons "SLOPE" SLOPE)
                                    (cons "ELEV" ELEV)
                                    (cons "GRADE" GRADE)
                                    (cons "INNERGRADE" INNERGRADE)
                                    (cons "CENTERGRADE" CENTERGRADE)
                                    (cons "RCENTER" RCENTER)
                                    (cons "ROUT" ROUT)
                                    (cons "RIN" RIN)
                                    (cons "CUT" CUT)
                                    (cons "FILL" FILL)
                                    (cons "CUTDITCHSLOPE" CUTDITCHSLOPE)
                                    (cons "CUTDITCHDEPTH" CUTDITCHDEPTH)
                                    (cons "CUTDITCHWIDTH" CUTDITCHWIDTH)
                              )
     )
     T
    )
   )
  )
  nil
 )
)
(defun C:DRAWROUNDABOUT (/ *error* A ANG CCLIST CMDECHO CUT CUTOS DRAW3DP ELEV ENT ENTLIST FILL FIXLIST FLAG ICLIST MLIST N NMAX NODE NODE1 NODE2 OBSURFACE OGLINE OGOFFSETLIST ORTHOMODE OCLIST OSMODE P P1 P2 PLIST PLISTD PREVENT R RCENTER REP RIN ROUT SLOPE SWATH TOELIST X Y Z Z1 Z1CUT Z2)
 (command "._UNDO" "M")
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "OSMODE" OSMODE)
  (princ msg)
  (setq *error* nil)
 )
 (defun DRAW3DP (PLIST CLOSED / P)
  (command "._3DPOLY")
  (foreach P PLIST
   (command P)
  )
  (if CLOSED
   (command "C")
   (command "")
  )
  T
 )
 (defun FIXLIST (PLIST MINMAX / P Z)
  (setq TMPLIST nil Z nil)
  (if (= "MINIMUM" MINMAX)
   (setq Z (apply 'min (mapcar '(lambda (P) (caddr P)) PLIST)))
   (if (= "MAXIMUM" MINMAX)
    (setq Z (apply 'max (mapcar '(lambda (P) (caddr P)) PLIST)))
   )
  )
  (if Z
   (apply 'list (mapcar '(lambda (P) (list (car P) (cadr P) Z)) PLIST))
   PLIST
  )
 )
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 
 (setq PREVENT nil)
 (if (= nil (RFL:GETROUNDABOUTLIST (setq ENT (car (entsel "\nSelect roundabout block : ")))))
  (princ "\nProblem accessing roundabout data!")
  (progn
   (setq ELEV (cdr (assoc "ELEV" RFL:ROUNDABOUTLIST)))
   (setq ENTLIST (entget ENT))
   (setq NMAX 0)
   (while (< NMAX 3)
    (if (= nil (setq NMAX (getint "\nEnter number of circulatory segments <60> : ")))
     (setq NMAX 60)
    )
    (if (< NMAX 3) (princ "\nMust be at least 3!"))
   )
   (setq P (cdr (assoc 10 ENTLIST)))
   (setq P (list (car P) (cadr P) ELEV))
   (setq ANG (cdr (assoc 50 ENTLIST)))
   ; Compute outer circle elevations
   (setq SLOPE (cdr (assoc "SLOPE" RFL:ROUNDABOUTLIST)))
   (setq OCLIST nil)
   (setq ROUT (cdr (assoc "ROUT" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car P) (* ROUT (cos (+ A ANG)))))
    (setq Y (+ (cadr P) (* ROUT (sin (+ A ANG)))))
    (setq Z (- ELEV (* (/ SLOPE 100.0) (* ROUT (cos A)))))
    (setq OCLIST (append OCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute inner circle elevations
   (setq SLOPE (cdr (assoc "GRADE" RFL:ROUNDABOUTLIST)))
   (setq ICLIST nil)
   (setq RIN (cdr (assoc "RIN" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car P) (* RIN (cos (+ A ANG)))))
    (setq Y (+ (cadr P) (* RIN (sin (+ A ANG)))))
    (setq Z (+ (caddr (nth N OCLIST)) (* (/ SLOPE 100.0) (- ROUT RIN))))
    (setq ICLIST (append ICLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute mount circle elevations
   (setq SLOPE (cdr (assoc "INNERGRADE" RFL:ROUNDABOUTLIST)))
   (setq MCLIST nil)
   (setq RCENTER (cdr (assoc "RCENTER" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car P) (* RCENTER (cos (+ A ANG)))))
    (setq Y (+ (cadr P) (* RCENTER (sin (+ A ANG)))))
    (setq Z (+ (caddr (nth N OCLIST)) (* (/ SLOPE 100.0) (- ROUT RCENTER))))
    (setq MCLIST (append MCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute center circle elevations
   (setq SLOPE (cdr (assoc "INNERGRADE" RFL:ROUNDABOUTLIST)))
   (setq CCLIST nil)
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (car P))
    (setq Y (cadr P))
    (setq Z (+ (caddr (nth N MCLIST)) (* (/ SLOPE 100.0) (- 0.0 RCENTER))))
    (setq CCLIST (append CCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   (if CCLIST
    (progn
     (initget "GRADE MINIMUM MAXIMUM")
     (if (= nil (setq REP (getkword "\nInner apron: Use fixed grade, minimum or maximum (Grade/Minimum/<Maximum>) : ")))
      (setq REP "MAXIMUM")
     )
     (if (/= "GRADE" REP) (setq CCLIST (FIXLIST CCLIST REP)))
    )
   )
   ; Draw closed 3D outer, inner, and center circle polyline
   (DRAW3DP OCLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (DRAW3DP ICLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (DRAW3DP MCLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (DRAW3DP CCLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   
   (setq TOELIST nil)
   (if (setq OBSURFACE (RFL:GETC3DSURFACE))
    (progn
     (setq SWATH 0.0)
     (while (<= SWATH 0.0)
      (if (= nil (setq SWATH (getdist "\nEnter swath distance <100.0> : ")))
       (setq SWATH 100.0)
       (if (<= SWATH 0.0) (princ "\nMust be greater then 0.0!"))
      )
     )
     (setq FILL (cdr (assoc "FILL" RFL:ROUNDABOUTLIST)))
     (setq CUT (cdr (assoc "CUT" RFL:ROUNDABOUTLIST)))
     (setq N 0)
     (while (< N NMAX)
      (setq A (/ (* 2.0 pi N) NMAX))
      (setq OGLINE nil)
      (setq P1 (nth N OCLIST))
      (setq Z1 (caddr P1))
      (setq Z1CUT (- Z1 (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))))
      (setq CUTOS (+ (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                        (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                     )
                     (cdr (assoc "CUTDITCHWIDTH" RFL:ROUNDABOUTLIST))
                  )
      )
      (setq P1 (list (car P1) (cadr P1)))
      (setq P2 (list (+ (car P1) (* SWATH (cos (+ A ANG))))
                     (+ (cadr P1) (* SWATH (sin (+ A ANG))))
               )
      )
      (setq PLIST (list (nth N CCLIST)
                        (nth N MCLIST)
                        (nth N ICLIST)
                        (nth N OCLIST)
                  )
      )
      (if (/= nil (setq OGLINE (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
       (progn
        (setq OGOFFSETLIST nil)
        (foreach NODE OGLINE
         (setq OGOFFSETLIST (append OGOFFSETLIST (list (list (distance P1 (list (car NODE) (cadr NODE))) (caddr NODE)))))
        )
        (setq NODE1 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
              NODE2 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
        )
        (setq FLAG T)
        (setq P2 nil)
        (setq PLISTD nil)
        (while (and FLAG NODE1 NODE2)
         (if (setq P2 (inters NODE1 NODE2 (list 0.0 Z1) (list SWATH (- Z1 (/ SWATH FILL)))))
          (progn
           (setq FLAG nil)
           (setq PLISTD (list (list (+ (car P1) (* (car P2) (cos (+ A ANG))))
                                    (+ (cadr P1) (* (car P2) (sin (+ A ANG))))
                                    (cadr P2)
                              )
                        )
           )
          )
         )
         (if (= nil P2)
          (if (and (setq P2 (inters NODE1 NODE2 (list CUTOS Z1CUT) (list SWATH (+ Z1CUT (/ (- SWATH CUTOS) CUT)))))
                   (<= CUTOS (car P2))
              )
           (progn
            (setq FLAG nil)
            (setq PLISTD (list (list (+ (car P1) 
                                        (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                                           (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                                           (cos (+ A ANG))
                                        )
                                     )
                                     (+ (cadr P1)
                                        (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                                           (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                                           (sin (+ A ANG))
                                        )
                                     )
                                     Z1CUT
                                )
                                (list (+ (car P1) 
                                         (* CUTOS
                                            (cos (+ A ANG))
                                         )
                                      )
                                      (+ (cadr P1)
                                         (* CUTOS
                                            (sin (+ A ANG))
                                         )
                                      )
                                      Z1CUT
                                )
                                (list (+ (car P1) (* (car P2) (cos (+ A ANG))))
                                      (+ (cadr P1) (* (car P2) (sin (+ A ANG))))
                                      (cadr P2)
                                )
                         )
            )
           )
          )
         )
         (setq NODE1 NODE2
               NODE2 (car OGOFFSETLIST)
               OGOFFSETLIST (cdr OGOFFSETLIST)
         )
        )
       )
      )
      (if PLISTD (setq PLIST (append PLIST PLISTD)))
      (if PLIST
       (progn
        (setq TOELIST (append TOELIST (list (last PLIST))))
        (DRAW3DP PLIST nil)
        (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
       )
      )
      (setq N (1+ N))
     )
     (if TOELIST
      (progn
       (DRAW3DP TOELIST T)
       (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      )
     )
    )
   )
  )
 )
 
 (setvar "CMDECHO" CMDECHO)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
 T
)
(defun C:FIXROUNDABOUT (/ ACTIVEDOC ACTIVESPACE ANG D D1 D2 D3 ENT ENT2 ENTLIST ENTOBJ GRADE OBSURFACE P P1 P2 P3 Z Z1 Z2 Z3)
 (command "._UNDO" "M")
 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )
 (if (setq ENT (car (entsel "\nSelect roundabout block : ")))
  (progn
   (setq ENTLIST (entget ENT))
   (if (and (= "INSERT" (cdr (assoc 0 ENTLIST)))
            (= "ROUNDABOUT" (strcase (cdr (assoc 2 ENTLIST))))
            (= 1 (cdr (assoc 66 ENTLIST)))
       )
    (progn
     (princ "\nNote: Selecting no surface will use elevation of selected points.")
     (setq OBSURFACE (RFL:GETC3DSURFACE))
     (princ "\nNote: 1 point  = roundabout elevation adjusted to elevation of point, slope set to 0.0%")
     (princ "\n      2 points = roundabout elevation adjusted to average elevation of points, slope and rotation adjusted")
     (princ "\n      3 points = roundabout elevation adjusted to elevation of point on plane, slope and rotation adjusted")
     (setq P1 nil P2 nil P3 nil)
     (if (/= nil (setq P1 (getpoint "\nSelect first point : ")))
      (if (= nil (setq P2 (getpoint "\nSelect second point (<return> for single point) : ")))
       (progn ; Single point
        (if OBSURFACE
         (setq P1 (list (car P1) (cadr P1))
               Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
         )
         (setq Z1 (caddr P1)
               P1 (list (car P1) (cadr P1))
         )
        )
        (if Z1
         (progn
          (setq ENT2 (entnext ENT))
          (setq ENTLIST (entget ENT2))
          (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
           (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                  (progn
                   (setq ENTLIST (subst (cons 1 (rtos Z1 2 8)) (assoc 1 ENTLIST) ENTLIST))
                   (entmod ENTLIST)
                   (entupd ENT2)
                   (entupd ENT)
                  )
                 )
           )
           (setq ENT2 (entnext ENT2))
           (setq ENTLIST (entget ENT2))
          )
         )
        )
       )
       (if (= nil (setq P3 (getpoint "\nSelect third point (<return> for two points) : ")))
        (progn ; Two points
         (if OBSURFACE
          (setq P1 (list (car P1) (cadr P1))
                Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
                P2 (list (car P2) (cadr P2))
                Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)
          )
          (setq Z1 (caddr P1)
                P1 (list (car P1) (cadr P1))
                Z2 (caddr P2)
                P2 (list (car P2) (cadr P2))
          )
         )
         (if (and Z1 Z2)
          (progn
           (setq ENTLIST (entget ENT))
           (setq P (cdr (assoc 10 ENTLIST)))
           (setq P (list (car P) (cadr P)))
           (if (< Z2 Z1)
            (setq ANG (angle P1 P2))
            (setq ANG (angle P2 P1))
           )
           (setq ENTOBJ (vlax-ename->vla-object ENT))
           (vlax-put-property ENTOBJ 'Rotation ANG)
           (setq D (distance P1 P2))
           (setq D1 (/ (+ (- (expt (distance P1 P) 2) (expt (distance P2 P) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P) 2) (expt (distance P1 P) 2)) (expt D 2)) (* 2 D)))
           (setq Z (+ Z1 (* (- Z2 Z1) (/ D1 D))))
           (setq GRADE (* 100.0 (/ (- (max Z1 Z2) (min Z1 Z2)) D)))
           (setq ENT2 (entnext ENT))
           (setq ENTLIST (entget ENT2))
           (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
            (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos Z 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
                  ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos GRADE 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
            )
            (setq ENT2 (entnext ENT2))
            (setq ENTLIST (entget ENT2))
           )
          )
         )
        )
        (progn ; Three points
         (if OBSURFACE
          (setq P1 (list (car P1) (cadr P1))
                Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
                P2 (list (car P2) (cadr P2))
                Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)
                P3 (list (car P3) (cadr P3))
                Z3 (RFL:GETSURFACEPOINT P3 OBSURFACE)
          )
          (setq Z1 (caddr P1)
                P1 (list (car P1) (cadr P1))
                Z2 (caddr P2)
                P2 (list (car P2) (cadr P2))
                Z3 (caddr P3)
                P3 (list (car P3) (cadr P3))
          )
         )
         (if (and Z1 Z2 Z3)
          (progn
           (setq D (distance P1 P2))
           (setq D1 (/ (+ (- (expt (distance P1 P3) 2) (expt (distance P2 P3) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P3) 2) (expt (distance P1 P3) 2)) (expt D 2)) (* 2 D)))
           (setq D3 (sqrt (- (expt (distance P1 P3) 2) (expt D1 2))))
           (if (< (sin (- (angle P1 P2) (angle P1 P3))) 0.0) (setq D3 (* -1.0 D3)))
           (setq G1 (/ (- Z2 Z1) D))
           (setq P (list (+ (car P1) (* D1 (cos (angle P1 P2))))
                         (+ (cadr P1) (* D1 (sin (angle P1 P2))))
                   )
           )
           (setq Z (+ Z1 (* (- Z2 Z1) (/ D1 D))))
           (setq G2 (/ (- Z3 Z) D3))
           (setq ENTLIST (entget ENT))
           (setq P (cdr (assoc 10 ENTLIST)))
           (setq P (list (car P) (cadr P)))
           (setq D1 (/ (+ (- (expt (distance P1 P) 2) (expt (distance P2 P) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P) 2) (expt (distance P1 P) 2)) (expt D 2)) (* 2 D)))
           (setq D3 (sqrt (- (expt (distance P1 P) 2) (expt D1 2))))
           (if (< (sin (- (angle P1 P2) (angle P1 P))) 0.0) (setq D3 (* -1.0 D3)))
           (setq Z (+ Z1 (* D1 G1) (* D3 G2)))
           (setq GRADE (* 100.0 (sqrt (+ (expt G1 2) (expt G2 2)))))
           (setq ANG (+ pi (- (angle P1 P2) (atan (/ G2 G1)))))
           (setq ENTOBJ (vlax-ename->vla-object ENT))
           (vlax-put-property ENTOBJ 'Rotation ANG)
           (setq ENT2 (entnext ENT))
           (setq ENTLIST (entget ENT2))
           (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
            (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos Z 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
                  ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos GRADE 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
            )
            (setq ENT2 (entnext ENT2))
            (setq ENTLIST (entget ENT2))
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
 T
)