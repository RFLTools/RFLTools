;
;
;     Program written by Robert Livingston, 2009-11-25
;
;     VCDTAN is a routine for drawing tangents off of vertical curves.
;
;
(defun C:VCDTAN (/ *error* A ANGBASE ANGDIR B C D G1 G2 ORTHOMODE OSMODE P1 P2 P3 PLIST ROUNDSLOPE S SA SB SC X X0A X0B X1 X2 X3 XB Y Y0A Y0B Y1 Y2 Y3 YB TMP VEXAG)
 (if (= nil vlax-create-object) (vl-load-com))
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  ;(setq *error* nil)
  (print msg)
 )
 (setvar "ANGDIR" 0)
 (command "._UCS" "W")
 (command "._UNDO" "M")

 (setq PLIST (RFL:GETVCURVE3P))
 (setq P1 (car PLIST) P2 (cadr PLIST) P3 (caddr PLIST) VEXAG (cadddr PLIST))

 (if (and (/= nil P1) (/= nil P2) (/= nil P3))
  (progn
   (if (= VEXAG nil)
    (progn
     (if (= nil VCURVEVEXAG) (setq VCURVEVEXAG 10.0))
     (setq VEXAG (getdist (strcat "\nVertical exaggeration <" (rtos VCURVEVEXAG) "> : ")))
     (if (= nil VEXAG)
      (setq VEXAG VCURVEVEXAG)
      (setq VCURVEVEXAG VEXAG)
     )
    )
   )
   (if (= nil VCURVETANROUND) (setq VCURVETANROUND 0.1))
   (setq ROUNDSLOPE (getdist (strcat "\nRound slope to nearest <" (rtos VCURVETANROUND) "> : ")))
   (if (= nil ROUNDSLOPE)
    (setq ROUNDSLOPE VCURVETANROUND)
    (setq VCURVETANROUND ROUNDSLOPE)
   )
   (setq ROUNDSLOPE (* ROUNDSLOPE VEXAG 0.01))
   (setq X1 (nth 0 P1))
   (setq Y1 (nth 1 P1))
   (setq X2 (nth 0 P2))
   (setq Y2 (nth 1 P2))
   (setq X3 (nth 0 P3))
   (setq Y3 (nth 1 P3))
   (setq G1 (/ (- Y2 Y1) (- X2 X1)))
   (setq G2 (/ (- Y3 Y2) (- X3 X2)))
   (setq A (/ (- G2 G1) (- X3 X1) 2.0))
   (setq B (/ (- G2 (* G1 (/ X3 X1))) (- 1.0 (/ X3 X1))))
   (setq C (- Y1 (+ (* A X1 X1) (* B X1))))
   (while (= (car (setq TMP (grread nil 1))) 5)
    (setq X (caadr TMP))
    (setq Y (cadadr TMP))
    (command "._REDRAW")
    (setq SA A)
    (setq SB (* -2.0 A X))
    (setq SC (- Y C (* B X)))
    (if (> (- (* SB SB) (* 4.0 SA SC)) 0.0)
     (progn
      (setq X0A (/ (+ (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
      (setq Y0A (+ (* A X0A X0A) (* B X0A) C))
      (setq X0B (/ (- (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
      (setq Y0B (+ (* A X0B X0B) (* B X0B) C))
      (if (> X0A X0B)
       (progn
        (setq TMP X0A)
        (setq X0A X0B)
        (setq X0B TMP)
        (setq TMP Y0A)
        (setq Y0A Y0B)
        (setq Y0B TMP)
       )
      )
      (if (< (nth 0 P2) X)
       (progn
        (setq XB X0A YB Y0A)
       )
       (progn
        (setq XB X0B YB Y0B)
       )
      )
      (setq D (distance (list XB YB) (list X Y)))
      (setq S (/ (- Y YB) (- X XB)))
      (if (> S 0.0) (setq TMP 1.0) (setq TMP -1.0))
      (setq S (abs S))
      (setq S (* TMP (* (float (fix (+ 0.5 (/ S ROUNDSLOPE)))) ROUNDSLOPE)))
      (setq XB (/ (- S B) (* 2.0 A)))
      (setq YB (+ (* A XB XB) (* B XB) C))
      (if (< (nth 0 P2) X)
       (progn
        (setq X (+ XB (* D (cos (atan S)))))
        (setq Y (+ YB (* D (sin (atan S)))))
       )
       (progn
        (setq X (- XB (* D (cos (atan S)))))
        (setq Y (- YB (* D (sin (atan S)))))
       )
      )
      (grdraw (list XB YB) (list X Y) 7)
     )
    )
   )
   (command "._REDRAW")
   (if (> (- (* SB SB) (* 4.0 SA SC)) 0.0)
    (command "._LINE" (list XB YB) (list X Y) "")
    (princ "\nBad Point!")
   )
  )
 )
 (command "._UCS" "P")
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
)