;
;
;     Program written by Robert Livingston, 2001/01/11
;
;     RFL:3DP2ALIGN converts a 3d polyline to horizontal and vertical alignments
;
;
(defun RFL:3DP2ALIGN (ENT STA / ENTLIST L P1 P2)
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (/= (cdr (assoc 0 ENTLIST)) "POLYLINE")
    (princ "\n*****  Not a polyline!  *****")
    (progn
     (if (= 0 (logand (cdr (assoc 70 ENTLIST)) 8))
      (princ "\n*****  Not a 3d polyline!  *****")
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P2 (cdr (assoc 10 ENTLIST)))
       (setq RFL:PVILIST (list (list STA
                                 (nth 2 P2)
                                 "L"
                                 0.0
                           )
                     )
       )
       (setq RFL:ALIGNLIST nil)
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
        (setq P1 P2)
        (setq P2 (cdr (assoc 10 ENTLIST)))
        (setq L (distance (list (nth 0 P1) (nth 1 P1)) (list (nth 0 P2) (nth 1 P2))))
        (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list STA
                                                              (list (nth 0 P1) (nth 1 P1))
                                                              (list (nth 0 P2) (nth 1 P2))
                                                              0.0
                                                        )
                                                  )
                            )
        )
        (setq STA (+ STA L))
        (setq RFL:PVILIST (append RFL:PVILIST (list (list STA
                                                          (nth 2 P2)
                                                          "L"
                                                          0.0
                                                    )
                                              )
                          )
        )
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
       )
      )
     )
    )
   )
  )
 )
)(defun RFL:AXY (AL STA SWATH / ALSAVE ENTLIST OFFSET1 OFFSET2 OFFSET3 P1 P2 P3)
 (setq ENTLIST (entget ENT))
 (if (= (cdr (assoc 0 ENTLIST)) "LWPOLYLINE")
  (progn
   (setq P1 (RFL:XY (list STA (/ SWATH -2.0))))
   (setq P2 (RFL:XY (list STA (/ SWATH 2.0))))
   (if (and (/= P1 nil) (/= P2 nil))
    (progn
     (setq ALSAVE RFL:ALIGNLIST)
     (setq RFL:ALIGNLIST AL)
     (if (= nil RFL:ALIGNLIST)
      (progn
       (setq RFL:ALIGNLIST ALSAVE)
       (eval nil)
      )
      (progn
       (setq OFFSET1 (RFL:STAOFF P1))
       (setq OFFSET2 (RFL:STAOFF P2))
       (setq P3 (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))
       (setq OFFSET3 (RFL:STAOFF P3))
       (if (= OFFSET1 nil)
        (progn
         (setq P1 P3)
         (setq OFFSET1 OFFSET3)
        )
       )
       (if (= OFFSET2 nil)
        (progn
         (setq P2 P3)
         (setq OFFSET2 OFFSET3)
        )
       )
       (if (and (/= OFFSET1 nil) (/= OFFSET2 nil))
        (progn
         (setq OFFSET1 (cadr OFFSET1))
         (setq OFFSET2 (cadr OFFSET2))
         (if (> (* OFFSET1 OFFSET2) 0.0)
          (progn
           (setq RFL:ALIGNLIST ALSAVE)
           (eval nil)
          )
          (progn
           (while (> (distance P1 P2) RFL:TOL)
            (setq P3 (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))
            (setq OFFSET3 (cadr (RFL:STAOFF P3)))
            (if (> (* OFFSET1 OFFSET3) 0.0)
             (setq P1 P3)
             (setq P2 P3)
            )
           )
           (setq RFL:ALIGNLIST ALSAVE)
           (setq P3 P3)
          )
         )
        )
        (progn
         nil
        )
       )
      )
     )
    )
    (progn
     nil
    )
   )
  )
  (progn
   nil
  )
 )
)
;
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:ALIGNDEF returns an RFL Alignment list based on either a single polyline of a set of entities.
;
;
;
(defun RFL:ALIGNDEF (ALIGNENT PSTART STASTART / ALIGNENTLIST ALIGNENTSET AL BULGE FINDENT P P1 P2 R RFLAG STA)
 (setq AL nil)
 (setq RFL:TOL 0.000001)
 (setq RFLAG 1.0)
 (setq STA STASTART)
 (defun FINDENT (P ALIGNENTSET / ANG ANG1 ANG2 BULGE C ENT ENT2 ENT3 ENTLIST FOUND L P1 P2 PC R TMP)
  (setq C 0)
  (setq ENT nil)
  (setq FOUND 0)
  (while (and (= FOUND 0) (< C (sslength ALIGNENTSET)))
   (setq ENT2 (ssname ALIGNENTSET C))
   (setq ENTLIST (entget ENT2))
   (if (= (cdr (assoc 0 ENTLIST)) "LINE")
    (progn
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq P1 (list (car P1) (cadr P1)))
     (setq P2 (cdr (assoc 11 ENTLIST)))
     (setq P2 (list (car P2) (cadr P2)))
     (setq L (distance P1 P2))
     (setq BULGE 0.0)
     (if (< (distance P P1) RFL:TOL)
      (progn
       (setq FOUND 1)
       (setq ENT ENT2)
      )
     )
     (if (< (distance P P2) RFL:TOL)
      (progn
       (setq FOUND 1)
       (setq ENT ENT2)
       (setq TMP P1)
       (setq P1 P2)
       (setq P2 TMP)
      )
     )
    )
   )
   (if (= (cdr (assoc 0 ENTLIST)) "ARC")
    (progn
     (setq PC (cdr (assoc 10 ENTLIST)))
     (setq R (cdr (assoc 40 ENTLIST)))
     (setq ANG1 (cdr (assoc 50 ENTLIST)))
     (setq P1 (list (+ (car PC) (* R (cos ANG1)))
                    (+ (cadr PC) (* R (sin ANG1)))))
     (setq ANG2 (cdr (assoc 51 ENTLIST)))
     (setq P2 (list (+ (car PC) (* R (cos ANG2)))
                    (+ (cadr PC) (* R (sin ANG2)))))
     (setq ANG (- ANG2 ANG1))
     (if (< ANG 0.0)
      (setq ANG (+ ANG (* 2.0 pi)))
     )
     (setq L (* R ANG))
     (setq BULGE (RFL:TAN (/ ANG 4.0)))

     (if (< (distance P P1) RFL:TOL)
      (progn
       (setq FOUND 1)
       (setq ENT ENT2)
      )
     )
     (if (< (distance P P2) RFL:TOL)
      (progn
       (setq FOUND 1)
       (setq ENT ENT2)
       (setq BULGE (* -1.0 BULGE))
       (setq TMP P1)
       (setq P1 P2)
       (setq P2 TMP)
      )
     )
    )
   )
   (if (= (cdr (assoc 0 ENTLIST)) "POLYLINE")
    (progn
     (setq L (RFL:GETSPIRALLS ENT2))
     (if (/= L nil)
      (progn
       (setq ENT3 (entnext ENT2))
       (setq ENTLIST (entget ENT3))
       (setq P1 (cdr (assoc 10 ENTLIST)))
       (setq P1 (list (car P1) (cadr P1)))
       (setq ENT3 (entnext ENT3))
       (setq ENTLIST (entget ENT3))
       (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
        (setq P2 (cdr (assoc 10 ENTLIST)))
        (setq P2 (list (car P2) (cadr P2)))
        (setq ENT3 (entnext ENT3))
        (setq ENTLIST (entget ENT3))
       )
       (setq BULGE (RFL:GETSPIRALDATA ENT2))
       (setq L (- L (last BULGE)))
       (if (< (distance P P1) RFL:TOL)
        (progn
         (setq FOUND 1)
         (setq ENT ENT2)
        )
       )
       (if (< (distance P P2) RFL:TOL)
        (progn
         (setq FOUND 1)
         (setq ENT ENT2)
         (setq TMP P1)
         (setq P1 P2)
         (setq P2 TMP)
        )
       )
      )
     )
    )
   )
   (if (= (cdr (assoc 0 ENTLIST)) "LWPOLYLINE")
    (progn
     (setq L (RFL:GETSPIRALLS ENT2))
     (if (/= L nil)
      (progn
       (setq P1 (cdr (assoc 10 ENTLIST)))
       (setq P2 (cdr (assoc 10 (reverse ENTLIST))))
       (setq BULGE (RFL:GETSPIRALDATA ENT2))
       (setq L (- L (last BULGE)))
       (if (< (distance P P1) RFL:TOL)
        (progn
         (setq FOUND 1)
         (setq ENT ENT2)
        )
       )
       (if (< (distance P P2) RFL:TOL)
        (progn
         (setq FOUND 1)
         (setq ENT ENT2)
         (setq TMP P1)
         (setq P1 P2)
         (setq P2 TMP)
        )
       )
      )
     )
    )
   )
   (setq C (+ C 1))
  )
  (if (= FOUND 0)
   (eval nil)
   (list ENT P1 P2 BULGE L)
  )
 )
 (if (listp ALIGNENT)
  (progn
   (setq ALIGNENTSET (car ALIGNENT))
   (setq P PSTART)
   (while (/= (setq ALIGNENT (FINDENT P ALIGNENTSET)) nil)
    (setq ALIGNENTSET (ssdel (car ALIGNENT) ALIGNENTSET))
    (setq P1 (cadr ALIGNENT))
    (setq P2 (caddr ALIGNENT))
    (setq BULGE (cadddr ALIGNENT))
    (setq AL (append AL (list (list STA P1 P2 BULGE))))
    (setq STA (+ STA (nth 4 ALIGNENT)))
    (setq P P2)
   )
  )
  (progn
   (setq ALIGNENTLIST (entget ALIGNENT))
   (if (= (cdr (assoc 0 ALIGNENTLIST)) "LWPOLYLINE")
    (progn
     (setq P1 (cdr (assoc 10 ALIGNENTLIST)))
     (if (> (distance P1 PSTART) RFL:TOL)
      (progn
       (setq RFLAG -1.0)
       (setq ALIGNENTLIST (reverse ALIGNENTLIST))
      )
     )
     (setq P1 (cdr (assoc 10 ALIGNENTLIST)))
     (if (< (distance P1 PSTART) RFL:TOL)
      (progn
       (while (/= (car (car ALIGNENTLIST)) 10)
        (setq ALIGNENTLIST (cdr ALIGNENTLIST))
       )
       (setq P1 (cdr (car ALIGNENTLIST)))
       (setq P1 (list (car P1) (cadr P1)))
       (setq ALIGNENTLIST (cdr ALIGNENTLIST))
       (setq BULGE 0.0)
       (while (/= ALIGNENTLIST nil)
        (cond ((= (car (car ALIGNENTLIST)) 42)
               (setq BULGE (* RFLAG (cdr (car ALIGNENTLIST))))
              )
              ((= (car (car ALIGNENTLIST)) 10)
               (progn
                (setq P2 (cdr (car ALIGNENTLIST)))
                (setq P2 (list (car P2) (cadr P2)))
                (setq AL (append AL (list (list STA P1 P2 BULGE))))
                (setq STA (+ STA (RFL:ARCLENGTH P1 P2 BULGE)))
                (setq P1 P2)
                (setq BULGE 0.0)
               )
              )
        )
        (setq ALIGNENTLIST (cdr ALIGNENTLIST))
       )
      )
      (princ "\n**** POINT NOT AT START OF ALIGNMENT ****")
     )
    )
    (progn
     (eval nil)
    )
   )
  )
 )
 AL
)
;
;
;     Program written by Robert Livingston, 98/06/12
;
;     RFL:ARCLENGTH returns the length of an arc defined by 2 points and a bulge
;
;
(defun RFL:ARCLENGTH (P1 P2 BULGE / ATOTAL CHORD R)
 (if (listp BULGE)
  (- (RFL:GETSPIRALLS2 (car BULGE) (cadr BULGE) (caddr BULGE)) (cadddr BULGE))
  (progn
   (setq ATOTAL (* 4 (atan (abs BULGE)))
         CHORD (distance P1 P2)
   )
   (if (= 0.0 BULGE)
    CHORD
    (progn 
     (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
     (* R ATOTAL)
    )
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 99/12/03
;
;   RFL:DIST returns the length of an alignment entity
;
;
(defun RFL:DIST (P1 P2 BULGE / ATOTAL CHORD R)
 (if (listp BULGE)
  (progn
   (- (RFL:GETSPIRALLS2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)) (nth 3 BULGE))
  )
  (progn
   (setq ATOTAL (* 4.0 (atan (abs BULGE))))
   (setq CHORD (distance P1 P2))
   (if (= 0.0 BULGE)
    (eval CHORD)
    (progn 
     (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
     (* R ATOTAL)
    )
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:DRAWALIGN draws the current alignmnet for alignments without spirals
;
;
;
(defun RFL:DRAWALIGN (/ ALLIST ALENT ENTLIST)
 (setq ALLIST RFL:ALIGNLIST)
 (entmake)
 (setq ENTLIST (list (cons 0 "POLYLINE")
                     (cons 66 1)))
 (entmake ENTLIST)
 (while (/= ALLIST nil)
  (setq ALENT (car ALLIST))
  (setq ALLIST (cdr ALLIST))
  (setq ENTLIST (list (cons 0 "VERTEX")
                      (append (list 10) (nth 1 ALENT))
                      (cons 42 (nth 3 ALENT))
                )
  )
  (entmake ENTLIST)
  (if (= ALLIST nil)
   (progn
    (setq ENTLIST (list (cons 0 "VERTEX")
                        (append (list 10) (nth 2 ALENT))
                  )
    )
    (entmake ENTLIST)
   )
  )
 )
 (setq ENTLIST (list (cons 0 "SEQEND")))
 (entmake ENTLIST)
 (command "._convert" "P" "S" (entlast) "")
);
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:DRAWALIGN2 draws the current alignmnet
;
;
;
(defun RFL:DRAWALIGN2 (/ ANG1 ANG2 ALLIST ALENT ENT ENTLIST PC PREVENT R)
 (setq ALLIST RFL:ALIGNLIST)
 (entmake)
 (while (/= ALLIST nil)
  (setq ALENT (car ALLIST))
  (setq ALLIST (cdr ALLIST))
  (if (listp (last ALENT))
   (progn
    (RFL:DRAWSPIRAL (nth 0 (last ALENT)) (nth 1 (last ALENT)) (nth 2 (last ALENT)) (nth 3 (last ALENT)) 0.0)
    (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   )
   (progn
    (if (> (abs (last ALENT)) RFL:TOLFINE)
     (progn
      (setq PC (RFL:CENTER (nth 1 ALENT) (nth 2 ALENT) (nth 3 ALENT)))
      (setq R (RFL:RADIUS (nth 1 ALENT) (nth 2 ALENT) (nth 3 ALENT)))
      (if (< (last ALENT) 0.0)
       (progn
        (setq ANG2 (angle PC (nth 1 ALENT)))
        (setq ANG1 (angle PC (nth 2 ALENT)))
       )
       (progn
        (setq ANG1 (angle PC (nth 1 ALENT)))
        (setq ANG2 (angle PC (nth 2 ALENT)))
       )
      )
      (setq ENTLIST (list (cons 0 "ARC")
                          (list 10 (nth 0 PC) (nth 1 PC) 0.0)
                          (cons 40 R)
                          (cons 50 ANG1)
                          (cons 51 ANG2)
                    )
      )
      (entmake ENTLIST)
      (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
     )
     (progn
      (setq ENTLIST (list (cons 0 "LINE")
                          (list 10 (nth 0 (nth 1 ALENT)) (nth 1 (nth 1 ALENT)) 0.0)
                          (list 11 (nth 0 (nth 2 ALENT)) (nth 1 (nth 2 ALENT)) 0.0)
                    )
      )
      (entmake ENTLIST)
      (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
     )
    )
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:DRAWALIGNOS draws the current alignmnet at the specified offset
;
;
;
(defun RFL:DRAWALIGNOS (OS / ALLIST ALENT ENTLIST)
 (RFL:DRAWALIGNOS2 OS)
)
;
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:DRAWALIGNOS2 draws the current alignmnet at the specified offset
;
;
;
(defun RFL:DRAWALIGNOS2 (OS / ANG ANG1 ANG2 ALLIST ALENT ENT ENTLIST OS2 P1X P1Y P2X P2Y PC PREVENT R)
 (setq PREVENT nil)
 (setq ALLIST RFL:ALIGNLIST)
 (entmake)
 (while (/= ALLIST nil)
  (setq ALENT (car ALLIST))
  (setq ALLIST (cdr ALLIST))
  (if (listp (last ALENT))
   (progn
    (if (< (distance (nth 2 ALENT) (nth 2 (last ALENT))) (distance (nth 1 ALENT) (nth 2 (last ALENT))))
     (setq OS2 OS)
     (setq OS2 (* -1.0 OS))
    )
    (RFL:DRAWSPIRAL (nth 0 (last ALENT)) (nth 1 (last ALENT)) (nth 2 (last ALENT)) (nth 3 (last ALENT)) OS2)
    (setq ENT (entlast))
    (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   )
   (progn
    (if (> (abs (last ALENT)) RFL:TOLFINE)
     (progn
      (setq PC (RFL:CENTER (nth 1 ALENT) (nth 2 ALENT) (nth 3 ALENT)))
      (setq R (RFL:RADIUS (nth 1 ALENT) (nth 2 ALENT) (nth 3 ALENT)))
      (if (> (last ALENT) 0.0)
       (progn
        (setq OS2 OS)
        (setq ANG1 (angle PC (nth 1 ALENT)))
        (setq ANG2 (angle PC (nth 2 ALENT)))
       )
       (progn
        (setq OS2 (* -1.0 OS))
        (setq ANG2 (angle PC (nth 1 ALENT)))
        (setq ANG1 (angle PC (nth 2 ALENT)))
       )
      )
      (setq ENTLIST (list (cons 0 "ARC")
                          (list 10 (nth 0 PC) (nth 1 PC) 0.0)
                          (cons 40 (+ R OS2))
                          (cons 50 ANG1)
                          (cons 51 ANG2)
                    )
      )
      (entmake ENTLIST)
      (setq ENT (entlast))
      (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
     )
     (progn
      (setq ANG (angle (nth 1 ALENT) (nth 2 ALENT)))
      (setq P1X (+ (nth 0 (nth 1 ALENT)) (* OS (sin ANG))))
      (setq P1Y (- (nth 1 (nth 1 ALENT)) (* OS (cos ANG))))
      (setq P2X (+ (nth 0 (nth 2 ALENT)) (* OS (sin ANG))))
      (setq P2Y (- (nth 1 (nth 2 ALENT)) (* OS (cos ANG))))
      (setq ENTLIST (list (cons 0 "LINE")
                          (list 10 P1X P1Y 0.0)
                          (list 11 P2X P2Y 0.0)
                    )
      )
      (entmake ENTLIST)
      (setq ENT (entlast))
      (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
     )
    )
   )
  )
 )
)
;
;
;     Program written by Robert Livingston, 2017-04-11
;
;     RFL:ESTRADIUS estimates the radius at a given station by finding points within a distance D
;
;
(setq RFL:ESTRADIUSDIST 30.0)
(setq RFL:ESTRADIUSNUMPOINTS 10)
(defun RFL:ESTRADIUS (STA / DLIST N1 N2 OS P PC PLIST)
 (setq DLIST nil)
 (if (setq P (RFL:XY (list STA 0.0)))
  (if (setq DLIST (mapcar '(lambda (N1) (append (list (distance P (cadr N1))) (cadr N1))) RFL:ALIGNLIST))
   (if (setq DLIST (vl-sort DLIST (function (lambda (N1 N2) (< (car N1) (car N2))))))
    (progn
     (setq PLIST nil)
     (foreach N1 DLIST
      (if (and (or (= RFL:ESTRADIUSDIST nil) (<= (car N1) RFL:ESTRADIUSDIST))
               (or (= RFL:ESTRADIUSNUMPOINTS nil) (< (length PLIST) RFL:ESTRADIUSNUMPOINTS))
          )
       (setq PLIST (append PLIST (list (list (cadr N1) (caddr N1)))))
      )
     )
     (if (> (length PLIST) 2)
      (if (setq PC (RFL:BESTCIRCLE PLIST))
       (if (setq OS (cadr (RFL:STAOFF (car PC))))
        (if (< OS 0.0)
         (cadr PC)
         (* -1.0 (cadr PC))
        )
        nil
       )
       nil
      )
      nil
     )
    )
    nil
   )
   nil
  )
  nil
 )
)
;
;
;     Program written by Robert Livingston, 2016/07/07
;
;     RFL:GETALIGNLENGTH returns the length the alignment defined by RFL:ALIGNLIST
;
;
(if RFL:GETALIGNLENGTH (princ "\nRFL:GETALIGNLENGTH already loaded...")
(defun RFL:GETALIGNLENGTH ()
 (if (= RFL:ALIGNLIST nil)
  (progn
   nil
  )
  (progn
   (- (+ (car (last RFL:ALIGNLIST))
         (RFL:DIST (cadr (last RFL:ALIGNLIST)) (caddr (last RFL:ALIGNLIST)) (cadddr (last RFL:ALIGNLIST)))
      )
      (car (car RFL:ALIGNLIST))
   )
  )
 )
)
)
;
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:GETRADIUS returns the radius at a specified station
;
;
;
(defun RFL:GETRADIUS (STA / AL C DIR R)
 (if (/= nil RFL:ALIGNLIST)
  (progn
   (setq AL (last RFL:ALIGNLIST))
   (if (<= STA (+ (car AL) (RFL:ARCLENGTH (cadr AL) (caddr AL) (cadddr AL))))
    (progn
     (setq C 0)
     (setq AL (nth C RFL:ALIGNLIST))
     (if (>= STA (car AL))
      (progn
       (while (> STA (+ (car AL) (RFL:ARCLENGTH (cadr AL) (caddr AL) (cadddr AL))))
        (setq C (+ C 1))
        (setq AL (nth C RFL:ALIGNLIST))
       )
       (if (listp (cadddr AL))
        (progn
         (if (< (distance (caddr AL) (caddr (cadddr AL))) (distance (cadr AL) (caddr (cadddr AL))))
          (progn
           (setq R (RFL:GETSPIRALRADIUS (+ (- STA
                                              (car AL)
                                           )
                                           (cadddr (cadddr AL))
                                        )
                                        (car (cadddr AL))
                                        (cadr (cadddr AL))
                                        (caddr (cadddr AL))
                   )
           )
          )
          (progn
           (setq R (* -1.0
                      (RFL:GETSPIRALRADIUS (- (RFL:GETSPIRALLS2 (car (cadddr AL))
                                                                (cadr (cadddr AL))
                                                                (caddr (cadddr AL))
                                              )
                                              (- STA
                                                 (car AL)
                                              )
                                           )
                                           (car (cadddr AL))
                                           (cadr (cadddr AL))
                                           (caddr (cadddr AL))
                      )
                   )
           )
          )
         )
        )
        (progn
         (if (< (abs (cadddr AL)) RFL:TOL)
          (progn
           (setq R 0.0)
          )
          (progn
           (setq DIR (RFL:SIGN (cadddr AL)))
           (setq R (* DIR (RFL:RADIUS (cadr AL) (caddr AL) (cadddr AL))))
          )
         )
        )
       )
      )
      (progn
       (princ "\n**** STATION OUT OF RANGE ****")
       (eval nil)
      )
     )
    )
    (progn
     (princ "\n**** STATION OUT OF RANGE ****")
     (eval nil)
    )
   )
  )
  (progn
   (princ "\n**** NO ALIGNMENT DEFINED ****")
   (eval nil)
  )
 )
)
;
;
;   Program written by Robert Livingston, 2002/01/07
;
;   RFL:Hor2Table is a routine for creating and alignment table from the currently defined RFL alignment
;
;
(defun RFL:HOR2TABLE (/ *error* ANGBASE ANGC ANGH ANGDIR AL ATTREQ C1 CCOUNT CHECKCURVE CLAYER CMDECHO CURVECOUNT CURVEPI
                        DIMZIN ENT ENTLIST FLAG GETCODE GETCURVE GETLENGTH GETRADIUS GETTANGENT
                        INSERTH INSERTC INSERTCURVE
                        NAMEC NAMEH NODE NODEPI NODENEXT NODEPREV OSMODE PH PIAHEAD PIBACK PINT PTMP
                        R RNEXT REPD
                        S1 S2 SCALECX SCALECY SCALEHX SCALEHY SEARCH SIGN SPIRALPI STATXT STEPH STR1 STR2
                        TIN TMP TOL TOUT)
;(defun C:RFLHOR2TABLE ()
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ATTREQ (getvar "ATTREQ"))
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq TOL 5e-12)

 (command "._UNDO" "M")

 (command "._UCS" "W")

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "CLAYER" CLAYER)
  (setvar "DIMZIN" DIMZIN)
  (setvar "OSMODE" OSMODE)
  (setvar "ATTREQ" ATTREQ)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (alert msg)
  ;(setq *error* nil)
 )

 (defun SIGN (X)
  (if (< X 0)
   (eval -1)
   (eval 1)
  )
 )

 (defun CHECKCURVE (NODE)
  (if (= nil NODE)
   (eval 0)
   (if (listp (last NODE))
    (eval 0)
    (if (< (abs (last NODE)) TOL)
     (eval 0)
     (eval 1)
    )
   )
  )
 )

 (defun GETCURVE (NODE / A2 ATOTAL BULGE CHORD D LO LS P1 P2 R THETA THETA2)
  (if (/= nil NODE)
   (progn
    (setq BULGE (last NODE))
    (setq P1 (nth 1 NODE))
    (setq P2 (nth 2 NODE))
    (if (listp BULGE)
     (progn
      (setq LS (RFL:GETSPIRALLS2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (if (listp (last BULGE))
       (setq LO 0.0)
       (setq LO (last BULGE))
      )
      (setq THETA (RFL:GETSPIRALTHETA2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (setq R (RFL:GETSPIRALR2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (setq A2 (* 2.0 R R THETA))
      (setq THETA2 (/ (* LO LO) A2 2.0))
      (setq THETA (- THETA THETA2))
      (if (= nil S1)
       (if (= nil C1)
        (setq S1 (list THETA LS LO R))
        (setq S2 (list THETA LS LO R))
       )
       (if (= nil S2)
        (progn
         (setq S2 (list THETA LS LO R))
        )
       )
      )
     )
     (if (< (abs BULGE) TOL)
      (progn
       (setq THETA (abs (- (angle (nth 0 TOUT) (nth 1 TOUT)) (angle (nth 0 TIN) (nth 1 TIN)))))
       (if (> THETA PI) (setq THETA (- (* 2.0 PI) THETA)))
       (setq C1 (list THETA 0.0 0.0 0.0))
      )
      (progn
       (setq ATOTAL (* 4.0 (atan (abs BULGE))))
       (setq CHORD (distance P1 P2))
       (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
       (setq C1 (list ATOTAL R (* R ATOTAL) (distance P1 (CURVEPI NODE))))
      )
     )
    )
   )
  )
 )

 (defun GETCODE (NODE1 NODE2 / TMP)
  (if (or (= nil NODE1) (= nil NODE2))
   (setq TMP "NONE")
   (if (listp (last NODE1))
    (if (listp (last NODE2))
     (setq TMP "S.C./C.S.")
     (if (< (abs (last NODE2)) TOL)
      (setq TMP "S.T.")
      (setq TMP "S.C.")
     )
    )
    (if (< (abs (last NODE1)) TOL)
     (if (listp (last NODE2))
      (setq TMP "T.S.")
      (if (< (abs (last NODE2)) TOL)
       (setq TMP "P.I.")
       (setq TMP "B.C.")
      )
     )
     (if (listp (last NODE2))
      (setq TMP "C.S.")
      (if (< (abs (last NODE2)) TOL)
       (setq TMP "E.C.")
       (setq TMP "P.C.C.")
      )
     )
    )
   )
  )
  (eval TMP)
 )

 (defun CURVEPI (NODE / ANG ATOTAL BULGE CHORD D P1 P2 PINT)
  (setq P1 (nth 1 NODE))
  (setq P2 (nth 2 NODE))
  (setq BULGE (last NODE))
  (setq ATOTAL (* 4.0 (atan BULGE)))
  (setq CHORD (distance P1 P2))
  (setq D (/ CHORD (* 2.0 (cos (/ ATOTAL 2.0)))))
  (setq ANG (- (angle P1 P2) (/ ATOTAL 2.0)))
  (setq PINT (list (+ (nth 0 P1) (* D (cos ANG)))
                   (+ (nth 1 P1) (* D (sin ANG)))))
 )

 (defun SPIRALPI (NODE / A2 ANG BULGE DIR LO P P1 PINT R THETA THETA2)
  (setq BULGE (last NODE))
  (if (listp (setq LO (last BULGE)))
   (setq PINT (nth 1 BULGE))
   (if (< (abs LO) TOL)
    (setq PINT (nth 1 BULGE))
    (progn
     (setq DIR (SIGN (- (angle (nth 2 BULGE) (nth 1 BULGE))
                        (angle (nth 1 BULGE) (nth 0 BULGE)))))
     (setq THETA (RFL:GETSPIRALTHETA2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
     (setq R (RFL:GETSPIRALR2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
     (setq A2 (* 2.0 R R THETA))
     (setq THETA2 (/ (* LO LO) A2 2.0))
     (setq ANG (angle (nth 0 BULGE) (nth 1 BULGE)))
     (if (< (distance (nth 2 NODE) (nth 2 BULGE)) TOL)
      (setq P1 (nth 1 NODE))
      (setq P1 (nth 2 NODE))
     )
     (setq P (list (+ (nth 0 P1) (cos (+ ANG (* DIR THETA2))))
                   (+ (nth 1 P1) (sin (+ ANG (* DIR THETA2))))))
     (setq PINT (inters (nth 1 BULGE) (nth 2 BULGE) P1 P nil))
    )
   )
  )
 )

 (defun GETTANGENT (IO NODE / P1 P2)
  (if (= nil NODE)
   (setq P1 nil P2 nil)
   (if (listp (last NODE))
    (if (= IO "IN")
     (setq P1 (nth 1 NODE) P2 (SPIRALPI NODE))
     (setq P1 (SPIRALPI NODE) P2 (nth 2 NODE))
    )
    (if (< (abs (last NODE)) TOL)
     (setq P1 (nth 1 NODE) P2 (nth 2 NODE))
     (if (= IO "IN")
      (setq P1 (nth 1 NODE) P2 (CURVEPI NODE))
      (setq P1 (CURVEPI NODE) P2 (nth 2 NODE))
     )
    )
   )
  )
  (list P1 P2)
 )

 (defun GETRADIUS (NODE / ATOTAL BULGE CHORD P1 P2 R)
  (if (= nil NODE)
   (setq R 0.0)
   (progn
    (setq P1 (nth 1 NODE))
    (setq P2 (nth 2 NODE))
    (setq BULGE (last NODE))
    (if (listp BULGE)
     (setq R (RFL:GETSPIRALR2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
     (if (< (abs BULGE) TOL)
      (setq R 0.0)
      (progn
       (setq ATOTAL (* 4.0 (atan (abs BULGE))))
       (setq CHORD (distance P1 P2))
       (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
      )
     )
    )
   )
  )
  (eval R)
 )

 (defun GETLENGTH (NODE / ATOTAL BULGE CHORD L P1 P2 R)
  (if (= nil NODE)
   (setq L nil)
   (progn
    (setq P1 (nth 1 NODE))
    (setq P2 (nth 2 NODE))
    (setq BULGE (last NODE))
    (if (listp BULGE)
     (if (listp (last BULGE))
      (setq L (RFL:GETSPIRALLS2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (setq L (- (RFL:GETSPIRALLS2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)) (last BULGE)))
     )
     (if (< (abs BULGE) TOL)
      (setq L (distance P1 P2))
      (progn
       (setq ATOTAL (* 4.0 (atan (abs BULGE))))
       (setq CHORD (distance P1 P2))
       (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
       (setq L (* R ATOTAL))
      )
     )
    )
   )
  )
  (eval L)
 )

 (defun REPD (S / TMP)
  (setq TMP (strcat (substr S 1 (- (SEARCH "d" S) 1)) "%%" (substr S (SEARCH "d" S))))
  (if (< (- (SEARCH "'" TMP) (SEARCH "d" TMP)) 3)
   (setq TMP (strcat (substr TMP 1 (SEARCH "d" TMP)) "0" (substr TMP (+ (SEARCH "d" TMP) 1))))
  )
  (if (< (- (SEARCH "." TMP) (SEARCH "'" TMP)) 3)
   (setq TMP (strcat (substr TMP 1 (SEARCH "'" TMP)) "0" (substr TMP (+ (SEARCH "'" TMP) 1))))
  )
  (setq TMP TMP)
 )

 (defun SEARCH (S L / C)
  (setq C 1)
  (while (and (/= (substr L C (strlen S)) S) (<= C (strlen L)))
   (setq C (+ C 1))
  )
  (if (> C (strlen L)) (setq C nil) (setq C C))
 )

 (defun STATXT (STA / DIMZIN SIGN STAH STAL)
  (setq STA (/ (fix (+ (* STA 1000.0) 0.5)) 1000.0))
  (setq DIMZIN (getvar "DIMZIN"))
  (setvar "DIMZIN" 0)
  (if (< STA 0.0)
   (setq SIGN "-")
   (setq SIGN "")
  )
  (setq STAH (fix (/ (abs STA) 1000.0)))
  (setq STAL (- (abs STA) (* STAH 1000.0)))
  (if (= (substr (rtos STAL) 1 4) "1000")
   (progn
    (setq STAL 0.0)
    (setq STAH (+ STAH (SIGN STAH)))
   )
  )
  (setq STAH (itoa STAH))
  (if (< STAL 10.0)
   (setq STAL (strcat "00" (rtos STAL 2 3)))
   (if (< STAL 100.0)
    (setq STAL (strcat "0" (rtos STAL 2 3)))
    (setq STAL (rtos STAL 2 3))
   )
  )
  (setvar "DIMZIN" DIMZIN)
  (strcat SIGN STAH "+" STAL)
 )

 (defun INSERTCURVE ()
  (setq FLAG 1)
  (setq CCOUNT (+ CCOUNT 1))
  (if (= nil C1)
   (setq C1 (list 0.0 (if (/= nil S1) (last S1) (last S2)) 0.0 0.0 0.0))
  )
  (if (and (= S1 nil) (= S2 nil))
   (INSERTC (itoa CCOUNT)
            (REPD (angtos (nth 0 C1) 1 6))
            (rtos (nth 1 C1) 2 3)
            (rtos (nth 2 C1) 2 3)
            (rtos (nth 3 C1) 2 3)
            ""
            ""
            ""
            ""
            ""
            ""
   )
   (if (and (/= S1 nil) (= S2 nil))
    (INSERTC (itoa CCOUNT)
             (REPD (angtos (nth 0 C1) 1 6))
             (rtos (nth 1 C1) 2 3)
             (rtos (nth 2 C1) 2 3)
             (rtos (nth 3 C1) 2 3)
             (strcat (if (< (abs (nth 2 S1)) TOL) "" "C") "SPIRAL IN")
             (REPD (angtos (nth 0 S1) 1 6))
             (rtos (- (nth 1 S1) (nth 2 S1)) 2 3)
             ""
             ""
             ""
    )
    (if (and (= S1 nil) (/= S2 nil))
     (INSERTC (itoa CCOUNT)
              (REPD (angtos (nth 0 C1) 1 6))
              (rtos (nth 1 C1) 2 3)
              (rtos (nth 2 C1) 2 3)
              (rtos (nth 3 C1) 2 3)
              (strcat (if (< (abs (nth 2 S2)) TOL) "" "C") "SPIRAL OUT")
              (REPD (angtos (nth 0 S2) 1 6))
              (rtos (- (nth 1 S2) (nth 2 S2)) 2 3)
              ""
              ""
              ""
     )
     (if (and (< (abs (- (nth 0 S1) (nth 0 S2))) TOL)
              (< (abs (- (nth 1 S1) (nth 1 S2))) TOL)
              (< (abs (- (nth 2 S1) (nth 2 S2))) TOL))
      (INSERTC (itoa CCOUNT)
               (REPD (angtos (nth 0 C1) 1 6))
               (rtos (nth 1 C1) 2 3)
               (rtos (nth 2 C1) 2 3)
               (rtos (nth 3 C1) 2 3)
               (strcat (if (< (abs (nth 2 S1)) TOL) "" "C") "SPIRAL DATA")
               (REPD (angtos (nth 0 S1) 1 6))
               (rtos (- (nth 1 S1) (nth 2 S1)) 2 3)
               ""
               ""
               ""
      )
      (INSERTC (itoa CCOUNT)
               (REPD (angtos (nth 0 C1) 1 6))
               (rtos (nth 1 C1) 2 3)
               (rtos (nth 2 C1) 2 3)
               (rtos (nth 3 C1) 2 3)
               (strcat (if (< (abs (nth 2 S1)) TOL) "" "C") "SPIRAL IN")
               (REPD (angtos (nth 0 S1) 1 6))
               (rtos (- (nth 1 S1) (nth 2 S1)) 2 3)
               (strcat (if (< (abs (nth 2 S2)) TOL) "" "C") "SPIRAL OUT")
               (REPD (angtos (nth 0 S2) 1 6))
               (rtos (- (nth 1 S2) (nth 2 S2)) 2 3)
      )
     )
    )
   )
  )
  (INSERTH (strcat (nth 0 PIAHEAD) "" (itoa CCOUNT) " AH")
           (RFL:STATXT (nth 1 PIAHEAD))
           (rtos (nth 2 PIAHEAD) 2 3)
           (rtos (nth 3 PIAHEAD) 2 3)
  )
  (INSERTH (strcat (nth 0 PIBACK) "" (itoa CCOUNT) " BK")
           (RFL:STATXT (nth 1 PIBACK))
           (rtos (nth 2 PIBACK) 2 3)
           (rtos (nth 3 PIBACK) 2 3)
  )
 )

 (defun INSERTC (LABEL CDELTA CRADIUS CLENGTH CTANGENT
                 SB SBTHETA SBLENGTH SA SATHETA SALENGTH / ATTREQ ENT ENTLIST)
  (setq ATTREQ (getvar "ATTREQ"))
  (setvar "ATTREQ" 0)

  (setq PC (list (+ (nth 0 PC) (* (cos ANGC) (* STEPC SCALECX)))
                 (+ (nth 1 PC) (* (sin ANGC) (* STEPC SCALECX)))
           )
  )
  (if (= nil (tblsearch "BLOCK" NAMEC)) (RFL:MAKEENT NAMEC))
  (command "._INSERT" NAMEC PC SCALECX SCALECY (* ANGC (/ 180.0 pi)))
  (setq ENT (entlast))
  (setq ENTLIST (entget ENT))
  (setq ANGC (cdr (assoc 50 ENTLIST)))
  (if (= (cdr (assoc 66 ENTLIST)) 1)
   (progn
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
     (if (= (cdr (assoc 2 ENTLIST)) "STEP")
      (progn
       (setq STEPC (atof (cdr (assoc 1 ENTLIST))))
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "LABEL")
      (progn
       (setq ENTLIST (subst (cons 1 LABEL) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "CDELTA")
      (progn
       (setq ENTLIST (subst (cons 1 CDELTA) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "CRADIUS")
      (progn
       (setq ENTLIST (subst (cons 1 CRADIUS) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "CLENGTH")
      (progn
       (setq ENTLIST (subst (cons 1 CLENGTH) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "CTANGENT")
      (progn
       (setq ENTLIST (subst (cons 1 CTANGENT) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "SB")
      (progn
       (setq ENTLIST (subst (cons 1 SB) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "SBTHETA")
      (progn
       (setq ENTLIST (subst (cons 1 SBTHETA) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "SBLENGTH")
      (progn
       (setq ENTLIST (subst (cons 1 SBLENGTH) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "SA")
      (progn
       (setq ENTLIST (subst (cons 1 SA) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "SATHETA")
      (progn
       (setq ENTLIST (subst (cons 1 SATHETA) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "SALENGTH")
      (progn
       (setq ENTLIST (subst (cons 1 SALENGTH) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
  )

  (setvar "ATTREQ" ATTREQ)
 )

 (defun INSERTH (PNT STA NORTHING EASTING / ATTREQ ENT ENTLIST)
  (setq ATTREQ (getvar "ATTREQ"))
  (setvar "ATTREQ" 0)

  (setq PH (list (+ (nth 0 PH) (* (sin ANGH) (* STEPH SCALEHY)))
                 (- (nth 1 PH) (* (cos ANGH) (* STEPH SCALEHY)))
           )
  )
  (if (= nil (tblsearch "BLOCK" NAMEH)) (RFL:MAKEENT NAMEH))
  (command "._INSERT" NAMEH PH SCALEHX SCALEHY (* ANGH (/ 180.0 pi)))
  (setq ENT (entlast))
  (setq ENTLIST (entget ENT))
  (setq ANGH (cdr (assoc 50 ENTLIST)))
  (if (= (cdr (assoc 66 ENTLIST)) 1)
   (progn
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
     (if (= (cdr (assoc 2 ENTLIST)) "STEP")
      (progn
       (setq STEPH (atof (cdr (assoc 1 ENTLIST))))
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "PNT")
      (progn
       (setq ENTLIST (subst (cons 1 PNT) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "STA")
      (progn
       (setq ENTLIST (subst (cons 1 STA) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "NORTHING")
      (progn
       (setq ENTLIST (subst (cons 1 NORTHING) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "EASTING")
      (progn
       (setq ENTLIST (subst (cons 1 EASTING) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
  )

  (setvar "ATTREQ" ATTREQ)
 )

 (if (= nil (tblsearch "BLOCK" "ALTABLE01"))
  (progn
   (RFL:MAKEENT "ALTABLE01")
   (princ "\nCreating block: ALTABLE01")
  )
 )
 (if (= nil (tblsearch "BLOCK" "CURVETABLE"))
  (progn
   (RFL:MAKEENT "CURVETABLE")
   (princ "\nCreating block: CURVETABLE")
  )
 )

 (if (= RFL:GETSPIRALR nil)
  (alert "Alignment utilities not loaded!")
  (if (= RFL:ALIGNLIST nil)
   (alert "No alignment defined!")
   (progn
    (setq TMP (fix (/ (car (car RFL:ALIGNLIST)) 1000.0)))
    (if (= (* (fix (/ (float TMP) 10.0)) 10) TMP) (setq TMP (+ TMP 1)))
    (setq CCOUNT (getint (strcat "\nEnter start curve number <" (itoa TMP) "> :")))
    (if (= CCOUNT nil) (setq CCOUNT TMP))
    (setq CCOUNT (- CCOUNT 1))
    (setq AL RFL:ALIGNLIST)
    (setq NODEPREV nil)
    (setq NODE (car AL))
    (setq NODENEXT (car (cdr AL)))
    (if (/= (setq ENT (car (entsel "\nSelect point table : "))) nil)
     (progn
      (setq ENTLIST (entget ENT))
      (if (and (= (cdr (assoc 0 ENTLIST)) "INSERT") (= (cdr (assoc 66 ENTLIST)) 1))
       (progn
        (setq NAMEH (strcat (cdr (assoc 2 ENTLIST)) "DATA"))
        (setq SCALEHX (cdr (assoc 41 ENTLIST)))
        (setq SCALEHY (cdr (assoc 42 ENTLIST)))
        (setq PH (cdr (assoc 10 ENTLIST)))
        (setq ANGH (cdr (assoc 50 ENTLIST)))
        (setq STEPH nil)
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
        (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
         (if (= (cdr (assoc 2 ENTLIST)) "STEP") (setq STEPH (atof (cdr (assoc 1 ENTLIST)))))
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
        )
        (if (/= (setq ENT (car (entsel "\nSelect curve table : "))) nil)
         (progn
          (setq ENTLIST (entget ENT))
          (if (and (= (cdr (assoc 0 ENTLIST)) "INSERT") (= (cdr (assoc 66 ENTLIST)) 1))
           (progn
            (setq NAMEC (strcat (cdr (assoc 2 ENTLIST)) "DATA"))
            (setq SCALECX (cdr (assoc 41 ENTLIST)))
            (setq SCALECY (cdr (assoc 42 ENTLIST)))
            (setq PC (cdr (assoc 10 ENTLIST)))
            (setq ANGC (cdr (assoc 50 ENTLIST)))
            (setq STEPC nil)
            (setq ENT (entnext ENT))
            (setq ENTLIST (entget ENT))
            (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
             (if (= (cdr (assoc 2 ENTLIST)) "STEP") (setq STEPC (atof (cdr (assoc 1 ENTLIST)))))
             (setq ENT (entnext ENT))
             (setq ENTLIST (entget ENT))
            )
            (if (listp (last NODE))
             (INSERTH "P.O.S."
                      (RFL:STATXT (nth 0 NODE))
                      (rtos (nth 1 (nth 1 NODE)) 2 3)
                      (rtos (nth 0 (nth 1 NODE)) 2 3)
             )
             (if (< (abs (last NODE)) TOL)
              (INSERTH "P.O.T."
                       (RFL:STATXT (nth 0 NODE))
                       (rtos (nth 1 (nth 1 NODE)) 2 3)
                       (rtos (nth 0 (nth 1 NODE)) 2 3)
              )
              (INSERTH "P.O.C."
                       (RFL:STATXT (nth 0 NODE))
                       (rtos (nth 1 (nth 1 NODE)) 2 3)
                       (rtos (nth 0 (nth 1 NODE)) 2 3)
              )
             )
            )
            (while (/= NODE nil)
             (setq R (GETRADIUS NODE))
             (setq RNEXT (GETRADIUS NODENEXT))
             (if (and (= R 0.0) (= RNEXT 0.0) (/= NODENEXT nil))
              (progn
               (setq TIN (GETTANGENT "IN" NODE))
               (setq TOUT (GETTANGENT "OUT" NODENEXT))
               (setq CCOUNT (+ CCOUNT 1))
               (GETCURVE NODE)
               (INSERTC (itoa CCOUNT)
                        (REPD (angtos (nth 0 C1) 1 6))
                        (rtos (nth 1 C1) 2 3)
                        (rtos (nth 2 C1) 2 3)
                        (rtos (nth 3 C1) 2 3)
                        ""
                        ""
                        ""
                        ""
                        ""
                        ""
               )
               (INSERTH (strcat "P.I. " (itoa CCOUNT))
                        (RFL:STATXT (+ (nth 0 NODE) (GETLENGTH NODE)))
                        (rtos (nth 1 (nth 2 NODE)) 2 3)
                        (rtos (nth 0 (nth 2 NODE)) 2 3)
               )
               (setq NODEPREV NODE)
               (setq AL (cdr AL))
               (setq NODE (car AL))
               (setq NODENEXT (car (cdr AL)))
              )
              (if (= R 0.0)
               (progn
                (setq NODEPREV NODE)
                (setq AL (cdr AL))
                (setq NODE (car AL))
                (setq NODENEXT (car (cdr AL)))
               )
               (progn
                (setq NODEPI nil)
                (setq TIN (GETTANGENT "IN" NODE))
                (setq TOUT (GETTANGENT "OUT" NODE))
                (setq S1 nil S2 nil C1 nil)
                (setq CURVECOUNT (CHECKCURVE NODE))
                (GETCURVE NODE)
                (setq NODEPI (append NODEPI (list (list (GETCODE NODEPREV NODE)
                                                        (nth 0 NODE)
                                                        (nth 1 (nth 1 NODE))
                                                        (nth 0 (nth 1 NODE))
                                                  )
                                            )
                             )
                )
                (setq CURVECOUNT (+ CURVECOUNT (CHECKCURVE NODENEXT)))
                (while (and (< (abs (- R RNEXT)) TOL)
                            (< CURVECOUNT 2)
                       )
                 (setq NODEPREV NODE)
                 (setq AL (cdr AL))
                 (setq NODE (car AL))
                 (setq NODENEXT (car (cdr AL)))
                 (setq TOUT (GETTANGENT "OUT" NODE))
                 (setq R RNEXT)
                 (setq RNEXT (GETRADIUS NODENEXT))
                 (GETCURVE NODE)
                 (setq NODEPI (append NODEPI (list (list (GETCODE NODEPREV NODE)
                                                         (nth 0 NODE)
                                                         (nth 1 (nth 1 NODE))
                                                         (nth 0 (nth 1 NODE))
                                                   )
                                             )
                              )
                 )
                 (setq CURVECOUNT (+ CURVECOUNT (CHECKCURVE NODENEXT)))
                )
                (if (= RNEXT 0.0)
                 (setq NODEPI (append NODEPI (list (list (GETCODE NODE NODENEXT)
                                                         (+ (nth 0 NODE) (GETLENGTH NODE))
                                                         (nth 1 (nth 2 NODE))
                                                         (nth 0 (nth 2 NODE))
                                                   )
                                             )
                              )
                 )
                )
                (setq PINT (inters (nth 0 TIN) (nth 1 TIN) (nth 0 TOUT) (nth 1 TOUT) nil))
                (setq PTMP (list (nth 1 (cdr (cdr (car NODEPI)))) (nth 0 (cdr (cdr (car NODEPI))))))
                (setq PIAHEAD (list "P.I."
                                    (+ (nth 1 (car NODEPI)) (distance PTMP PINT))
                                    (nth 1 PINT)
                                    (nth 0 PINT)
                              )
                )
                (setq PTMP (list (nth 1 (cdr (cdr (last NODEPI)))) (nth 0 (cdr (cdr (last NODEPI))))))
                (setq PIBACK (list "P.I."
                                   (- (+ (nth 0 NODE) (GETLENGTH NODE)) (distance PTMP PINT))
                                   (nth 1 PINT)
                                   (nth 0 PINT)
                             )
                )
                (setq FLAG 0)
                (while (/= nil NODEPI)
                 (if (and (= FLAG 0) (> (nth 1 (car NODEPI)) (nth 1 PIAHEAD)))
                  (INSERTCURVE)
                 )
                 (if (/= "NONE" (nth 0 (car NODEPI)))
                  (INSERTH (nth 0 (car NODEPI))
                           (RFL:STATXT (nth 1 (car NODEPI)))
                           (rtos (nth 2 (car NODEPI)) 2 3)
                           (rtos (nth 3 (car NODEPI)) 2 3)
                  )
                 )
                 (setq NODEPI (cdr NODEPI))
                )
                (if (= FLAG 0)
                 (INSERTCURVE)
                )
                (setq NODEPREV NODE)
                (setq AL (cdr AL))
                (setq NODE (car AL))
                (setq NODENEXT (car (cdr AL)))
               )
              )
             )         
            )
            (if (= NODE nil) (setq NODE NODEPREV))
            (if (listp (last NODE))
             (INSERTH "P.O.S."
                      (RFL:STATXT (+ (nth 0 NODE) (GETLENGTH NODE)))
                      (rtos (nth 1 (nth 2 NODE)) 2 3)
                      (rtos (nth 0 (nth 2 NODE)) 2 3)
             )
             (if (< (abs (last NODE)) TOL)
              (INSERTH "P.O.T."
                       (RFL:STATXT (+ (nth 0 NODE) (GETLENGTH NODE)))
                       (rtos (nth 1 (nth 2 NODE)) 2 3)
                       (rtos (nth 0 (nth 2 NODE)) 2 3)
              )
              (INSERTH "P.O.C."
                       (RFL:STATXT (+ (nth 0 NODE) (GETLENGTH NODE)))
                       (rtos (nth 1 (nth 2 NODE)) 2 3)
                       (rtos (nth 0 (nth 2 NODE)) 2 3)
              )
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "CLAYER" CLAYER)
 (setvar "DIMZIN" DIMZIN)
 (setvar "OSMODE" OSMODE)
 (setvar "ATTREQ" ATTREQ)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
);
;
;   Program written by Robert Livingston, 2002/01/07
;
;   RFLHor2Table is a routine for creating and alignment table from the currently defined RFL alignment
;
;
(defun RFL:HOR2TABLE2 (/ *error* ANGBASE ANGC ANGH ANGDIR AL ATTREQ C1 CCOUNT CHECKCURVE CLAYER CMDECHO CURVECOUNT CURVEPI
                         DIMZIN DIR ENT ENTLIST FLAG GETCODE GETCURVE GETDIR GETLENGTH GETRADIUS GETTANGENT
                         INSERTH INSERTC INSERTCURVE
                         NAMEC NAMEH NODE NODEPI NODENEXT NODEPREV OSMODE PH PIAHEAD PIBACK PINT PTMP
                         R RNEXT REPD RFLSTAPOS ROUND
                         S1 S2 SCALECX SCALECY SCALEHX SCALEHY SEARCH SIGN SPIRALPI STEPH STR1 STR2
                         TIN TMP TOL TOUT)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ATTREQ (getvar "ATTREQ"))
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq TOL 1e-4)

 (command "._UNDO" "M")

 (command "._UCS" "W")

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "CLAYER" CLAYER)
  (setvar "DIMZIN" DIMZIN)
  (setvar "OSMODE" OSMODE)
  (setvar "ATTREQ" ATTREQ)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (alert msg)
  ;(setq *error* nil)
 )

 (setq TMP (getint "\nStation text '+' location <2> : "))
 (if (= nil TMP)
  (setq RFLSTAPOS 2)
  (setq RFLSTAPOS TMP)
 )

 (defun ROUND (X PREC / )
  (* (SIGN X) (/ (fix (+ (* (abs X) (EXPT 10.0 PREC)) 0.5)) (EXPT 10.0 PREC)))
 )
 
 (defun SIGN (X)
  (if (< X 0)
   (eval -1)
   (eval 1)
  )
 )

 (defun CHECKCURVE (NODE)
  (if (= nil NODE)
   (eval 0)
   (if (listp (last NODE))
    (eval 1) ; changed 0 to 1
    (if (< (abs (last NODE)) TOL)
     (eval 0)
     (eval 1)
    )
   )
  )
 )

 (defun GETCURVE (NODE / A2 ATOTAL BULGE CHORD D LO LS P1 P2 R THETA THETA2)
  (if (/= nil NODE)
   (progn
    (setq BULGE (last NODE))
    (setq P1 (nth 1 NODE))
    (setq P2 (nth 2 NODE))
    (if (listp BULGE)
     (progn
      (setq LS (RFL:GETSPIRALLS2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (if (listp (last BULGE))
       (setq LO 0.0)
       (setq LO (last BULGE))
      )
      (setq THETA (RFL:GETSPIRALTHETA2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (setq R (RFL:GETSPIRALR2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (setq A2 (* 2.0 R R THETA))
      (setq THETA2 (/ (* LO LO) A2 2.0))
      (setq THETA (- THETA THETA2))
      (if (= nil S1)
       (if (= nil C1)
        (setq S1 (list THETA LS LO R))
        (setq S2 (list THETA LS LO R))
       )
       (if (= nil S2)
        (progn
         (setq S2 (list THETA LS LO R))
        )
       )
      )
     )
     (if (< (abs BULGE) TOL)
      (progn
       (setq THETA (abs (- (angle (nth 0 TOUT) (nth 1 TOUT)) (angle (nth 0 TIN) (nth 1 TIN)))))
       (if (> THETA PI) (setq THETA (- (* 2.0 PI) THETA)))
       (setq C1 (list THETA 0.0 0.0 0.0))
      )
      (progn
       (setq ATOTAL (* 4.0 (atan (abs BULGE))))
;       (setq ATOTAL (* 4.0 (atan BULGE)))
       (setq CHORD (distance P1 P2))
       (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
       (setq C1 (list ATOTAL R (* R ATOTAL) (distance P1 (CURVEPI NODE))))
      )
     )
    )
   )
  )
 )

 (defun GETCODE (NODE1 NODE2 / TMP)
  (if (or (= nil NODE1) (= nil NODE2))
   (setq TMP "NONE")
   (if (listp (last NODE1))
    (if (listp (last NODE2))
     (setq TMP "S.C./C.S.")
     (if (< (abs (last NODE2)) TOL)
      (setq TMP "S.T.")
      (setq TMP "S.C.")
     )
    )
    (if (< (abs (last NODE1)) TOL)
     (if (listp (last NODE2))
      (setq TMP "T.S.")
      (if (< (abs (last NODE2)) TOL)
       (setq TMP "P.I.")
       (setq TMP "B.C.")
      )
     )
     (if (listp (last NODE2))
      (setq TMP "C.S.")
      (if (< (abs (last NODE2)) TOL)
       (setq TMP "E.C.")
       (setq TMP "P.C.C.")
      )
     )
    )
   )
  )
  (eval TMP)
 )

 (defun GETDIR (NODE / BULGE P1 P2)
  (if (/= nil NODE)
   (progn
    (setq BULGE (cadddr NODE))
    (setq P1 (cadr NODE))
    (setq P2 (caddr NODE))
    (if (listp BULGE)
     (if (> (sin (- (angle (cadr BULGE) (caddr BULGE)) (angle (car BULGE) (cadr BULGE)))) 0.0)
      (if (< (distance P2 (caddr BULGE)) (distance P1 (caddr BULGE)))
       1
       -1
      )
      (if (< (distance P2 (caddr BULGE)) (distance P1 (caddr BULGE)))
       -1
       1
      )
     )
     (if (< (abs BULGE) TOL)
      0
      (if (< BULGE 0.0)
       -1
       1
      )
     )
    )
   )
  )
 )
 
 (defun CURVEPI (NODE / ANG ATOTAL BULGE CHORD D P1 P2 PINT)
  (setq P1 (nth 1 NODE))
  (setq P2 (nth 2 NODE))
  (setq BULGE (last NODE))
  (setq ATOTAL (* 4.0 (atan BULGE)))
  (setq CHORD (distance P1 P2))
  (setq D (/ CHORD (* 2.0 (cos (/ ATOTAL 2.0)))))
  (setq ANG (- (angle P1 P2) (/ ATOTAL 2.0)))
  (setq PINT (list (+ (nth 0 P1) (* D (cos ANG)))
                   (+ (nth 1 P1) (* D (sin ANG)))))
 )

 (defun SPIRALPI (NODE / A2 ANG BULGE DIR LO P P1 PINT R THETA THETA2)
  (setq BULGE (last NODE))
  (if (listp (setq LO (last BULGE)))
   (setq PINT (nth 1 BULGE))
   (if (< (abs LO) TOL)
    (setq PINT (nth 1 BULGE))
    (progn
     (setq DIR (SIGN (- (angle (nth 2 BULGE) (nth 1 BULGE))
                        (angle (nth 1 BULGE) (nth 0 BULGE)))))
     (setq THETA (RFL:GETSPIRALTHETA2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
     (setq R (RFL:GETSPIRALR2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
     (setq A2 (* 2.0 R R THETA))
     (setq THETA2 (/ (* LO LO) A2 2.0))
     (setq ANG (angle (nth 0 BULGE) (nth 1 BULGE)))
     (if (< (distance (nth 2 NODE) (nth 2 BULGE)) TOL)
      (setq P1 (nth 1 NODE))
      (setq P1 (nth 2 NODE))
     )
     (setq P (list (+ (nth 0 P1) (cos (+ ANG (* DIR THETA2))))
                   (+ (nth 1 P1) (sin (+ ANG (* DIR THETA2))))))
     (setq PINT (inters (nth 1 BULGE) (nth 2 BULGE) P1 P nil))
    )
   )
  )
 )

 (defun GETTANGENT (IO NODE / P1 P2)
  (if (= nil NODE)
   (setq P1 nil P2 nil)
   (if (listp (last NODE))
    (if (= IO "IN")
     (setq P1 (nth 1 NODE) P2 (SPIRALPI NODE))
     (setq P1 (SPIRALPI NODE) P2 (nth 2 NODE))
    )
    (if (< (abs (last NODE)) TOL)
     (setq P1 (nth 1 NODE) P2 (nth 2 NODE))
     (if (= IO "IN")
      (setq P1 (nth 1 NODE) P2 (CURVEPI NODE))
      (setq P1 (CURVEPI NODE) P2 (nth 2 NODE))
     )
    )
   )
  )
  (list P1 P2)
 )

 (defun GETRADIUS (NODE / ATOTAL BULGE CHORD DIR P1 P2 R)
  (if (= nil NODE)
   (setq R 0.0)
   (progn
    (setq P1 (nth 1 NODE))
    (setq P2 (nth 2 NODE))
    (setq BULGE (last NODE))
    (if (listp BULGE)
     (setq R (RFL:GETSPIRALR2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
     (if (< (abs BULGE) TOL)
      (setq R 0.0)
      (progn
       (setq ATOTAL (* 4.0 (atan (abs BULGE))))
;       (setq ATOTAL (* 4.0 (atan BULGE)))
       (setq CHORD (distance P1 P2))
       (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
      )
     )
    )
   )
  )
  (eval R)
 )

 (defun GETLENGTH (NODE / ATOTAL BULGE CHORD L P1 P2 R)
  (if (= nil NODE)
   (setq L nil)
   (progn
    (setq P1 (nth 1 NODE))
    (setq P2 (nth 2 NODE))
    (setq BULGE (last NODE))
    (if (listp BULGE)
     (if (listp (last BULGE))
      (setq L (RFL:GETSPIRALLS2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)))
      (setq L (- (RFL:GETSPIRALLS2 (nth 0 BULGE) (nth 1 BULGE) (nth 2 BULGE)) (last BULGE)))
     )
     (if (< (abs BULGE) TOL)
      (setq L (distance P1 P2))
      (progn
       (setq ATOTAL (* 4.0 (atan (abs BULGE))))
;       (setq ATOTAL (* 4.0 (atan BULGE)))
       (setq CHORD (distance P1 P2))
       (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
       (setq L (* R ATOTAL))
      )
     )
    )
   )
  )
  (eval L)
 )

 (defun REPD (S / TMP)
  (setq TMP (strcat (substr S 1 (- (SEARCH "d" S) 1)) "%%" (substr S (SEARCH "d" S))))
  (if (< (- (SEARCH "'" TMP) (SEARCH "d" TMP)) 3)
   (setq TMP (strcat (substr TMP 1 (SEARCH "d" TMP)) "0" (substr TMP (+ (SEARCH "d" TMP) 1))))
  )
  (if (< (- (SEARCH "." TMP) (SEARCH "'" TMP)) 3)
   (setq TMP (strcat (substr TMP 1 (SEARCH "'" TMP)) "0" (substr TMP (+ (SEARCH "'" TMP) 1))))
  )
  (setq TMP TMP)
 )

 (defun SEARCH (S L / C)
  (setq C 1)
  (while (and (/= (substr L C (strlen S)) S) (<= C (strlen L)))
   (setq C (+ C 1))
  )
  (if (> C (strlen L)) (setq C nil) (setq C C))
 )

 (defun INSERTCURVE ()
  (setq FLAG 1)
  (setq CCOUNT (+ CCOUNT 1))
  (if (= nil C1)
   (setq C1 (list 0.0 (if (/= nil S1) (last S1) (last S2)) 0.0 0.0 0.0))
  )
  (if (< 0 (sin (- (angle (list (nth 3 PIAHEAD) (nth 2 PIAHEAD)) (nth 1 TOUT))
                   (angle (nth 0 TIN) (list (nth 3 PIAHEAD) (nth 2 PIAHEAD)))
                )
           )
      )
   (setq DIR " LT")
   (setq DIR " RT")
  )
  (if (and (= S1 nil) (= S2 nil))
   (INSERTC (strcat "CURVE " (itoa CCOUNT))
            (strcat (rtos (nth 1 C1) 2 3) DIR)
            ""
            (REPD (angtos (nth 0 C1) 1 6))
            (rtos (distance (nth 0 TIN) (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))) 2 3)
            (rtos (distance (list (nth 3 PIAHEAD) (nth 2 PIAHEAD)) (nth 1 TOUT)) 2 3)
            (rtos (nth 2 C1) 2 3)
            (rtos (abs (nth 1 (RFL:STAOFF (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))))) 2 3)
            "N/A"
            ""
            ""
            ""
            ""
            (RFL:STATXT (nth 1 PIAHEAD))
            (rtos (nth 2 PIAHEAD) 2 3)
            (rtos (nth 3 PIAHEAD) 2 3)
   )
   (if (and (/= S1 nil) (= S2 nil))
    (INSERTC (strcat "CURVE " (itoa CCOUNT))
             (strcat (rtos (nth 1 C1) 2 3) DIR)
             (REPD (angtos (+ (nth 0 C1) (nth 0 S1)) 1 6))
             (REPD (angtos (nth 0 C1) 1 6))
             (rtos (distance (nth 0 TIN) (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))) 2 3)
             (rtos (distance (list (nth 3 PIAHEAD) (nth 2 PIAHEAD)) (nth 1 TOUT)) 2 3)
             (rtos (nth 2 C1) 2 3)
             (rtos (abs (nth 1 (RFL:STAOFF (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))))) 2 3)
             "N/A"
             (rtos (- (nth 1 S1) (nth 2 S1)) 2 3)
             (REPD (angtos (nth 0 S1) 1 6))
             ""
             ""
             (RFL:STATXT (nth 1 PIAHEAD))
             (rtos (nth 2 PIAHEAD) 2 3)
             (rtos (nth 3 PIAHEAD) 2 3)
    )
    (if (and (= S1 nil) (/= S2 nil))
     (INSERTC (strcat "CURVE " (itoa CCOUNT))
              (strcat (rtos (nth 1 C1) 2 3) DIR)
              (REPD (angtos (+ (nth 0 C1) (nth 0 S2)) 1 6))
              (REPD (angtos (nth 0 C1) 1 6))
              (rtos (distance (nth 0 TIN) (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))) 2 3)
              (rtos (distance (list (nth 3 PIAHEAD) (nth 2 PIAHEAD)) (nth 1 TOUT)) 2 3)
              (rtos (nth 2 C1) 2 3)
              (rtos (abs (nth 1 (RFL:STAOFF (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))))) 2 3)
              "N/A"
              ""
              ""
              (rtos (- (nth 1 S2) (nth 2 S2)) 2 3)
              (REPD (angtos (nth 0 S2) 1 6))
              (RFL:STATXT (nth 1 PIAHEAD))
              (rtos (nth 2 PIAHEAD) 2 3)
              (rtos (nth 3 PIAHEAD) 2 3)
     )
     (if (and (< (abs (- (nth 0 S1) (nth 0 S2))) TOL)
              (< (abs (- (nth 1 S1) (nth 1 S2))) TOL)
              (< (abs (- (nth 2 S1) (nth 2 S2))) TOL))
      (INSERTC (strcat "CURVE " (itoa CCOUNT))
               (strcat (rtos (nth 1 C1) 2 3) DIR)
               (REPD (angtos (+ (nth 0 C1) (nth 0 S1) (nth 0 S2)) 1 6))
               (REPD (angtos (nth 0 C1) 1 6))
               (rtos (distance (nth 0 TIN) (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))) 2 3)
               (rtos (distance (list (nth 3 PIAHEAD) (nth 2 PIAHEAD)) (nth 1 TOUT)) 2 3)
               (rtos (nth 2 C1) 2 3)
               (rtos (abs (nth 1 (RFL:STAOFF (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))))) 2 3)
               "N/A"
               (rtos (- (nth 1 S1) (nth 2 S1)) 2 3)
               (REPD (angtos (nth 0 S1) 1 6))
               (rtos (- (nth 1 S2) (nth 2 S2)) 2 3)
               (REPD (angtos (nth 0 S2) 1 6))
               (RFL:STATXT (nth 1 PIAHEAD))
               (rtos (nth 2 PIAHEAD) 2 3)
               (rtos (nth 3 PIAHEAD) 2 3)
      )
      (INSERTC (strcat "CURVE " (itoa CCOUNT))
               (strcat (rtos (nth 1 C1) 2 3) DIR)
               (REPD (angtos (+ (nth 0 C1) (nth 0 S1) (nth 0 S2)) 1 6))
               (REPD (angtos (nth 0 C1) 1 6))
               (rtos (distance (nth 0 TIN) (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))) 2 3)
               (rtos (distance (list (nth 3 PIAHEAD) (nth 2 PIAHEAD)) (nth 1 TOUT)) 2 3)
               (rtos (nth 2 C1) 2 3)
               (rtos (abs (nth 1 (RFL:STAOFF (list (nth 3 PIAHEAD) (nth 2 PIAHEAD))))) 2 3)
               "N/A"
               (rtos (- (nth 1 S1) (nth 2 S1)) 2 3)
               (REPD (angtos (nth 0 S1) 1 6))
               (rtos (- (nth 1 S2) (nth 2 S2)) 2 3)
               (REPD (angtos (nth 0 S2) 1 6))
               (RFL:STATXT (nth 1 PIAHEAD))
               (rtos (nth 2 PIAHEAD) 2 3)
               (rtos (nth 3 PIAHEAD) 2 3)
      )
     )
    )
   )
  )
 )

 (defun INSERTC (LABEL CRADIUS DELTA CDELTA CTANGENT1 CTANGENT2 CLENGTH EXT
                 E LS1 THETA1 LS2 THETA2 PISTA PINORTHING PIEASTING
                 / ATTREQ ENT ENTLIST UPDATEFLAG)
  (setq ATTREQ (getvar "ATTREQ"))
  (setvar "ATTREQ" 0)

  (setq PC (list (+ (nth 0 PC) (* (cos ANGC) (* STEPC SCALECX)))
                 (+ (nth 1 PC) (* (sin ANGC) (* STEPC SCALECX)))
           )
  )
  (if (= nil (tblsearch "BLOCK" NAMEC)) (RFL:MAKEENT NAMEC))
  (command "._INSERT" NAMEC PC SCALECX SCALECY (* ANGC (/ 180.0 pi)))
  (setq ENT (entlast))
  (setq ENTLIST (entget ENT))
  (setq ANGC (cdr (assoc 50 ENTLIST)))
  (if (= (cdr (assoc 66 ENTLIST)) 1)
   (progn
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
     (setq UPDATEFLAG T)
     (cond ((= "STEP" (cdr (assoc 2 ENTLIST)))
            (progn
             (setq STEPC (atof (cdr (assoc 1 ENTLIST))))
             (setq UPDATEFLAG nil)
            )
           )
           ((= "LABEL" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 LABEL) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "CRADIUS" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 CRADIUS) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "DELTA" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 DELTA) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "CDELTA" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 CDELTA) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "CTANGENT1" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 CTANGENT1) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "CTANGENT2" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 CTANGENT2) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "CLENGTH" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 CLENGTH) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "EXT" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 EXT) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "E" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 E) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "LS1" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 LS1) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "THETA1" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 THETA1) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "LS2" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 LS2) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "THETA2" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 THETA2) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "PISTA" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 PISTA) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "PINORTHING" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 PINORTHING) (assoc 1 ENTLIST) ENTLIST))
           )
           ((= "PIEASTING" (cdr (assoc 2 ENTLIST)))
            (setq ENTLIST (subst (cons 1 PIEASTING) (assoc 1 ENTLIST) ENTLIST))
           )
           (T (setq UPDTAEFLAG nil))
     )
     (if UPDATEFLAG
      (progn
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
  )
  (setvar "ATTREQ" ATTREQ)
 )

 (defun INSERTH (PNT STA NORTHING EASTING / ATTREQ ENT ENTLIST)
  (setq ATTREQ (getvar "ATTREQ"))
  (setvar "ATTREQ" 0)

  (setq PH (list (+ (nth 0 PH) (* (sin ANGH) (* STEPH SCALEHY)))
                 (- (nth 1 PH) (* (cos ANGH) (* STEPH SCALEHY)))
           )
  )
  (if (= nil (tblsearch "BLOCK" NAMEH)) (RFL:MAKEENT NAMEH))
  (command "._INSERT" NAMEH PH SCALEHX SCALEHY (* ANGH (/ 180.0 pi)))
  (setq ENT (entlast))
  (setq ENTLIST (entget ENT))
  (setq ANGH (cdr (assoc 50 ENTLIST)))
  (if (= (cdr (assoc 66 ENTLIST)) 1)
   (progn
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
     (if (= (cdr (assoc 2 ENTLIST)) "STEP")
      (progn
       (setq STEPH (atof (cdr (assoc 1 ENTLIST))))
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "PNT")
      (progn
       (setq ENTLIST (subst (cons 1 PNT) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "STA")
      (progn
       (setq ENTLIST (subst (cons 1 STA) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "NORTHING")
      (progn
       (setq ENTLIST (subst (cons 1 NORTHING) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (if (= (cdr (assoc 2 ENTLIST)) "EASTING")
      (progn
       (setq ENTLIST (subst (cons 1 EASTING) (assoc 1 ENTLIST) ENTLIST))
       (entmod ENTLIST)
       (entupd ENT)
      )
     )
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
  )

  (setvar "ATTREQ" ATTREQ)
 )

 (if (= nil (tblsearch "BLOCK" "ALTABLE01"))
  (progn
   (RFL:MAKEENT "ALTABLE01")
   (princ "\nCreating block: ALTABLE01")
  )
 )
 (if (= nil (tblsearch "BLOCK" "CURVETABLE"))
  (progn
   (RFL:MAKEENT "CURVETABLE")
   (princ "\nCreating block: CURVETABLE")
  )
 )

 (if (= RFL:GETSPIRALR nil)
  (alert "Alignment utilities not loaded!")
  (if (= RFL:ALIGNLIST nil)
   (alert "No alignment defined!")
   (progn
    (setq TMP (fix (/ (car (car RFL:ALIGNLIST)) 1000.0)))
    (if (= (* (fix (/ (float TMP) 10.0)) 10) TMP) (setq TMP (+ TMP 1)))
    (setq CCOUNT (getint (strcat "\nEnter start curve number <" (itoa TMP) "> :")))
    (if (= CCOUNT nil) (setq CCOUNT TMP))
    (setq CCOUNT (- CCOUNT 1))
    (setq AL RFL:ALIGNLIST)
    (setq NODEPREV nil)
    (setq NODE (car AL))
    (setq NODENEXT (car (cdr AL)))
    (if (/= (setq ENT (car (entsel "\nSelect curve table : "))) nil)
     (progn
      (setq ENTLIST (entget ENT))
      (if (and (= (cdr (assoc 0 ENTLIST)) "INSERT") (= (cdr (assoc 66 ENTLIST)) 1))
       (progn
        (setq NAMEC (strcat (cdr (assoc 2 ENTLIST)) "DATA"))
        (setq SCALECX (cdr (assoc 41 ENTLIST)))
        (setq SCALECY (cdr (assoc 42 ENTLIST)))
        (setq PC (cdr (assoc 10 ENTLIST)))
        (setq ANGC (cdr (assoc 50 ENTLIST)))
        (setq STEPC nil)
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
        (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
         (if (= (cdr (assoc 2 ENTLIST)) "STEP") (setq STEPC (atof (cdr (assoc 1 ENTLIST)))))
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
        )
        (INSERTC "START"
                 ""
                 ""
                 ""
                 ""
                 ""
                 ""
                 ""
                 "N/A"
                 ""
                 ""
                 ""
                 ""
                 (RFL:STATXT (nth 0 NODE))
                 (rtos (nth 1 (nth 1 NODE)) 2 3)
                 (rtos (nth 0 (nth 1 NODE)) 2 3)
        )
        (while (/= NODE nil)
         (setq R (GETRADIUS NODE))
         (setq RNEXT (GETRADIUS NODENEXT))
         (if (and (= R 0.0) (= RNEXT 0.0) (/= NODENEXT nil))
          (progn
           (setq TIN (GETTANGENT "IN" NODE))
           (setq TOUT (GETTANGENT "OUT" NODENEXT))
           (setq CCOUNT (+ CCOUNT 1))
           (GETCURVE NODE)
           (INSERTC (strcat "CURVE " (itoa CCOUNT))
                    ""
                    (REPD (angtos (nth 0 C1) 1 6))
                    ""
                    ""
                    ""
                    ""
                    ""
                    "N/A"
                    ""
                    ""
                    ""
                    ""
                    (RFL:STATXT (+ (nth 0 NODE) (GETLENGTH NODE)))
                    (rtos (nth 1 (nth 2 NODE)) 2 3)
                    (rtos (nth 0 (nth 2 NODE)) 2 3)
           )
           (setq NODEPREV NODE)
           (setq AL (cdr AL))
           (setq NODE (car AL))
           (setq NODENEXT (car (cdr AL)))
          )
          (if (= R 0.0)
           (progn
            (setq NODEPREV NODE)
            (setq AL (cdr AL))
            (setq NODE (car AL))
            (setq NODENEXT (car (cdr AL)))
           )
           (progn
            (setq NODEPI nil)
            (setq TIN (GETTANGENT "IN" NODE))
            (setq TOUT (GETTANGENT "OUT" NODE))
            (setq S1 nil S2 nil C1 nil)
            (setq CURVECOUNT (CHECKCURVE NODE))
            (GETCURVE NODE)
            (setq NODEPI (append NODEPI (list (list (GETCODE NODEPREV NODE)
                                                    (nth 0 NODE)
                                                    (nth 1 (nth 1 NODE))
                                                    (nth 0 (nth 1 NODE))
                                              )
                                        )
                         )
            )
            (setq CURVECOUNT (+ CURVECOUNT (CHECKCURVE NODENEXT)))
            (while (and (< (abs (- R RNEXT)) TOL)
                        (= (GETDIR NODE) (GETDIR NODENEXT))
                        (< CURVECOUNT 4) ; changed 2 to 4
                   )
             (setq NODEPREV NODE)
             (setq AL (cdr AL))
             (setq NODE (car AL))
             (setq NODENEXT (car (cdr AL)))
             (setq TOUT (GETTANGENT "OUT" NODE))
             (setq R RNEXT)
             (setq RNEXT (GETRADIUS NODENEXT))
             (GETCURVE NODE)
             (setq NODEPI (append NODEPI (list (list (GETCODE NODEPREV NODE)
                                                     (nth 0 NODE)
                                                     (nth 1 (nth 1 NODE))
                                                     (nth 0 (nth 1 NODE))
                                               )
                                         )
                          )
             )
             (setq CURVECOUNT (+ CURVECOUNT (CHECKCURVE NODENEXT)))
            )
            (if (= RNEXT 0.0)
             (setq NODEPI (append NODEPI (list (list (GETCODE NODE NODENEXT)
                                                     (+ (nth 0 NODE) (GETLENGTH NODE))
                                                     (nth 1 (nth 2 NODE))
                                                     (nth 0 (nth 2 NODE))
                                               )
                                         )
                          )
             )
            )
            (setq PINT (inters (nth 0 TIN) (nth 1 TIN) (nth 0 TOUT) (nth 1 TOUT) nil))
            (setq PTMP (list (nth 1 (cdr (cdr (car NODEPI)))) (nth 0 (cdr (cdr (car NODEPI))))))
            (setq PIAHEAD (list "P.I."
                                (+ (nth 1 (car NODEPI)) (distance PTMP PINT))
                                (nth 1 PINT)
                                (nth 0 PINT)
                          )
            )
            (setq PTMP (list (nth 1 (cdr (cdr (last NODEPI)))) (nth 0 (cdr (cdr (last NODEPI))))))
            (setq PIBACK (list "P.I."
                               (- (+ (nth 0 NODE) (GETLENGTH NODE)) (distance PTMP PINT))
                               (nth 1 PINT)
                               (nth 0 PINT)
                         )
            )
            (setq FLAG 0)
            (while (/= nil NODEPI)
             (if (and (= FLAG 0) (> (nth 1 (car NODEPI)) (nth 1 PIAHEAD)))
              (INSERTCURVE)
             )
             (setq NODEPI (cdr NODEPI))
            )
            (if (= FLAG 0)
             (INSERTCURVE)
            )
            (setq NODEPREV NODE)
            (setq AL (cdr AL))
            (setq NODE (car AL))
            (setq NODENEXT (car (cdr AL)))
           )
          )
         )         
        )
        (if (= NODE nil) (setq NODE NODEPREV))
        (INSERTC "END"
                 ""
                 ""
                 ""
                 ""
                 ""
                 ""
                 ""
                 "N/A"
                 ""
                 ""
                 ""
                 ""
                 (RFL:STATXT (+ (nth 0 NODE) (GETLENGTH NODE)))
                 (rtos (nth 1 (nth 2 NODE)) 2 3)
                 (rtos (nth 0 (nth 2 NODE)) 2 3)
        )
       )
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "CLAYER" CLAYER)
 (setvar "DIMZIN" DIMZIN)
 (setvar "OSMODE" OSMODE)
 (setvar "ATTREQ" ATTREQ)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)(defun RFL:INTERSA (P1 P2 P3 P4 BULGE / ANG1 ANG2 D D1 D2 D3 D4 OFFSET PA PB PCEN R)
 (setq P1 (list (car P1) (cadr P1)))
 (setq P2 (list (car P2) (cadr P2)))
 (setq P3 (list (car P3) (cadr P3)))
 (setq P4 (list (car P4) (cadr P4)))
 (if (< (abs BULGE) RFL:TOL)
  (progn
   (setq PA (inters P1 P2 P3 P4 nil))
   (if (/= PA nil)
    (progn
     (if (or (> (distance P1 PA) (distance P1 P2))
             (> (distance P2 PA) (distance P1 P2))
         )
      (progn
       (setq PA nil)
      )
     )
    )
   )
   (setq PB PA)
  )
  (progn
   (setq PCEN (CENTER P3 P4 BULGE))
   (setq R (RFL:RADIUS P3 P4 BULGE))
   (setq D1 (distance P1 PCEN))
   (setq D2 (distance PCEN P2))
   (setq D (distance P1 P2))
   (setq D3 (/ (+ (- (* D1 D1) (* D2 D2)) (* D D))
               (* 2.0 D)
            )
   )
   (setq D4 (/ (+ (- (* D2 D2) (* D1 D1)) (* D D))
               (* 2.0 D)
            )
   )
   (setq OFFSET (sqrt (abs (- (* D1 D1) (* D3 D3)))))
   (if (> OFFSET (+ R RFL:TOL))
    (progn
     (setq PA nil)
     (setq PB PA)
    )
    (progn
     (if (and (<= OFFSET (+ R RFL:TOL)) (>= OFFSET (- R RFL:TOL)))
      (progn
       (setq PA (list (+ (car P1) (* D3 (/ (- (car P2) (car P1)) D)))
                      (+ (cadr P1) (* D3 (/ (- (cadr P2) (cadr P1)) D)))
                )
       )
       (setq PB PA)
      )
      (progn
       (setq D5 (- D3 (sqrt (- (* R R) (* OFFSET OFFSET)))))
       (setq PA (list (+ (car P1) (* D5 (/ (- (car P2) (car P1)) D)))
                      (+ (cadr P1) (* D5 (/ (- (cadr P2) (cadr P1)) D)))
                )
       )
       (setq D6 (+ D3 (sqrt (- (* R R) (* OFFSET OFFSET)))))
       (setq PB (list (+ (car P1) (* D6 (/ (- (car P2) (car P1)) D)))
                      (+ (cadr P1) (* D6 (/ (- (cadr P2) (cadr P1)) D)))
                )
       )
      )
     )
     (if (< BULGE 0.0)
      (setq ANG1 (- (angle PCEN P3) (angle PCEN PA)))
      (setq ANG1 (- (angle PCEN PA) (angle PCEN P3)))
     )
     (while (< ANG1 0.0) (setq ANG1 (+ ANG1 (* 2.0 pi))))
     (if (< BULGE 0.0)
      (setq ANG2 (- (angle PCEN P3) (angle PCEN P4)))
      (setq ANG2 (- (angle PCEN P4) (angle PCEN P3)))
     )
     (while (< ANG2 0.0) (setq ANG2 (+ ANG2 (* 2.0 pi))))
     (if (> ANG1 ANG2)
      (progn
       (setq PA nil)
      )
     )
     (if (< BULGE 0.0)
      (setq ANG1 (- (angle PCEN P3) (angle PCEN PB)))
      (setq ANG1 (- (angle PCEN PB) (angle PCEN P3)))
     )
     (while (< ANG1 0.0) (setq ANG1 (+ ANG1 (* 2.0 pi))))
     (if (< BULGE 0.0)
      (setq ANG2 (- (angle PCEN P3) (angle PCEN P4)))
      (setq ANG2 (- (angle PCEN P4) (angle PCEN P3)))
     )
     (while (< ANG2 0.0) (setq ANG2 (+ ANG2 (* 2.0 pi))))
     (if (> ANG1 ANG2)
      (progn
       (setq PB nil)
      )
     )
    )
   )
  )
 )
 (list PA PB)
)
;
;
;     Program written by Robert Livingston, 2016/07/05
;
;     RFL:LALIGNSTALBL is a utility for placing STALBL blocks along and alignment
;
;
(defun RFL:LALIGNSTALBL (STASTART STAEND INC OS R / HANDLE HANDLEPREV)
 (if RFL:ALIGNLIST
  (progn
  )
  (princ "\n*** No alignment defined! ***\n")
 )
 nil
)
;
;
;   Program written by Robert Livingston, 99/09/10
;
;   RFL:MPOINT is a routine that returns a set of points from one station/offset to another station/offset
;          (note - ALIGN must be loaded and an alignment must be set.  Also recommended to turn off your osnaps)
;
;
(defun RFL:MPOINT2 (STATION1 OFFSET1 STATION2 OFFSET2 CMAX / C OFFSETINC P STATIONINC)
 (if (and (/= RFL:ALIGNLIST nil) (/= RFL:XY nil))
  (progn
   (setq C 0)
   (while (< C (+ CMAX 1))
    (setq P (RFL:XY (list (+ STATION1 (* (- STATION2 STATION1) (/ (float C) (float CMAX))))
                          (+ OFFSET1 (* (- OFFSET2 OFFSET1) (/ (float C) (float CMAX))))
                    )
            )
    )
    (print P)
    (command "_NON" P)
    (setq C (+ C 1))
   )
  )
 )
)
(defun RFL:MPOINT (/ C CMAX CMDECHO OFFSET1 OFFSET2 STATION1 STATION2)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (if (and (/= RFL:ALIGNLIST nil) (/= RFL:XY nil))
  (progn
   (setq STATION1 (getreal "\nEnter start station : "))
   (setq OFFSET1 (getreal "\nEnter start offset : "))
   (setq STATION2 (getreal "\nEnter end station : "))
   (setq OFFSET2 (getreal "\nEnter end offset : "))
   (setq CMAX (getint "\nEnter number of steps : "))
   (RFL:MPOINT2 STATION1 OFFSET1 STATION2 OFFSET2 CMAX)
  )
 )
 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 98/06/11
;
;   RFL:RALIGN reads a horizontal alignment from the specified file
;
;
(defun RFL:RALIGN (INFILENAME / ANGBASE ANGDIR CMDECHO INFILE INLINE LO P1X P1Y P2X P2Y
                                PLTX PLTY PLTSTX PLTSTY PSTX PSTY BULGE)
 (if (/= INFILENAME nil) (setq INFILENAME (findfile INFILENAME)))
 (if (/= INFILENAME nil)
  (progn
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory INFILENAME) "\\"))
   (setq INFILE (open INFILENAME "r"))
   (setq RFL:ALIGNLIST nil)
   (setq INLINE (read-line INFILE))
   (if (/= INLINE "#RFL HORIZONTAL ALIGNMENT FILE")
    (progn
     (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
    )
    (progn
     (setq INLINE (read-line INFILE))
     (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
      (setq STA (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq P1X (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq P1Y (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq P2X (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq P2Y (atof INLINE))
      (setq INLINE (read-line INFILE))
      (if (= INLINE "SPIRAL")
       (progn
        (setq INLINE (read-line INFILE))
        (setq PLTX (atof INLINE))
        (setq INLINE (read-line INFILE))
        (setq PLTY (atof INLINE))
        (setq INLINE (read-line INFILE))
        (setq PLTSTX (atof INLINE))
        (setq INLINE (read-line INFILE))
        (setq PLTSTY (atof INLINE))
        (setq INLINE (read-line INFILE))
        (setq PSTX (atof INLINE))
        (setq INLINE (read-line INFILE))
        (setq PSTY (atof INLINE))
        (setq INLINE (read-line INFILE))
        (setq LO (atof INLINE))
        (setq BULGE (list (list PLTX PLTY) (list PLTSTX PLTSTY) (list PSTX PSTY) LO))
       )
       (progn
        (setq BULGE (atof INLINE))
       )
      )
      (setq INLINE (read-line INFILE))
      (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list STA (list P1X P1Y) (list P2X P2Y) BULGE))))
     )
    )
   )
   (close INFILE)
  )
 )
);
;
;   Program written by Robert Livingston, 2008/11/04
;
;   RFL:RALIGNB reads a horizontal alignment from a RFLAlign Block
;
;
(defun RFL:RALIGNB (BLKENT / ENT ENTLIST INLINE LO P1X P1Y P2X P2Y
                             PLTX PLTY PLTSTX PLTSTY PSTX PSTY BULGE)
 (setq RFL:ALIGNLIST nil)
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "HOR" (cdr (assoc 2 ENTLIST)))
  (setq ENT (entnext ENT))
  (setq ENTLIST (entget ENT))
 )
 (setq INLINE (cdr (assoc 1 ENTLIST)))
 (setq ENT (entnext ENT))
 (setq ENTLIST (entget ENT))
 (if (/= INLINE "#RFL HORIZONTAL ALIGNMENT FILE")
  (progn
   (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
  )
  (progn
   (setq INLINE (cdr (assoc 1 ENTLIST)))
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
    (setq STA (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq P1X (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq P1Y (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq P2X (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq P2Y (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (if (= INLINE "SPIRAL")
     (progn
      (setq INLINE (cdr (assoc 1 ENTLIST)))
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (setq PLTX (atof INLINE))
      (setq INLINE (cdr (assoc 1 ENTLIST)))
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (setq PLTY (atof INLINE))
      (setq INLINE (cdr (assoc 1 ENTLIST)))
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (setq PLTSTX (atof INLINE))
      (setq INLINE (cdr (assoc 1 ENTLIST)))
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (setq PLTSTY (atof INLINE))
      (setq INLINE (cdr (assoc 1 ENTLIST)))
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (setq PSTX (atof INLINE))
      (setq INLINE (cdr (assoc 1 ENTLIST)))
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (setq PSTY (atof INLINE))
      (setq INLINE (cdr (assoc 1 ENTLIST)))
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (setq LO (atof INLINE))
      (setq BULGE (list (list PLTX PLTY) (list PLTSTX PLTSTY) (list PSTX PSTY) LO))
     )
     (progn
      (setq BULGE (atof INLINE))
     )
    )
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list STA (list P1X P1Y) (list P2X P2Y) BULGE))))
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:STAOFF returns a list of (STA OFFSET) for a provided (X Y)
;
;
(if RFL:STAOFF (princ "\nRFL:STAOFF already loaded...")
(defun RFL:STAOFF (P / ANG ANG1 ANG2 AL C D D1 D11 D2 D22 OFFSET
                       P1 P2 PLT PLTST PST LO
                       OFFSETBEST PC R STA STABEST TMP)
 (setq STABEST nil)
 (setq OFFSETBEST nil)
 (if (/= RFL:ALIGNLIST nil)
  (progn
   (setq C 0)
   (setq AL (nth C RFL:ALIGNLIST))
   (while (/= AL nil)
    (if (> (distance (cadr AL) (caddr AL)) RFL:TOLFINE)
     (progn
      (if (listp (cadddr AL))
       (progn
        (setq P1 (cadr AL))
        (setq P2 (caddr AL))
        (setq PLT (car (cadddr AL)))
        (setq PLTST (cadr (cadddr AL)))
        (setq PST (caddr (cadddr AL)))
        (setq LO (cadddr (cadddr AL)))
        (if (= (RFL:SPIRALPOINTON P PLT PLTST PST LO) 1)
         (progn
          (setq TMP (RFL:SPIRALSTAOFF2 P PLT PLTST PST LO))
          (if (< (distance P2 PST) (distance P1 PST))
           (progn
            (setq STA (- (+ (car AL) (car TMP)) LO))
            (setq OFFSET (cadr TMP))
           )
           (progn
            (setq STA (- (+ (car AL) (RFL:GETSPIRALLS2 PLT PLTST PST)) (car TMP)))
            (setq OFFSET (* -1.0 (cadr TMP)))
           )
          )
          (if (= STABEST nil)
           (progn
            (setq STABEST STA)
            (setq OFFSETBEST OFFSET)
           )
           (progn
            (if (< (abs OFFSET) (abs OFFSETBEST))
             (progn
              (setq STABEST STA)
              (setq OFFSETBEST OFFSET)
             )
            )
           )
          )
         )
        )
       )
       (progn
        (if (< (abs (cadddr AL)) RFL:TOLFINE)
         (progn
          (setq D (distance (cadr AL) (caddr AL)))
          (setq D1 (distance (cadr AL) P))
          (setq D2 (distance (caddr AL) P))
          (setq D11 (/ (+ (* D D)
                          (- (* D1 D1)
                             (* D2 D2)
                          )
                       )
                       (* 2.0 D)
                    )
          )
          (setq D22 (- D D11))
          (if (and (<= D11 (+ D RFL:TOLFINE)) (<= D22 (+ D RFL:TOLFINE)))
           (progn
            (setq STA (+ (car AL) D11))
            (setq OFFSET (sqrt (abs (- (* D1 D1) (* D11 D11)))))
            (setq ANG (- (angle (cadr AL) (caddr AL)) (angle (cadr AL) P)))
            (while (< ANG 0.0) (setq ANG (+ ANG (* 2.0 pi))))
            (if (> ANG (/ pi 2.0)) (setq OFFSET (* OFFSET -1.0)))
            (if (= STABEST nil)
             (progn
              (setq STABEST STA)
              (setq OFFSETBEST OFFSET)
             )
             (progn
              (if (< (abs OFFSET) (abs OFFSETBEST))
               (progn
                (setq STABEST STA)
                (setq OFFSETBEST OFFSET)
               )
              )
             )
            )
           )
          )
         )
         (progn
          (setq PC (RFL:CENTER (cadr AL) (caddr AL) (cadddr AL)))
          (if (< (cadddr AL) 0.0)
           (setq ANG1 (- (angle PC (cadr AL)) (angle PC P)))
           (setq ANG1 (- (angle PC P) (angle PC (cadr AL))))
          )
          (while (< ANG1 0.0) (setq ANG1 (+ ANG1 (* 2.0 pi))))
          (if (< (cadddr AL) 0.0)
           (setq ANG2 (- (angle PC (cadr AL)) (angle PC (caddr AL))))
           (setq ANG2 (- (angle PC (caddr AL)) (angle PC (cadr AL))))
          )
          (while (< ANG2 0.0) (setq ANG2 (+ ANG2 (* 2.0 pi))))
          (if (<= ANG1 (+ ANG2 RFL:TOLFINE))
           (progn
            (setq R (RFL:RADIUS (cadr AL) (caddr AL) (cadddr AL)))
            (setq STA (+ (car AL) (* R ANG1)))
            (setq OFFSET (- (distance PC P) R))
            (if (< (cadddr AL) 0.0) (setq OFFSET (* -1.0 OFFSET)))
            (if (= STABEST nil)
             (progn
              (setq STABEST STA)
              (setq OFFSETBEST OFFSET)
             )
             (progn
              (if (< (abs OFFSET) (abs OFFSETBEST))
               (progn
                (setq STABEST STA)
                (setq OFFSETBEST OFFSET)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
    (setq C (+ C 1))
    (setq AL (nth C RFL:ALIGNLIST))
   )
  )
 )
 (if (= STABEST nil)
  (eval nil)
  (list STABEST OFFSETBEST)
 )
)
)
;
;
;   Program written by Robert Livingston, 98/06/11
;
;   RFL:WALIGN writes a horizontal alignment to the specifiedfile
;
;
(defun RFL:WALIGN (OUTFILENAME / C OUTFILE)
 (if (/= OUTFILENAME nil)
  (progn
   (if (/= ".HOR" (strcase (substr OUTFILENAME (- (strlen OUTFILENAME) 3))))
    (setq OUTFILENAME (strcat OUTFILENAME ".HOR"))
   )
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory OUTFILENAME) "\\"))
   (setq C 0)
   (while (and (= nil (setq OUTFILE (open OUTFILENAME "w"))) (< C 5))
    (setq C (+ C 1))
    (princ (strcat "\nProblem openning file for writing : " (itoa C)))
   )
   (if (= nil OUTFILE)
    (alert (strcat "Error openning file for writing : " OUTFILENAME))
    (progn
     (princ "#RFL HORIZONTAL ALIGNMENT FILE\n" OUTFILE)
     (setq C 0)
     (while (< C (length RFL:ALIGNLIST))
      (princ (rtos (nth 0 (nth C RFL:ALIGNLIST)) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (rtos (nth 0 (nth 1 (nth C RFL:ALIGNLIST))) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (rtos (nth 1 (nth 1 (nth C RFL:ALIGNLIST))) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (rtos (nth 0 (nth 2 (nth C RFL:ALIGNLIST))) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (rtos (nth 1 (nth 2 (nth C RFL:ALIGNLIST))) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (if (listp (nth 3 (nth C RFL:ALIGNLIST)))
       (progn
        (princ "SPIRAL\n" OUTFILE)
        (princ (rtos (nth 0 (nth 0 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16) OUTFILE)
        (princ "\n" OUTFILE)
        (princ (rtos (nth 1 (nth 0 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16) OUTFILE)
        (princ "\n" OUTFILE)
        (princ (rtos (nth 0 (nth 1 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16) OUTFILE)
        (princ "\n" OUTFILE)
        (princ (rtos (nth 1 (nth 1 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16) OUTFILE)
        (princ "\n" OUTFILE)
        (princ (rtos (nth 0 (nth 2 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16) OUTFILE)
        (princ "\n" OUTFILE)
        (princ (rtos (nth 1 (nth 2 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16) OUTFILE)
        (princ "\n" OUTFILE)
        (princ (rtos (nth 3 (nth 3 (nth C RFL:ALIGNLIST))) 2 16) OUTFILE)
       )
       (progn
        (princ (rtos (nth 3 (nth C RFL:ALIGNLIST)) 2 16) OUTFILE)
       )
      )
      (princ "\n" OUTFILE)
      (setq C (+ C 1))
     )
     (princ "#END DEFINITION\n" OUTFILE)
     (close OUTFILE)
    )
   )
  )
 )
)
(defun RFL:WALIGNB (BLKENT / BLKENTNEW BLKENTLIST C ENT ENTLIST ENTN)
 (entmake)
 (setq BLKENTLIST (entget BLKENT))
 (setq BLKENTNEW (entmake BLKENTLIST))
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
  (if (= "HOR" (cdr (assoc 2 ENTLIST)))
   (progn
    (setq ENTLIST (subst (cons 1 "#RFL HORIZONTAL ALIGNMENT FILE") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq C 0)
    (while (< C (length RFL:ALIGNLIST))
     (setq ENTLIST (subst (cons 70 1) (assoc 70 ENTLIST) ENTLIST))
     (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth C RFL:ALIGNLIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth 1 (nth C RFL:ALIGNLIST))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth 1 (nth C RFL:ALIGNLIST))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth 2 (nth C RFL:ALIGNLIST))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth 2 (nth C RFL:ALIGNLIST))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (if (listp (nth 3 (nth C RFL:ALIGNLIST)))
      (progn
       (setq ENTLIST (subst (cons 1 "SPIRAL") (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
       (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth 0 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
       (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth 0 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
       (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth 1 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
       (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth 1 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
       (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth 2 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
       (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth 2 (nth 3 (nth C RFL:ALIGNLIST)))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
       (setq ENTLIST (subst (cons 1 (rtos (nth 3 (nth 3 (nth C RFL:ALIGNLIST))) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
      )
      (progn
       (setq ENTLIST (subst (cons 1 (rtos (nth 3 (nth C RFL:ALIGNLIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
       (entmake ENTLIST)
      )
     )
     (setq C (+ C 1))
    )
    (setq ENTLIST (subst (cons 1 "#END DEFINITION") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (= "HOR" (cdr (assoc 2 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
   (progn
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
  )
 )
 (entmake ENTLIST)
 (entdel BLKENT)
 (setq BLKENTNEW (entlast))
)
;
;
;   Program written by Robert Livingston, 98/06/12
;
;   RFL:XY returns a list of (X Y) for a provided (STA OFFSET)
;
;
(if RFL:XY (princ "\nRFL:XY already loaded...")
(defun RFL:XY (P / ANG AL ALTMP C D OFFSET P1 P2 PC POINT STA X Y TOL)
 (setq TOL 0.00000001)
 (defun POINT (P1 P2 BULGE L / A ATOTAL C CHORD LTOTAL P PC R SB X Y)
  (setq CHORD (distance P1 P2))
  (if (< (abs BULGE) TOL)
   (progn
    (list (+ (* (/ L CHORD) (- (car P2) (car P1))) (car P1))
          (+ (* (/ L CHORD) (- (cadr P2) (cadr P1))) (cadr P1)))
   )
   (progn
    (setq ATOTAL (* 4.0 (atan (abs BULGE))))
    (setq PC (RFL:CENTER P1 P2 BULGE))
    (setq R (RFL:RADIUS P1 P2 BULGE))
    (setq A (+ (angle PC P1) (* (RFL:SIGN BULGE) (/ L R))))
    (list (+ (car PC) (* R (cos A)))
          (+ (cadr PC) (* R (sin A))))
   )
  )
 )
 (if (/= nil RFL:ALIGNLIST)
  (progn
   (setq STA (car P))
   (setq OFFSET (cadr P))
   (setq AL (last RFL:ALIGNLIST))
   (if (<= STA (+ (car AL) (RFL:DIST (cadr AL) (caddr AL) (cadddr AL))))
    (progn
     (setq AL (car RFL:ALIGNLIST))
     (setq ALTMP (cdr RFL:ALIGNLIST))
     (if (>= STA (car AL))
      (progn
       (while (> STA (+ (car AL) (RFL:DIST (cadr AL) (caddr AL) (cadddr AL))))
        (setq AL (car ALTMP))
        (setq ALTMP (cdr ALTMP))
       )
       (if (listp (cadddr AL))
        (progn
         (if (< (distance (caddr AL) (caddr (cadddr AL))) (distance (cadr AL) (caddr (cadddr AL))))
          (progn
           (setq P1 (RFL:SPIRALXY2 (list (+ (- STA
                                           (car AL)
                                        )
                                        (cadddr (cadddr AL))
                                     )
                                     OFFSET
                               )
                               (car (cadddr AL))
                               (cadr (cadddr AL))
                               (caddr (cadddr AL))
                    )
           )
          )
          (progn
           (setq P1 (RFL:SPIRALXY2 (list (- (RFL:GETSPIRALLS2 (car (cadddr AL))
                                                              (cadr (cadddr AL))
                                                              (caddr (cadddr AL))
                                            )
                                            (- STA
                                               (car AL)
                                            )
                                         )
                                         (* -1.0 OFFSET)
                                   )
                                   (car (cadddr AL))
                                   (cadr (cadddr AL))
                                   (caddr (cadddr AL))
                    )
           )
          )
         )
        )
        (progn
         (setq P2 (POINT (cadr AL) (caddr AL) (cadddr AL) (- STA (car AL))))
         (if (< (abs (cadddr AL)) TOL)
          (progn
           (setq ANG (angle (cadr AL) (caddr AL)))
           (setq D (distance (cadr AL) P2))
           (setq P1 (list (+ (+ (car (cadr AL)) (* D (cos ANG))) (* OFFSET (sin ANG)))
                          (- (+ (cadr (cadr AL)) (* D (sin ANG))) (* OFFSET (cos ANG)))
                    )
           )
          )
          (progn
           (setq PC (RFL:CENTER (cadr AL) (caddr AL) (cadddr AL)))
           (if (< (cadddr AL) 0.0)
            (setq ANG (angle P2 PC))
            (setq ANG (angle PC P2))
           )
           (setq P1 (list (+ (car P2) (* OFFSET (cos ANG)))
                          (+ (cadr P2) (* OFFSET (sin ANG)))
                    )
           )
          )
         )
        )
       )
      )
      (progn
       (princ "\n**** STATION OUT OF RANGE ****")
       nil
      )
     )
    )
    (progn
     (princ "\n**** STATION OUT OF RANGE ****")
     nil
    )
   )
  )
  (progn
   (princ "\n**** NO ALIGNMENT DEFINED ****")
   nil
  )
 )
)
)
;
;
;   Program written by Robert Livingston, 99/12/03
;
;   (RFL:XYP) returns the X,Y point for a station and offset of the currently defined alignment
;
;
(defun RFL:XYP (/ ACCEPTXYP AL ANG CANCEL CANCELXYP DCL_ID ENT FIXE FIXN FIXSTA FIXOS
                  FIXFROMSTA FIXFROMOS FIXTOSTA FIXTOOS
                  FIXSTEP FIXXFROMSTA FIXXTOSTA FIXXSWATH FIXXINC INC INFILE INLINE
                  NODE NODEPOINT P P1 P2 PREVENT RERUN STA STA1 STA2 STAMIN STAMAX STANODE
                  TMP UPDATENE UPDATESTAOFF)

 (defun ACCEPTXYP (TMP)
  (setq CANCEL TMP)
  (setq XYPSTA (atof (get_tile "STATION")))
  (setq XYPOS (atof (get_tile "OFFSET")))
  (setq XYPFROMSTA (atof (get_tile "FROMSTATION")))
  (setq XYPFROMOS (atof (get_tile "FROMOFFSET")))
  (setq XYPTOSTA (atof (get_tile "TOSTATION")))
  (setq XYPTOOS (atof (get_tile "TOOFFSET")))
  (setq XYPSTEP (atoi (get_tile "STEP")))
  (setq XYPXFROMSTA (atof (get_tile "XFROMSTATION")))
  (setq XYPXTOSTA (atof (get_tile "XTOSTATION")))
  (setq XYPXROUND (get_tile "XROUND"))
  (setq XYPXSWATH (atof (get_tile "XSWATH")))
  (setq XYPXINC (atof (get_tile "XINC")))
  (setq XYPXSPECIAL (get_tile "XSPECIAL"))
  (done_dialog)
 )

 (defun CANCELXYP ()
  (setq CANCEL 1)
  (done_dialog)
 )

 (defun FIXSTA (/ TMP)
  (setq TMP (atof (get_tile "STATION")))
  (if (< TMP STAMIN) (setq TMP STAMIN))
  (if (> TMP STAMAX) (setq TMP STAMAX))
  (set_tile "STATION" (rtos TMP))
  (UPDATENE)
 )

 (defun FIXOS ()
  (set_tile "OFFSET" (rtos (atof (get_tile "OFFSET"))))
  (UPDATENE)
 )

 (defun FIXN ()
  (set_tile "NORTHING" (rtos (atof (get_tile "NORTHING"))))
  (UPDATESTAOFF)
 )

 (defun FIXE ()
  (set_tile "EASTING" (rtos (atof (get_tile "EASTING"))))
  (UPDATESTAOFF)
 )

 (defun FIXFROMSTA (/ TMP)
  (setq TMP (atof (get_tile "FROMSTATION")))
  (if (< TMP STAMIN) (setq TMP STAMIN))
  (if (> TMP STAMAX) (setq TMP STAMAX))
  (set_tile "FROMSTATION" (rtos TMP))
 )

 (defun FIXFROMOS ()
  (set_tile "FROMOFFSET" (rtos (atof (get_tile "FROMOFFSET"))))
 )

 (defun FIXTOSTA (/ TMP)
  (setq TMP (atof (get_tile "TOSTATION")))
  (if (< TMP STAMIN) (setq TMP STAMIN))
  (if (> TMP STAMAX) (setq TMP STAMAX))
  (set_tile "TOSTATION" (rtos TMP))
 )

 (defun FIXTOOS ()
  (set_tile "TOOFFSET" (rtos (atof (get_tile "TOOFFSET"))))
 )

 (defun FIXSTEP (/ TMP)
  (setq TMP (atoi (get_tile "STEP")))
  (if (< TMP 1) (setq TMP 1))
  (set_tile "STEP" (itoa TMP))
 )

 (defun FIXXFROMSTA (/ TMP)
  (setq TMP (atof (get_tile "XFROMSTATION")))
  (if (< TMP STAMIN) (setq TMP STAMIN))
  (if (> TMP STAMAX) (setq TMP STAMAX))
  (set_tile "XFROMSTATION" (rtos TMP))
 )

 (defun FIXXTOSTA (/ TMP)
  (setq TMP (atof (get_tile "XTOSTATION")))
  (if (< TMP STAMIN) (setq TMP STAMIN))
  (if (> TMP STAMAX) (setq TMP STAMAX))
  (set_tile "XTOSTATION" (rtos TMP))
 )

 (defun FIXXSWATH (/ TMP)
  (setq TMP (atof (get_tile "XSWATH")))
  (if (<= TMP 0.0) (setq TMP 0.0))
  (set_tile "XSWATH" (rtos TMP))
 )

 (defun FIXXINC (/ TMP)
  (setq TMP (atof (get_tile "XINC")))
  (if (< TMP 0.0) (setq TMP 10.0))
  (set_tile "XINC" (rtos TMP))
 )

 (defun UPDATENE (/ P)
  (setq P (list (atof (get_tile "STATION")) (atof (get_tile "OFFSET"))))
  (setq P (RFL:XY P))
  (if (/= P nil)
   (progn
    (set_tile "NORTHING" (rtos (nth 1 P)))
    (set_tile "EASTING" (rtos (nth 0 P)))
   )
  )
 )

 (defun UPDATESTAOFF (/ P)
  (setq P (list (atof (get_tile "EASTING")) (atof (get_tile "NORTHING"))))
  (setq P (RFL:STAOFF P))
  (if (/= P nil)
   (progn
    (set_tile "STATION" (rtos (nth 0 P)))
    (set_tile "OFFSET" (rtos (nth 1 P)))
   )
   (progn
    (UPDATENE)
   )
  )
 )
 
 (defun NODEPOINT (ALIGNLIST STA INC STA2 / NODE STANODE)
  (setq NODE (car ALIGNLIST))
  (setq ALIGNLIST (cdr ALIGNLIST))
  (while (and NODE
              (> STA (setq STANODE (+ (car NODE) (RFL:DIST (cadr NODE) (caddr NODE) (cadddr NODE)))))
              (< STANODE STA2)
         )
   (setq NODE (car ALIGNLIST))
   (setq ALIGNLIST (cdr ALIGNLIST))
  )
  (if (and (< STANODE STA2)
           (> (+ STA INC) STANODE)
      )
   STANODE
   nil
  )
 )

 (if (or (= RFL:ALIGNLIST nil) (= RFL:XY nil))
  (princ "\n*** No alignment defined or utilities not loaded ***")
  (progn
   (setq PREVENT nil)
   (setq NODE (car RFL:ALIGNLIST))
   (setq STAMIN (car NODE))
   (setq NODE (last RFL:ALIGNLIST))
   (setq STAMAX (+ (car NODE) (RFL:DIST (nth 1 NODE) (nth 2 NODE) (nth 3 node))))

   (if (= XYPDCLNAME nil)
    (progn
     (setq XYPDCLNAME (vl-filename-mktemp "rfl.dcl"))
     (RFL:MAKEDCL XYPDCLNAME "XYP")
    )
    (if (= nil (findfile XYPDCLNAME))
     (progn
      (setq XYPDCLNAME (vl-filename-mktemp "rfl.dcl"))
      (RFL:MAKEDCL XYPDCLNAME "XYP")
     )
    )
   )
   
   (setq DCL_ID (load_dialog XYPDCLNAME))
   (if (not (new_dialog "XYP" DCL_ID)) (exit))

   (if (= nil XYPSTA) (setq XYPSTA STAMIN))
   (if (= nil XYPOS) (setq XYPOS 0.0))

   (if (= nil XYPFROMSTA) (setq XYPFROMSTA STAMIN))
   (if (= nil XYPFROMOS) (setq XYPFROMOS 0.0))
   (if (= nil XYPTOSTA) (setq XYPTOSTA STAMAX))
   (if (= nil XYPTOOS) (setq XYPTOOS 0.0))
   (if (= nil XYPSTEP) (setq XYPSTEP 1))
   (if (= nil XYPXFROMSTA) (setq XYPXFROMSTA STAMIN))
   (if (= nil XYPXTOSTA) (setq XYPXTOSTA STAMAX))
   (if (= nil XYPXROUND) (setq XYPXROUND "1"))
   (if (= nil XYPXSWATH) (setq XYPXSWATH 25.0))
   (if (= nil XYPXINC) (setq XYPXINC 10.0))
   (if (= nil XYPXSPECIAL) (setq XYPXSPECIAL "0"))

   (set_tile "STAMINMAX" (strcat (rtos STAMIN 2 3) " < STA < " (rtos STAMAX 2 3)))
   (set_tile "STATION" (rtos XYPSTA))
   (set_tile "OFFSET" (rtos XYPOS))

   (set_tile "FROMSTATION" (rtos XYPFROMSTA))
   (set_tile "FROMOFFSET" (rtos XYPFROMOS))
   (set_tile "TOSTATION" (rtos XYPTOSTA))
   (set_tile "TOOFFSET" (rtos XYPTOOS))
   (set_tile "STEP" (itoa XYPSTEP))

   (set_tile "XFROMSTATION" (rtos XYPXFROMSTA))
   (set_tile "XTOSTATION" (rtos XYPXTOSTA))
   (set_tile "XROUND" XYPXROUND)
   (set_tile "XSWATH" (rtos XYPXSWATH))
   (set_tile "XINC" (rtos XYPXINC))
   (set_tile "XSPECIAL" XYPXSPECIAL)

   (FIXSTA)
   (FIXOS)
   (FIXFROMSTA)
   (FIXFROMOS)
   (FIXTOSTA)
   (FIXTOOS)
   (FIXSTEP)
   (FIXXFROMSTA)
   (FIXXTOSTA)
   (FIXXSWATH)
   (FIXXINC)

   (action_tile "STATION" "(FIXSTA)")
   (action_tile "OFFSET" "(FIXOS)")
   (action_tile "NORTHING" "(FIXN)")
   (action_tile "EASTING" "(FIXE)")
   (action_tile "FROMSTATION" "(FIXFROMSTA)")
   (action_tile "FROMOFFSET" "(FIXFROMOS)")
   (action_tile "TOSTATION" "(FIXTOSTA)")
   (action_tile "TOOFFSET" "(FIXTOOS)")
   (action_tile "STEP" "(FIXSTEP)")
   (action_tile "XFROMSTATION" "(FIXXFROMSTA)")
   (action_tile "XTOSTATION" "(FIXXTOSTA)")
   (action_tile "XSWATH" "(FIXXSWATH)")
   (action_tile "XINC" "(FIXXINC)")
   (action_tile "OK" "(ACCEPTXYP 0)")
   (action_tile "DRAW" "(ACCEPTXYP -1)")
   (action_tile "XDRAW" "(ACCEPTXYP -2)")
   (action_tile "FROMFILE" "(ACCEPTXYP -3)")
   (action_tile "PICK" "(ACCEPTXYP \"RERUN1\")")
   (action_tile "MPICK" "(ACCEPTXYP \"RERUN2\")")
   (action_tile "XPICK" "(ACCEPTXYP \"RERUN3\")")
   (action_tile "CANCEL" "(CANCELXYP)")

   (start_dialog)

   (if (= CANCEL 0)
    (progn
     (unload_dialog DCL_ID)
     (setq P (RFL:XY (list XYPSTA XYPOS)))
     (if (/= P nil)
      (command "_NON" P)
     )
    )
   )
   (if (= CANCEL -1)
    (progn
     (unload_dialog DCL_ID)
     (RFL:MPOINT2 XYPFROMSTA XYPFROMOS XYPTOSTA XYPTOOS XYPSTEP)
    )
   )
   (if (= CANCEL -2)
    (progn
     (unload_dialog DCL_ID)
     (command)
     (command)
     (setq INC XYPXINC)
     (if (> INC 0.0)
      (progn
       (if (< XYPXFOMSTA XYPXTOSTA)
        (setq STA1 XYPXFROMSTA STA2 XYPXTOSTA)
        (setq STA1 XYPXTOSTA STA2 XYPXFROMSTA)
       )
       (if (= XYPXROUND "1")
        (setq STA (float (* INC (fix (+ 0.99999999 (/ STA1 INC))))))
        (setq STA STA1)
       )
       (while (<= STA STA2)
        (if (and (= XYPXSPECIAL "1")
                 (setq STANODE (NODEPOINT RFL:ALIGNLIST STA INC STA2))
            )
         (progn
          (setq P1 (RFL:XY (list STANODE (* -0.5 XYPXSWATH))))
          (setq P2 (RFL:XY (list STANODE (* 0.5 XYPXSWATH))))
          (if (/= P1 nil)
           (progn
            (entmake)
            (if (= XYPXSWATH 0.0)
             (progn
              (if (/= P1 nil)
               (progn
                (setq P2 (RFL:XY (list STANODE 1.0)))
                (setq ANG (angle P1 P2))
                (entmake (list (cons 0 "XLINE")
                               (cons 100 "AcDbEntity")
                               (cons 100 "AcDbXline")
                               (append (list 10) P1 (list 0.0))
                               (list 11 (cos ANG) (sin ANG) 0.0)
                         )
                )
               )
               (entmake (list (cons 0 "LINE")
                              (append (list 10) P1 (list 0.0))
                              (append (list 11) P2 (list 0.0))
                        )
               )
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             )
            )
           )
          )
         )
        )
        (setq P1 (RFL:XY (list STA (* -0.5 XYPXSWATH))))
        (setq P2 (RFL:XY (list STA (* 0.5 XYPXSWATH))))
        (if (/= P1 nil)
         (progn
          ;(command "._LINE" "_NON" P1 "_NON" P2 "")
          (entmake)
          (if (= XYPXSWATH 0.0)
           (progn
            (setq P2 (RFL:XY (list STA 1.0)))
            (setq ANG (angle P1 P2))
            (entmake (list (cons 0 "XLINE")
                           (cons 100 "AcDbEntity")
                           (cons 100 "AcDbXline")
                           (append (list 10) P1 (list 0.0))
                           (list 11 (cos ANG) (sin ANG) 0.0)
                     )
            )
           )
           (entmake (list (cons 0 "LINE")
                          (append (list 10) P1 (list 0.0))
                          (append (list 11) P2 (list 0.0))
                    )
           )
          )
          (setq ENT (entlast))
          (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         )
        )
        (setq STA (+ STA INC))
       )
      )
     )
     (if (= XYPXSPECIAL "1")
      (progn
       (setq AL RFL:ALIGNLIST)
       (setq NODE (car AL))
       (setq AL (cdr AL))
       (while (/= NODE nil)
        (setq P1 (RFL:XY (list (car NODE) (* -0.5 XYPXSWATH))))
        (setq P2 (RFL:XY (list (car NODE) (* 0.5 XYPXSWATH))))
        (if (/= P1 nil)
         (progn
          (command "._LINE" "_NON" P1 "_NON" P2 "")
         )
        )
        (setq NODE (car AL))
        (setq AL (cdr AL))
       )
       (setq NODE (last RFL:ALIGNLIST))
       (setq P1 (RFL:XY (list (+ (car NODE) (RFL:DIST (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))) (* -0.5 XYPXSWATH))))
       (setq P2 (RFL:XY (list (+ (car NODE) (RFL:DIST (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))) (* 0.5 XYPXSWATH))))
       (if (/= P1 nil)
        (progn
         (command "._LINE" "_NON" P1 "_NON" P2 "")
        )
       )
      )
     )
    )
   )
   (if (= CANCEL -3)
    (progn
     (unload_dialog DCL_ID)
     (setq INFILE (getfiled "Select a Sta,O/S comma delimited file" "" "" 2))
     (if (/= INFILE nil)
      (progn
       (setq INFILE (open INFILE "r"))
       (setq INLINE (read-line INFILE))
       (while (/= INLINE nil)
        (if (= INLINE "")
         (command "")
         (progn
          (setq P (RFL:XY (list (atof (RFL:COLUMN INLINE 1 ","))
                            (atof (RFL:COLUMN INLINE 2 ",")))))
          (if (/= P nil) (command "_NON" P))
         )
        )
        (setq INLINE (read-line INFILE))
       )
       (close INFILE)
      )
     )
    )
   )
   (if (= CANCEL "RERUN1")
    (progn
     (unload_dialog DCL_ID)
     (setq TMP (RFL:STAOFF (getpoint "\n\n\nPoint :")))
     (if (/= TMP nil)
      (progn
       (setq XYPSTA (nth 0 TMP))
       (setq XYPOS (nth 1 TMP))
      )
     )
     (RFL:XYP)
    )
   )
   (if (= CANCEL "RERUN2")
    (progn
     (unload_dialog DCL_ID)
     (setq TMP (RFL:STAOFF (getpoint "\n\n\nFirst point :")))
     (if (/= TMP nil)
      (progn
       (setq XYPFROMSTA (nth 0 TMP))
       (setq XYPFROMOS (nth 1 TMP))
      )
     )
     (setq TMP (RFL:STAOFF (getpoint "\nSecond point :")))
     (if (/= TMP nil)
      (progn
       (setq XYPTOSTA (nth 0 TMP))
       (setq XYPTOOS (nth 1 TMP))
      )
     )
     (if (> XYPFROMSTA XYPTOSTA)
      (progn
       (setq TMP XYPFROMSTA)
       (setq XYPFROMSTA XYPTOSTA)
       (setq XYPTOSTA TMP)
       (setq TMP XYPFROMOS)
       (setq XYPFROMOS XYPTOOS)
       (setq XYPTOOS TMP)
      )
     )
     (RFL:XYP)
    )
   )
   (if (= CANCEL "RERUN3")
    (progn
     (unload_dialog DCL_ID)
     (setq TMP (RFL:STAOFF (getpoint "\n\n\nFirst point :")))
     (if (/= TMP nil) (setq XYPXFROMSTA (car TMP)))
     (setq TMP (RFL:STAOFF (getpoint "\nSecond point :")))
     (if (/= TMP nil) (setq XYPXTOSTA (car TMP)))
     (if (> XYPXFROMSTA XYPXTOSTA)
      (progn
       (setq TMP XYPXFROMSTA)
       (setq XYPXFROMSTA XYPXTOSTA)
       (setq XYPXTOSTA TMP)
      )
     )
     (RFL:XYP)
    )
   )
  )
 )
);
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:DRAWSPIRAL draws a reverse engineered DCA spiral
;
;
(defun RFL:DRAWSPIRAL (PLT PLTST PST LO OS / ANG BULGE C D DIR ENTLIST ENTLISTX H
                                             L LS PT PT2 PT3 R RMAX THETA THETAMAX V X Y)
 (if (= (tblsearch "APPID" "DCA_FIGURE_XENT") nil)
  (regapp "DCA_FIGURE_XENT")
 )
 (setq ANG (angle PLT PLTST))
 (if (> (sin (- (angle PLTST PST) (angle PLT PLTST))) 0.0)
  (setq DIR 1.0)
  (setq DIR -1.0)
 )
 (setq THETAMAX (RFL:GETSPIRALTHETA2 PLT PLTST PST))
 (setq LS (RFL:GETSPIRALLS2 PLT PLTST PST))
 (setq V 10.0)
 (setq ENTLISTX (list -3 (list "DCA_FIGURE_XENT"
                               (cons 1070 200)
                               (cons 1070 400)
                               (cons 1070 600)
                               (list 1011 (car PLT) (cadr PLT) 0.0)
                               (cons 1070 601)
                               (list 1011 (car PLTST) (cadr PLTST) 0.0)
                               (cons 1070 602)
                               (list 1011 (car PST) (cadr PST) 0.0)
                               (cons 1070 300)
                               (cons 1040 LO)
                         )
                )
 )
 (setq ENTLIST (list (cons 0 "LWPOLYLINE")
                     (cons 100 "AcDbEntity")
                     (cons 100 "AcDbPolyline")
                     (cons 90 (fix (+ V 1.0)))
                     (cons 43 0.0)
                     (cons 70 128)
               )
 )
 (setq RMAX (RFL:GETSPIRALR2 PLT PLTST PST))
 (setq C 0.0)
 (while (< C (+ V 1.0))
  (setq L (+ LO (* (/ C V) (- LS LO))))
  (if (= L 0.0)
   (progn
    (setq THETA 0.0)
    (setq R 0.0)
    (setq X 0.0)
    (setq Y 0.0)
   )
   (progn
    (setq THETA (* THETAMAX (expt (/ L LS) 2)))
    (setq R (* RMAX (/ LS L)))
    (setq X (* R (RFL:SPIRALFXR THETA)))
    (setq Y (* DIR R (RFL:SPIRALFYR THETA)))
   )
  )
  (setq X (+ X (* OS DIR (sin THETA))))
  (setq Y (- Y (* OS (cos THETA))))
  (setq PT (list (+ (car PLT) (* X (cos ANG)) (* -1.0 Y (sin ANG)))
                 (+ (cadr PLT) (* X (sin ANG)) (* Y (cos ANG)))
           )
  )
  (setq L (+ LO (* (/ (+ C 0.5) V) (- LS LO))))
  (if (= L 0.0)
   (progn
    (setq THETA 0.0)
    (setq R 0.0)
    (setq X 0.0)
    (setq Y 0.0)
   )
   (progn
    (setq THETA (* THETAMAX (expt (/ L LS) 2)))
    (setq R (* RMAX (/ LS L)))
    (setq X (* R (RFL:SPIRALFXR THETA)))
    (setq Y (* DIR R (RFL:SPIRALFYR THETA)))
   )
  )
  (setq X (+ X (* OS DIR (sin THETA))))
  (setq Y (- Y (* OS (cos THETA))))
  (setq PT2 (list (+ (car PLT) (* X (cos ANG)) (* -1.0 Y (sin ANG)))
                  (+ (cadr PLT) (* X (sin ANG)) (* Y (cos ANG)))
            )
  )
  (setq L (+ LO (* (/ (+ C 1.0) V) (- LS LO))))
  (if (= L 0.0)
   (progn
    (setq THETA 0.0)
    (setq R 0.0)
    (setq X 0.0)
    (setq Y 0.0)
   )
   (progn
    (setq THETA (* THETAMAX (expt (/ L LS) 2)))
    (setq R (* RMAX (/ LS L)))
    (setq X (* R (RFL:SPIRALFXR THETA)))
    (setq Y (* DIR R (RFL:SPIRALFYR THETA)))
   )
  )
  (setq X (+ X (* OS DIR (sin THETA))))
  (setq Y (- Y (* OS (cos THETA))))
  (setq PT3 (list (+ (car PLT) (* X (cos ANG)) (* -1.0 Y (sin ANG)))
                  (+ (cadr PLT) (* X (sin ANG)) (* Y (cos ANG)))
            )
  )
  (setq D (distance PT PT3))
  (setq H (distance PT2 (list (/ (+ (car PT) (car PT3)) 2.0) (/ (+ (cadr PT) (cadr PT3)) 2.0) 0.0)))
  (setq BULGE (* DIR 2.0 (/ H D)))
  (setq ENTLIST (append ENTLIST
                        (list (append (list 10) PT)
                        (cons 42 BULGE)
                        )
                )
  )
  (setq C (+ C 1.0))
 ) 
 (setq ENTLIST (append ENTLIST (list ENTLISTX)))
 (entmake ENTLIST)
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:FITSPIRALAA Fits a reverse engineered DCA spiral between two arcs
;
;    Note:  Not working at this time
;
;
(defun RFL:FITSPIRALAA (ENT1 ENT2 / A ANG ANG1 ANG2 ANG3 B C D1 D2 D3 DIR ENTLIST1 ENTLIST2
                                    K P P1 P2 PC PC1 PC2 PP PLT PLT1 PLT2 PLTST PLTST1 PLTST2 PST PST1 PST2
                                    R THETA THETA1 THETA2)
 (setq ENTLIST1 (entget ENT1))
 (setq ENTLIST2 (entget ENT2))
 (setq P1 (cdr (assoc 10 ENTLIST1)))
 (setq P1 (list (car P1) (cadr P1)))
 (setq P2 (cdr (assoc 11 ENTLIST1)))
 (setq P2 (list (car P2) (cadr P2)))
 (setq PC (cdr (assoc 10 ENTLIST2)))
 (setq PC (list (car PC) (cadr PC)))
 (setq R (cdr (assoc 40 ENTLIST2)))
 (setq ANG1 (cdr (assoc 50 ENTLIST2)))
 (setq PC1 (list (+ (car PC) (* R (cos ANG1)))
                 (+ (cadr PC) (* R (sin ANG1)))))
 (setq ANG2 (cdr (assoc 51 ENTLIST2)))
 (setq PC2 (list (+ (car PC) (* R (cos ANG2)))
                 (+ (cadr PC) (* R (sin ANG2)))))
 (if (> (sin (- (angle P1 PC) (angle P1 P2))) 0.0)
  (setq DIR 1.0)
  (setq DIR -1.0)
 )
 (setq D1 (distance P1 PC))
 (setq D2 (distance P2 PC))
 (setq D3 (distance P1 P2))
 (setq A (/ (+ (- (expt D1 2) (expt D2 2)) (expt D3 2)) (* 2 D3)))
 (setq B (/ (+ (- (expt D2 2) (expt D1 2)) (expt D3 2)) (* 2 D3)))
 (setq C (sqrt (- (expt D1 2) (expt A 2))))
 (if (> A B)
  (setq PP (list (+ (car P1) (* (/ A D3) (- (car P2) (car P1))))
                 (+ (cadr P1) (* (/ A D3) (- (cadr P2) (cadr P1))))
           )
  )
  (setq PP (list (+ (car P2) (* (/ B D3) (- (car P1) (car P2))))
                 (+ (cadr P2) (* (/ B D3) (- (cadr P1) (cadr P2))))
           )
  )
 )
 (if (< C R)
  (eval nil)
  (progn
   (setq P (- C R))
   (setq THETA1 0.0)
   (setq THETA2 pi)
   (setq THETA (/ (+ THETA1 THETA2) 2.0))
   (while (AND (/= THETA THETA1) (/= THETA THETA2))
    (if (< (RFL:SPIRALPR THETA) (/ P R))
     (setq THETA1 THETA)
     (setq THETA2 THETA)
    )
    (setq THETA (/ (+ THETA1 THETA2) 2.0))
   )
   (setq K (* R (RFL:SPIRALKR THETA)))
   (setq PLT1 (list (+ (car PP)
                       (* (/ K (distance PP P1))
                          (- (car P1) (car PP))
                       )
                    )
                    (+ (cadr PP)
                       (* (/ K (distance PP P1))
                          (- (cadr P1) (cadr PP))
                       )
                    )
              )
   )
   (setq PLTST1 (list (+ (car PLT1)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (cos (angle P1 P2)))
                      )
                      (+ (cadr PLT1)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (sin (angle P1 P2)))
                      )
                )
   )
   (setq PST1 (list (+ (car PLT1)
                       (* R (RFL:SPIRALFXR THETA) (cos (angle P1 P2)))
                       (* -1.0 DIR R (RFL:SPIRALFYR THETA) (sin (angle P1 P2)))
                    )
                    (+ (cadr PLT1)
                       (* R (RFL:SPIRALFXR THETA) (sin (angle P1 P2)))
                       (* DIR R (RFL:SPIRALFYR THETA) (cos (angle P1 P2)))
                    )
              )
   )
   (setq PLT2 (list (+ (car PP)
                       (* (/ K (distance PP P2))
                          (- (car P2) (car PP))
                       )
                    )
                    (+ (cadr PP)
                       (* (/ K (distance PP P2))
                          (- (cadr P2) (cadr PP))
                       )
                    )
              )
   )
   (setq PLTST2 (list (+ (car PLT2)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (cos (angle P2 P1)))
                      )
                      (+ (cadr PLT2)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (sin (angle P2 P1)))
                      )
                )
   )
   (setq PST2 (list (+ (car PLT2)
                       (* R (RFL:SPIRALFXR THETA) (cos (angle P2 P1)))
                       (* DIR R (RFL:SPIRALFYR THETA) (sin (angle P2 P1)))
                    )
                    (+ (cadr PLT2)
                       (* R (RFL:SPIRALFXR THETA) (sin (angle P2 P1)))
                       (* -1.0 DIR R (RFL:SPIRALFYR THETA) (cos (angle P2 P1)))
                    )
              )
   )
   (if (= DIR 1.0)
    (progn
     (if (< (RFL:ANGLE3P PST1 PC PC1) (RFL:ANGLE3P PST1 PC PC2))
      (progn
       (RFL:DRAWSPIRAL PLT1 PLTST1 PST1 0.0 0.0)
       (setq ENTLIST1 (subst (list 11 (car PLT1) (cadr PLT1))
                             (assoc 11 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 50 (angle PC PST1))
                             (assoc 50 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
      (progn
       (RFL:DRAWSPIRAL PLT2 PLTST2 PST2 0.0 0.0)
       (setq ENTLIST1 (subst (list 10 (car PLT2) (cadr PLT2))
                             (assoc 10 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 51 (angle PC PST2))
                             (assoc 51 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
     )
    )
    (progn
     (if (> (RFL:ANGLE3P PST1 PC PC1) (RFL:ANGLE3P PST1 PC PC2))
      (progn
       (RFL:DRAWSPIRAL PLT1 PLTST1 PST1 0.0 0.0)
       (setq ENTLIST1 (subst (list 11 (car PLT1) (cadr PLT1))
                             (assoc 11 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 51 (angle PC PST1))
                             (assoc 51 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
      (progn
       (RFL:DRAWSPIRAL PLT2 PLTST2 PST2 0.0 0.0)
       (setq ENTLIST1 (subst (list 10 (car PLT2) (cadr PLT2))
                             (assoc 10 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 50 (angle PC PST2))
                             (assoc 50 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
     )
    )
   )
  )
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:FITSPIRALLA Fits a reverse engineered DCA spiral between a line and an arc
;
;
(defun RFL:FITSPIRALLA (ENT1 ENT2 / A ANG ANG1 ANG2 ANG3 B C D1 D2 D3 DIR ENTLIST1 ENTLIST2
                                    K P P1 P2 PC PC1 PC2 PP PLT PLT1 PLT2 PLTST PLTST1 PLTST2 PST PST1 PST2
                                    R THETA THETA1 THETA2)
 (setq ENTLIST1 (entget ENT1))
 (setq ENTLIST2 (entget ENT2))
 (setq P1 (cdr (assoc 10 ENTLIST1)))
 (setq P1 (list (car P1) (cadr P1)))
 (setq P2 (cdr (assoc 11 ENTLIST1)))
 (setq P2 (list (car P2) (cadr P2)))
 (setq PC (cdr (assoc 10 ENTLIST2)))
 (setq PC (list (car PC) (cadr PC)))
 (setq R (cdr (assoc 40 ENTLIST2)))
 (setq ANG1 (cdr (assoc 50 ENTLIST2)))
 (setq PC1 (list (+ (car PC) (* R (cos ANG1)))
                 (+ (cadr PC) (* R (sin ANG1)))))
 (setq ANG2 (cdr (assoc 51 ENTLIST2)))
 (setq PC2 (list (+ (car PC) (* R (cos ANG2)))
                 (+ (cadr PC) (* R (sin ANG2)))))
 (if (> (sin (- (angle P1 PC) (angle P1 P2))) 0.0)
  (setq DIR 1.0)
  (setq DIR -1.0)
 )
 (setq D1 (distance P1 PC))
 (setq D2 (distance P2 PC))
 (setq D3 (distance P1 P2))
 (setq A (/ (+ (- (expt D1 2) (expt D2 2)) (expt D3 2)) (* 2 D3)))
 (setq B (/ (+ (- (expt D2 2) (expt D1 2)) (expt D3 2)) (* 2 D3)))
 (setq C (sqrt (- (expt D1 2) (expt A 2))))
 (if (> A B)
  (setq PP (list (+ (car P1) (* (/ A D3) (- (car P2) (car P1))))
                 (+ (cadr P1) (* (/ A D3) (- (cadr P2) (cadr P1))))
           )
  )
  (setq PP (list (+ (car P2) (* (/ B D3) (- (car P1) (car P2))))
                 (+ (cadr P2) (* (/ B D3) (- (cadr P1) (cadr P2))))
           )
  )
 )
 (if (< (distance PP P1) RFL:TOLFINE)
  (setq P1 (list (+ (car P2) (* 0.9 (- (car P1) (car P2))))
                 (+ (cadr P2) (* 0.9 (- (cadr P1) (cadr P2))))))
 )
 (if (< (distance PP P2) RFL:TOLFINE)
  (setq P2 (list (+ (car P1) (* 0.9 (- (car P2) (car P1))))
                 (+ (cadr P1) (* 0.9 (- (cadr P2) (cadr P1))))))
 )
 (if (< C R)
  (eval nil)
  (progn
   (setq P (- C R))
   (setq THETA1 0.0)
   (setq THETA2 pi)
   (setq THETA (/ (+ THETA1 THETA2) 2.0))
   (while (> (abs (- THETA2 THETA1)) RFL:TOLFINE)
    (if (< (RFL:SPIRALPR THETA) (/ P R))
     (setq THETA1 THETA)
     (setq THETA2 THETA)
    )
    (setq THETA (/ (+ THETA1 THETA2) 2.0))
   )
   (setq K (* R (RFL:SPIRALKR THETA)))
   (setq PLT1 (list (+ (car PP)
                       (* (/ K (distance PP P1))
                          (- (car P1) (car PP))
                       )
                    )
                    (+ (cadr PP)
                       (* (/ K (distance PP P1))
                          (- (cadr P1) (cadr PP))
                       )
                    )
              )
   )
   (setq PLTST1 (list (+ (car PLT1)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (cos (angle P1 P2)))
                      )
                      (+ (cadr PLT1)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (sin (angle P1 P2)))
                      )
                )
   )
   (setq PST1 (list (+ (car PLT1)
                       (* R (RFL:SPIRALFXR THETA) (cos (angle P1 P2)))
                       (* -1.0 DIR R (RFL:SPIRALFYR THETA) (sin (angle P1 P2)))
                    )
                    (+ (cadr PLT1)
                       (* R (RFL:SPIRALFXR THETA) (sin (angle P1 P2)))
                       (* DIR R (RFL:SPIRALFYR THETA) (cos (angle P1 P2)))
                    )
              )
   )
   (setq PLT2 (list (+ (car PP)
                       (* (/ K (distance PP P2))
                          (- (car P2) (car PP))
                       )
                    )
                    (+ (cadr PP)
                       (* (/ K (distance PP P2))
                          (- (cadr P2) (cadr PP))
                       )
                    )
              )
   )
   (setq PLTST2 (list (+ (car PLT2)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (cos (angle P2 P1)))
                      )
                      (+ (cadr PLT2)
                         (* R (- (RFL:SPIRALFXR THETA) (/ (RFL:SPIRALFYR THETA) (RFL:TAN THETA))) (sin (angle P2 P1)))
                      )
                )
   )
   (setq PST2 (list (+ (car PLT2)
                       (* R (RFL:SPIRALFXR THETA) (cos (angle P2 P1)))
                       (* DIR R (RFL:SPIRALFYR THETA) (sin (angle P2 P1)))
                    )
                    (+ (cadr PLT2)
                       (* R (RFL:SPIRALFXR THETA) (sin (angle P2 P1)))
                       (* -1.0 DIR R (RFL:SPIRALFYR THETA) (cos (angle P2 P1)))
                    )
              )
   )
   (if (= DIR 1.0)
    (progn
     (if (< (RFL:ANGLE3P PST1 PC PC1) (RFL:ANGLE3P PST1 PC PC2))
      (progn
       (RFL:DRAWSPIRAL PLT1 PLTST1 PST1 0.0 0.0)
       (setq ENTLIST1 (subst (list 11 (car PLT1) (cadr PLT1))
                             (assoc 11 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 50 (angle PC PST1))
                             (assoc 50 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
      (progn
       (RFL:DRAWSPIRAL PLT2 PLTST2 PST2 0.0 0.0)
       (setq ENTLIST1 (subst (list 10 (car PLT2) (cadr PLT2))
                             (assoc 10 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 51 (angle PC PST2))
                             (assoc 51 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
     )
    )
    (progn
     (if (> (RFL:ANGLE3P PST1 PC PC1) (RFL:ANGLE3P PST1 PC PC2))
      (progn
       (RFL:DRAWSPIRAL PLT1 PLTST1 PST1 0.0 0.0)
       (setq ENTLIST1 (subst (list 11 (car PLT1) (cadr PLT1))
                             (assoc 11 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 51 (angle PC PST1))
                             (assoc 51 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
      (progn
       (RFL:DRAWSPIRAL PLT2 PLTST2 PST2 0.0 0.0)
       (setq ENTLIST1 (subst (list 10 (car PLT2) (cadr PLT2))
                             (assoc 10 ENTLIST1)
                             ENTLIST1))
       (entmod ENTLIST1)
       (entupd ENT1)
       (setq ENTLIST2 (subst (cons 50 (angle PC PST2))
                             (assoc 50 ENTLIST2)
                             ENTLIST2))
       (entmod ENTLIST2)
       (entupd ENT2)
      )
     )
    )
   )
  )
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:FITSPIRALLL Fits a reverse engineered DCA spiral between two lines
;
;
(defun RFL:FITSPIRALLL (ENT1 ENT2 LS1 R LS2 / ANG ANG1 ANG2 DELTA DIR ENTLIST1 ENTLIST2
                                              P P1 P2 P3 P4 PLT1 PLT2 PLTST1 PLTST2 PST1 PST2
                                              R T1 T2 THETA1 THETA2 VAL1 VAL2)
 (setq ENTLIST1 (entget ENT1))
 (setq ENTLIST2 (entget ENT2))
 (setq P1 (cdr (assoc 10 ENTLIST1)))
 (setq P1 (list (car P1) (cadr P1)))
 (setq P2 (cdr (assoc 11 ENTLIST1)))
 (setq P2 (list (car P2) (cadr P2)))
 (setq P3 (cdr (assoc 10 ENTLIST2)))
 (setq P3 (list (car P3) (cadr P3)))
 (setq P4 (cdr (assoc 11 ENTLIST2)))
 (setq P4 (list (car P4) (cadr P4)))
 (setq P (inters P1 P2 P3 P4 nil))
 (setq ANG (RFL:ANGLE3P (if (> (distance P1 P) (distance P2 P)) P1 P2)
                        P
                        (if (> (distance P3 P) (distance P4 P)) P3 P4)
           )
 )
 (if (> (distance P1 P) (distance P2 P))
  (setq ANG1 (angle P P1))
  (setq ANG1 (angle P P2))
 )
 (if (> (distance P3 P) (distance P4 P))
  (setq ANG2 (angle P P3))
  (setq ANG2 (angle P P4))
 )
 (if (> (sin (- ANG2 (+ ANG1 pi))) 0.0)
  (setq DIR 1.0)
  (setq DIR -1.0)
 )
 (if (= R 0.0)
  (progn
   (setq DELTA 0.0)
   (setq THETA1 (/ (- pi ANG) (+ 1.0 (/ LS2 LS1))))
   (setq THETA2 (/ (- pi ANG) (+ 1.0 (/ LS1 LS2))))
   (setq R (/ LS1 (* 2.0 THETA1)))
  )
  (progn
   (setq THETA1 (/ LS1 (* 2.0 R)))
   (setq THETA2 (/ LS2 (* 2.0 R)))
   (setq DELTA (- (- pi ANG) (+ THETA1 THETA2)))
  )
 )
 (if (>= DELTA 0.0)
  (progn
   (setq VAL1 (* R (- (+ (* (RFL:SPIRALFYR THETA1) (sin ANG))
                            (cos (+ DELTA THETA2 (/ pi -2.0)))
                         )
                      (sin THETA2)
                   )
              )
   )
   (setq VAL2 (* R (- (+ (* (RFL:SPIRALFYR THETA2) (sin ANG))
                            (cos (+ DELTA THETA1 (/ pi -2.0)))
                         )
                      (sin THETA1)
                   )
              )
   )
   (setq T1 (/ (+ (* VAL1 (cos ANG))
                  VAL2
               )
               (expt (sin ANG) 2)
            )
   )
   (setq T2 (/ (+ (* VAL2 (cos ANG))
                  VAL1
               )
               (expt (sin ANG) 2)
            )
   )
   (setq PLT1 (list (+ (car P)
                       (* (+ T1
                             (* R (RFL:SPIRALFXR THETA1))
                          )
                          (cos ANG1)
                       )
                    )
                    (+ (cadr P)
                       (* (+ T1
                             (* R (RFL:SPIRALFXR THETA1))
                          )
                          (sin ANG1)
                       )
                    )
              )
   )
   (setq PLTST1 (list (+ (car P)
                         (* (+ T1
                               (if (> THETA1 0.0 )
                                (* R (/ (RFL:SPIRALFYR THETA1) (RFL:TAN THETA1)))
                                0.0
                               )
                            )
                            (cos ANG1)
                         )
                      )
                      (+ (cadr P)
                         (* (+ T1
                               (if (> THETA1 0.0 )
                                (* R (/ (RFL:SPIRALFYR THETA1) (RFL:TAN THETA1)))
                                0.0
                               )
                            )
                            (sin ANG1)
                         )
                      )
                )
   )
   (setq PST1 (list (+ (car P)
                       (* T1
                          (cos ANG1)
                       )
                       (* 1.0
                          DIR
                          (* R (RFL:SPIRALFYR THETA1))
                          (sin ANG1)
                       )
                    )
                    (+ (cadr P)
                       (* T1
                          (sin ANG1)
                       )
                       (* -1.0
                          DIR
                          (* R (RFL:SPIRALFYR THETA1))
                          (cos ANG1)
                       )
                    )
              )
   )
   (if (> THETA1 0.0)
    (RFL:DRAWSPIRAL PLT1 PLTST1 PST1 0.0 0.0)
   )
   (if (> (distance P1 P) (distance P2 P))
    (setq ENTLIST1 (subst (list 11 (car PLT1) (cadr PLT1)) (assoc 11 ENTLIST1) ENTLIST1))
    (setq ENTLIST1 (subst (list 10 (car PLT1) (cadr PLT1)) (assoc 10 ENTLIST1) ENTLIST1))
   )
   (entmod ENTLIST1)
   (entupd ENT1)
   (setq PLT2 (list (+ (car P)
                       (* (+ T2
                             (* R (RFL:SPIRALFXR THETA2))
                          )
                          (cos ANG2)
                       )
                    )
                    (+ (cadr P)
                       (* (+ T2
                             (* R (RFL:SPIRALFXR THETA2))
                          )
                          (sin ANG2)
                       )
                    )
              )
   )
   (setq PLTST2 (list (+ (car P)
                         (* (+ T2
                               (if (> THETA2 0.0)
                                (* R (/ (RFL:SPIRALFYR THETA2) (RFL:TAN THETA2)))
                                0.0
                               )
                            )
                            (cos ANG2)
                         )
                      )
                      (+ (cadr P)
                         (* (+ T2
                               (if (> THETA2 0.0)
                                (* R (/ (RFL:SPIRALFYR THETA2) (RFL:TAN THETA2)))
                                0.0
                               )
                            )
                            (sin ANG2)
                         )
                      )
                )
   )
   (setq PST2 (list (+ (car P)
                       (* T2
                          (cos ANG2)
                       )
                       (* -1.0
                          DIR
                          (* R (RFL:SPIRALFYR THETA2))
                          (sin ANG2)
                       )
                    )
                    (+ (cadr P)
                       (* T2
                          (sin ANG2)
                       )
                       (* 1.0
                          DIR
                          (* R (RFL:SPIRALFYR THETA2))
                          (cos ANG2)
                       )
                    )
              )
   )
   (if (> THETA2 0.0)
    (RFL:DRAWSPIRAL PLT2 PLTST2 PST2 0.0 0.0)
   )
   (if (> (distance P3 P) (distance P4 P))
    (setq ENTLIST2 (subst (list 11 (car PLT2) (cadr PLT2)) (assoc 11 ENTLIST2) ENTLIST2))
    (setq ENTLIST2 (subst (list 10 (car PLT2) (cadr PLT2)) (assoc 10 ENTLIST2) ENTLIST2))
   )
   (entmod ENTLIST2)
   (entupd ENT2)
   (if (> DELTA 0.0)
    (if (= DIR 1.0)
     (command "._ARC" PST1 "E" PST2 "R" R)
     (command "._ARC" PST2 "E" PST1 "R" R)
    )
   )
  )
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALA returns the spiral 'A' for an entity
;
;
(defun RFL:GETSPIRALA (ENT / R LS)
 (setq R (RFL:GETSPIRALR ENT))
 (setq LS (RFL:GETSPIRALLS ENT))
 (if (= LS nil)
  nil
  (sqrt (* LS R))
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALA2 returns the spiral 'A' for given long pi and short tangent points
;
;
(defun RFL:GETSPIRALA2 (PLT PLTST PST / R LS)
 (setq R (RFL:GETSPIRALR2 PLT PLTST PST))
 (setq LS (RFL:GETSPIRALLS2 PLT PLTST PST))
 (if (= LS nil)
  nil
  (sqrt (* LS R))
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALDATA returns the extended spiral data for an entity (reverse engineered DCA spiral)
;
;
(defun RFL:GETSPIRALDATA (ENT / ENTLIST ENTLIST2 PLT PLTST PST LS SPIRALLIST TMP)
 (setq ENTLIST2 (cdr (assoc -3 (entget ENT '("*")))))
 (setq ENTLIST (cdr (assoc "DCA_FIGURE_XENT" ENTLIST2)))
 (if (or (= ENTLIST nil) (= (assoc 1011 ENTLIST) nil))
  (progn
   (setq SPIRALLIST nil)
  )
  (progn
   (while (/= (car (car ENTLIST)) 1011)
    (setq ENTLIST (cdr ENTLIST))
   )
   (setq PLT (cdr (car ENTLIST)))
   (setq PLT (list (car PLT) (cadr PLT)))
   (setq ENTLIST (cdr ENTLIST))
   (while (/= (car (car ENTLIST)) 1011)
    (setq ENTLIST (cdr ENTLIST))
   )
   (setq PLTST (cdr (car ENTLIST)))
   (setq PLTST (list (car PLTST) (cadr PLTST)))
   (setq ENTLIST (cdr ENTLIST))
   (while (/= (car (car ENTLIST)) 1011)
    (setq ENTLIST (cdr ENTLIST))
   )
   (setq PST (cdr (car ENTLIST)))
   (setq PST (list (car PST) (cadr PST)))
   (while (/= (car (car ENTLIST)) 1040)
    (setq ENTLIST (cdr ENTLIST))
   )
   (setq LS (cdr (car ENTLIST)))
   (setq ENTLIST (cdr ENTLIST))
   (if (< (distance PLT PLTST) (distance PST PLTST))
    (progn
     (setq TMP PST)
     (setq PST PLT)
     (setq PLT TMP)
    )
   )
   (setq SPIRALLIST (list PLT PLTST PST LS))
  )
 )
 SPIRALLIST
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALLS returns the spiral length for an entity
;
;
(defun RFL:GETSPIRALLS (ENT / THETA R)
 (setq THETA (RFL:GETSPIRALTHETA ENT))
 (setq R (RFL:GETSPIRALR ENT))
 (if (= THETA nil)
  nil
  (* 2.0 THETA R)
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALLS2 returns the spiral length for given long pi and short tangent points
;
;
(defun RFL:GETSPIRALLS2 (PLT PLTST PST / THETA R)
 (setq THETA (RFL:GETSPIRALTHETA2 PLT PLTST PST))
 (setq R (RFL:GETSPIRALR2 PLT PLTST PST))
 (if (= THETA nil)
  nil
  (* 2.0 THETA R)
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALPI2 returns the spiral PI for given length long pi and short tangent points
;
;
(defun RFL:GETSPIRALPI2 (L PLT PLTST PST / A P P1 P2 THETA)
 (if (< L RFL:TOLFINE)
  (setq P PLTST)
  (progn
   (setq P1 (RFL:SPIRALXY2 (list L 0.0) PLT PLTST PST))
   (setq A (RFL:GETSPIRALA2 PLT PLTST PST))
   (setq THETA (/ (* L L) (* A A) 2.0))
   (if (> (sin (- (angle PLTST PST) (angle PLT PLTST))) 0.0)
    (setq THETA (+ (angle PLT PLTST) THETA))
    (setq THETA (- (angle PLT PLTST) THETA))
   )
   (setq P2 (list (+ (car P1) (cos THETA)) (+ (cadr P1) (sin THETA))))
   (setq P (inters P1 P2 PLTST PST nil))
  )
 )
 P
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALR returns the spiral radius for an entity
;
;
(defun RFL:GETSPIRALR (ENT / PLTST PST R SPIRALLIST)
 (setq SPIRALLIST (RFL:GETSPIRALDATA ENT))
 (if (= SPIRALLIST nil)
  (progn
   (setq R nil)
  )
  (progn
   (setq PLTST (cadr SPIRALLIST))
   (setq PST (caddr SPIRALLIST))
   (setq THETA (RFL:GETSPIRALTHETA ENT))
   (setq R (/ (* (distance PLTST PST) (sin THETA)) (RFL:SPIRALFYR THETA)))
  )
 )
 R
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALR2 returns the spiral radius for given long pi and short tangent points
;
;
(defun RFL:GETSPIRALR2 (PLT PLTST PST / R)
 (setq THETA (RFL:GETSPIRALTHETA2 PLT PLTST PST))
 (setq R (/ (* (distance PLTST PST) (sin THETA)) (RFL:SPIRALFYR THETA)))
 R
);
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALRADIUS returns the radius of the spiral data
;
;
(defun RFL:GETSPIRALRADIUS (L PLT PLTST PST / DIR LS R RMAX THETAMAX)
 (if (> (sin (- (angle PLTST PST) (angle PLT PLTST))) 0.0)
  (setq DIR 1.0)
  (setq DIR -1.0)
 )
 (setq R 0.0)
 (setq LS (RFL:GETSPIRALLS2 PLT PLTST PST))
 (setq RMAX (RFL:GETSPIRALR2 PLT PLTST PST))
 (if (< L RFL:TOLFINE)
  (progn
   (setq PS PLT)
   (setq THETA 0.0)
  )
  (progn
   (if (< L RFL:TOLFINE)
    (progn
     (setq R 0.0)
    )
    (progn
     (setq R (* RMAX (/ LS L)))
    )
   )
  )
 )
 (* DIR R)
);
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALTHETA returns the spiral deflection for an entity
;
;
(defun RFL:GETSPIRALTHETA (ENT / ENTLIST ENTLIST2 LS PLT PLTST PST SPIRALLIST THETA)
 (setq SPIRALLIST (RFL:GETSPIRALDATA ENT))
 (if (= SPIRALLIST nil)
  (progn
   (setq THETA nil)
  )
  (progn
   (setq PLT (car SPIRALLIST))
   (setq PLTST (cadr SPIRALLIST))
   (setq PST (caddr SPIRALLIST))
   (setq THETA (abs (- (angle PST PLTST) (angle PLTST PLT))))
   (if (< THETA 0.0)
    (progn
     (setq THETA (+ THETA (* 2.0 pi)))
    )
   )
   (if (> THETA pi)
    (progn
     (setq THETA (- (* 2.0 pi) THETA))
    )
   )
  )
 )
 THETA
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:GETSPIRALTHETA2 returns the spiral deflection for given long pi and short tangent points
;
;
(defun RFL:GETSPIRALTHETA2 (PLT PLTST PST / ENTLIST ENTLIST2 LS THETA)
 (setq THETA (abs (- (angle PST PLTST) (angle PLTST PLT))))
 (if (< THETA 0.0)
  (progn
   (setq THETA (+ THETA (* 2.0 pi)))
  )
 )
 (if (> THETA pi)
  (progn
   (setq THETA (- (* 2.0 pi) THETA))
  )
 )
 THETA
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALFXR returns (R *  Spiral 'X') for a given deflection
;
;
(if RFL:SPIRALFXR (princ "\nRFL:SPIRALFXR already loaded...")
(defun RFL:SPIRALFXR (THETA / AR2 DENOMINATOR N NUMERATOR SUM SUM2)
 (setq SUM -1.0)
 (setq SUM2 0.0)
 (setq AR2 (* 2.0 THETA))
 (setq N 1.0)
 (while (/= SUM SUM2)
  (setq SUM SUM2)
  (if (> THETA RFL:TOLFINE)
   (setq NUMERATOR (* (expt -1.0 (+ N 1.0)) (expt AR2 (* 2.0 (- N 1.0)))))
   (setq NUMERATOR 0.0)
  )
  (setq DENOMINATOR (* (expt 2.0 (* 2.0 (- N 1.0))) (- (* 4.0 N) 3.0) (RFL:FACT (* 2.0 (- N 1.0)))))
  (setq SUM2 (+ SUM2 (/ NUMERATOR DENOMINATOR)))
  (setq N (+ N 1))
 )
 (setq SUM (* SUM AR2))
 SUM
)
)

;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALFYR returns (R *  Spiral 'Y') for a given deflection
;
;
(if RFL:SPIRALFYR (princ "\nRFL:SPIRALFYR already loaded...")
(defun RFL:SPIRALFYR (THETA / AR2 DENOMINATOR N NUMERATOR SUM SUM2)
 (setq SUM -1.0)
 (setq SUM2 0.0)
 (setq AR2 (* 2.0 THETA))
 (setq N 1.0)
 (while (/= SUM SUM2)
  (setq SUM SUM2)
  (setq NUMERATOR (* (expt -1.0 (+ N 1.0)) (expt AR2 (- (* 2.0 N) 1.0))))
  (setq DENOMINATOR (* (expt 2.0 (- (* 2.0 N) 1.0)) (- (* 4.0 N) 1.0) (RFL:FACT (- (* 2.0 N) 1.0))))
  (setq SUM2 (+ SUM2 (/ NUMERATOR DENOMINATOR)))
  (setq N (+ N 1))
 )
 (setq SUM (* SUM AR2))
 SUM
)
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALK returns the spiral 'K' value for a given radius and length
;
;
(if RFL:SPIRALK (princ "\nRFL:SPIRALK already loaded...")
(defun RFL:SPIRALK (R LS / THETA)
 (setq THETA (/ LS R 2.0))
 (* R (- (SPIRALFXR THETA) (sin THETA)))
)
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALKR returns the spiral 'K' value for a given deflection
;
;
(if RFL:SPIRALKR (princ "\nRFL:SPIRALKR already loaded...")
(defun RFL:SPIRALKR (THETA)
 (- (RFL:SPIRALFXR THETA) (sin THETA))
)
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALOFFSET returns the offset of an offset spiral
;
;
(defun RFL:SPIRALOFFSET (ENT / ENT2 ENTLIST OS P P1 P2 PLT PLTST PST SDATA)
 (if (= (setq SDATA (RFL:GETSPIRALDATA ENT)) nil)
  nil
  (progn
   (setq ENTLIST (entget ENT))
   (if (= (cdr (assoc 0 ENTLIST)) "POLYLINE")
    (progn
     (setq ENT2 (entnext ENT))
     (setq ENTLIST (entget ENT2))
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
      (setq P2 (cdr (assoc 10 ENTLIST)))
      (setq ENT2 (entnext ENT2))
      (setq ENTLIST (entget ENT2))
     )
    )
    (progn
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq P2 (cdr (assoc 10 (reverse ENTLIST))))
    )
   )
   (setq PLT (car SDATA))
   (setq PLTST (cadr SDATA))
   (setq PST (caddr SDATA))
   (if (< (distance PST P1) (distance PST P2))
    (setq P P1)
    (setq P P2)
   )
   (setq OS (distance PST P))

   (setq OS (* OS
               -1.0
               (RFL:SIGN (sin (- (angle PLTST PST) (angle PLT PLTST))))
               (RFL:SIGN (- (sin (- (angle PLTST P) (angle PLT PLTST)))
                            (sin (- (angle PLTST PST) (angle PLT PLTST)))
                         )
               )
            )
   )
  )
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALOFFSET2 returns the offset of an offset spiral based on supplied spiral data
;
;
(defun SPIRALOFFSET2 (P1 P2 PLT PLTST PST LO / OS P)
 (if (< (distance PST P1) (distance PST P2))
  (setq P P1)
  (setq P P2)
 )
 (setq OS (distance PST P))
 (setq OS (* OS
             -1.0
             (RFL:SIGN (sin (- (angle PLTST PST) (angle PLT PLTST))))
             (RFL:SIGN (- (sin (- (angle PLTST P) (angle PLT PLTST)))
                          (sin (- (angle PLTST PST) (angle PLT PLTST)))
                       )
             )
          )
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALP returns the spiral 'P' offset for a given length and radius
;
;
(if RFL:SPIRALP (princ "\nRFL:SPIRALP already loaded...")
(defun RFL:SPIRALP (R LS / THETA)
 (setq THETA (/ LS R 2.0))
 (* R (- (RFL:SPIRALFYR THETA) (- 1.0 (cos THETA))))
)
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALPR returns (R * spiral 'P') for a given deflection
;
;
(if RFL:SPIRALPR (princ "\nRFL:SPIRALPR already loaded...")
(defun RFL:SPIRALPR (THETA)
 (- (RFL:SPIRALFYR THETA) (- 1.0 (cos THETA)))
)
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALPOINTON Checks is the entered point is within the spiral limits
;
;
(defun RFL:SPIRALPOINTON (P PLT PLTST PST LO / A2 ALPHA F1 F2 FCTN GETR PX PY
                                               RMAX SPIRALDIRECTION
                                               THETA1 THETA2 THETAMAX)
 (defun GETR (VAL)
  (if (< (abs VAL) RFL:TOLFINE)
   (eval 0.0)
   (sqrt (/ A2 VAL 2.0))
  )
 )
 (defun FCTN (VAL)
  (if (< (abs VAL) RFL:TOLFINE)
   PX
   (+ (* (- PX (* (GETR VAL) (RFL:SPIRALFXR VAL))) (cos VAL))
         (* SPIRALDIRECTION (- PY (* SPIRALDIRECTION (GETR VAL) (RFL:SPIRALFYR VAL))) (sin VAL))
   )
  )
 )
 (if (> (sin (- (angle PLTST PST) (angle PLT PLTST))) 0.0)
  (setq SPIRALDIRECTION 1.0)
  (setq SPIRALDIRECTION -1.0)
 )
 (setq ALPHA (angle PLT PLTST))
 (setq PX (+ (* (- (cadr P) (cadr PLT)) (sin ALPHA)) (* (- (car P) (car PLT)) (cos ALPHA))))
 (setq PY (- (* (- (cadr P) (cadr PLT)) (cos ALPHA)) (* (- (car P) (car PLT)) (sin ALPHA))))
 (setq THETAMAX (RFL:GETSPIRALTHETA2 PLT PLTST PST))
 (setq RMAX (RFL:GETSPIRALR2 PLT PLTST PST))
 (setq A2 (* 2.0 RMAX RMAX THETAMAX))
 (setq THETA1 (/ (* LO LO) A2 2.0))
 (setq THETA2 THETAMAX)
 (setq F1 (FCTN THETA1))
 (setq F2 (FCTN THETA2))
 (if (> (* F1 F2) RFL:TOLFINE)
  0
  1
 )
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALSTAOFF returns the station and offset of a point for a given entity
;
;
(defun RFL:SPIRALSTAOFF (P ENT / LO PLT PLTST PST SPIRALLIST STAOFFVAL)
 (setq SPIRALLIST (RFL:GETSPIRALDATA ENT))
 (if (= SPIRALLIST nil)
  (setq STAOFFVAL nil)
  (setq PLT (car SPIRALLIST)
        PLTST (cadr SPIRALLIST)
        PST (caddr SPIRALLIST)
        LO (cadddr SPIRALLIST)
        STAOFFVAL (RFL:SPIRALSTAOFF2 P PLT PLTST PST LO)
  )
 )
 STAOFFVAL
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALSTAOFF2 returns the station and offset of a point for given data
;
;
(defun RFL:SPIRALSTAOFF2 (P PLT PLTST PST LO / A2 ALPHA F F1 F2 FCTN LS GETR OFFSET OFFSETDIRECTION P0 P1 PX PY
                                               R R1 R2 RMAX SPIRALDIRECTION SPIRALLIST STAOFFVAL STATION
                                               THETA THETA1 THETA2 THETAMAX THETAOLD TMP)
 (setq P (list (car P) (cadr P)))
 (defun GETR (VAL)
  (if (< (abs VAL) RFL:TOLFINE)
   (eval 0.0)
   (sqrt (/ A2 VAL 2.0))
  )
 )
 (defun FCTN (VAL)
  (if (< (abs VAL) RFL:TOLFINE)
   (progn
    (setq TMP PX)
   )
   (progn
    (setq TMP (+ (* (- PX (* (GETR VAL) (RFL:SPIRALFXR VAL))) (cos VAL))
                 (* SPIRALDIRECTION (- PY (* SPIRALDIRECTION (GETR VAL) (RFL:SPIRALFYR VAL))) (sin VAL))))
   )
  )
  (eval TMP)
 )
 (if (> (sin (- (angle PLTST PST) (angle PLT PLTST))) 0.0)
  (setq SPIRALDIRECTION 1.0)
  (setq SPIRALDIRECTION -1.0)
 )
 (setq ALPHA (angle PLT PLTST))
 (setq PX (+ (* (- (cadr P) (cadr PLT)) (sin ALPHA)) (* (- (car P) (car PLT)) (cos ALPHA))))
 (setq PY (- (* (- (cadr P) (cadr PLT)) (cos ALPHA)) (* (- (car P) (car PLT)) (sin ALPHA))))
 (setq THETAMAX (RFL:GETSPIRALTHETA2 PLT PLTST PST))
 (setq RMAX (RFL:GETSPIRALR2 PLT PLTST PST))
 (setq A2 (* 2.0 RMAX RMAX THETAMAX))
 (if (< (distance P PST) RFL:TOLFINE)
  (progn
   (setq THETA THETAMAX)
  )
  (progn
   (if (< (distance P PLT) RFL:TOLFINE)
    (progn
     (setq THETA 0.0)
    )
    (progn
     (setq THETA1 (/ (* LO LO) A2 2.0))
     (setq THETA2 THETAMAX)
     (setq THETA (/ (+ THETA1 THETA2) 2.0))
     (setq THETAOLD -1.0)
     (setq F1 (FCTN THETA1))
     (setq F2 (FCTN THETA2))
     (setq F (FCTN THETA))
     (while (> (abs (- THETA THETAOLD)) RFL:TOLFINE)
      (if (> (* F F2) 0.0)
       (setq THETA2 THETA)
       (setq THETA1 THETA)
      )
      (setq THETAOLD THETA)
      (setq THETA (/ (+ THETA1 THETA2) 2.0))
      (setq F1 (FCTN THETA1))
      (setq F2 (FCTN THETA2))
      (setq F (FCTN THETA))
     )
    )
   )
  )
 )
 (setq R (GETR THETA))
 (if (< (abs R) RFL:TOLFINE)
  (setq STATION 0.0)
  (setq STATION (/ A2 R))
 )
 (setq P0 (list (* R (RFL:SPIRALFXR THETA)) (* SPIRALDIRECTION R (RFL:SPIRALFYR THETA)) 0.0))
 (setq P1 (list PX PY 0.0))
 (if (> (sin (angle P0 P1)) 0.0)
  (setq OFFSETDIRECTION -1.0)
  (setq OFFSETDIRECTION 1.0)
 )
 (setq OFFSET (* OFFSETDIRECTION (distance P0 P1)))
 (setq STAOFFVAL (list STATION OFFSET))
 STAOFFVAL
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALXY returns the station and offset of the supplied point to the supplied entity
;
;
(defun RFL:SPIRALXY (P ENT / LO PLT PLTST PST SPIRALLIST STAOFFVAL PXY)
 (setq SPIRALLIST (RFL:GETSPIRALDATA ENT))
 (if (= SPIRALLIST nil)
  (setq PXY nil)
  (setq PLT (car SPIRALLIST)
        PLTST (cadr SPIRALLIST)
        PST (caddr SPIRALLIST)
        LO (cadddr SPIRALLIST)
        PXY (RFL:SPIRALXY2 P PLT PLTST PST)
  )
 )
 PXY
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    RFL:SPIRALXY2 returns the station and offset of the supplied point to the supplied spiral data
;
;
(defun RFL:SPIRALXY2 (P PLT PLTST PST / ANG ANG2 DIR L LS OFFSET PS PXY R RMAX THETAMAX X Y)
 (setq ANG (angle PLT PLTST))
 (if (> (sin (- (angle PLTST PST) (angle PLT PLTST))) 0.0)
  (setq DIR 1.0)
  (setq DIR -1.0)
 )
 (setq L (car P))
 (setq OFFSET (cadr P))
 (setq LS (RFL:GETSPIRALLS2 PLT PLTST PST))
 (setq THETAMAX (RFL:GETSPIRALTHETA2 PLT PLTST PST))
 (setq RMAX (RFL:GETSPIRALR2 PLT PLTST PST))
 (if (< L RFL:TOLFINE)
  (progn
   (setq PS PLT)
   (setq THETA 0.0)
  )
  (progn
   (setq THETA (* THETAMAX (expt (/ L LS) 2)))
   (if (< L RFL:TOLFINE)
    (progn
     (setq R 0.0)
     (setq X 0.0)
     (setq Y 0.0)
    )
    (progn
     (setq R (* RMAX (/ LS L)))
     (setq X (* R (RFL:SPIRALFXR THETA)))
     (setq Y (* DIR R (RFL:SPIRALFYR THETA)))
    )
   )
   (setq PS (list (+ (car PLT) (* X (cos ANG)) (* -1.0 Y (sin ANG)))
                  (+ (cadr PLT) (* X (sin ANG)) (* Y (cos ANG)))
            )
   )
  )
 )
 (setq ANG2 (+ ANG (* DIR THETA) (/ pi -2.0)))
 (setq PXY (list (+ (car PS) (* OFFSET (cos ANG2)))
                 (+ (cadr PS) (* OFFSET (sin ANG2)))
           )
 )

 PXY
)
;
;
;     Program written by Robert Livingston, 2016/07/06
;
;     RFL:DRAWPARABOLICVCURVE draws a parabolic vertical curve through three input points.
;         Note that P2 must be precisely between P1 and P3 for this to be a valid alignment curve
;
;
(defun RFL:DRAWPARABOLICVCURVE (P1 P2 P3 / ENT ENTOB SPLINESEGS SPLINETYPE)
 (setq SPLINESEGS (getvar "SPLINESEGS"))
 (setq SPLINETYPE (getvar "SPLINETYPE"))
 
 (setq P1 (list (car P1) (cadr P1) 0.0)
       P2 (list (car P2) (cadr P2) 0.0)
       P3 (list (car P3) (cadr P3) 0.0)
 )

 (entmake (list (cons 0 "POLYLINE")
                (list 10 0.0 0.0 0.0)
                (cons 66 1)
          )
 )
 (entmake (list (cons 0 "VERTEX")
                (cons 10 P1)
          )
 )
 (entmake (list (cons 0 "VERTEX")
                (cons 10 P2)
          )
 )
 (entmake (list (cons 0 "VERTEX")
                (cons 10 P3)
          )
 )
 (setq ENT (entmake (list (cons 0 "SEQEND")
                    )
           )
 )
 (if ENT
  (progn
   (setvar "SPLINESEGS" 65)
   (setvar "SPLINETYPE" 5)
   (setq ENTOB (vlax-ename->vla-object (entlast)))
   (vlax-put-property ENTOB "Type" 2)
  )
 )
 
 (setvar "SPLINESEGS" SPLINESEGS)
 (setvar "SPLINETYPE" SPLINETYPE)
);
;
;   Program written by Robert Livingston, 99/11/15
;
;   RFL:DRAWPROF draws the current profile as defined in RFL:PVILIST
;
;
(defun RFL:DRAWPROF ( RFL:PVILIST / ACTIVEDOC ACTIVESPACE ANG BULGE C C2 CLAYER ENT ENTLIST G G1 G2 K
                                    L L1 L2 L3 L4 P1 P2 P3 PLINETYPE PREVENT SIGN STA STA1 STA2 TMP)
 (setq CLAYER (getvar "CLAYER"))
 
 (setq PREVENT nil)

 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )

 (if (= nil RFL:PROFDEFLIST)
  (princ "\n*** Profile not set ***")
  (progn
   (if (= (tblsearch "BLOCK" "PVI2") nil)
    (progn
     (princ "\n*** Creating LDD PVI node ***")
     (RFL:MAKEENT "PVI2")
    )
   )
     (setq C 0)
     (if (not (tblsearch "LAYER" (cdr (assoc "PLAYER" RFL:PROFDEFLIST))))
      (entmake (list (cons 0 "LAYER")
                     (cons 100 "AcDbSymbolTableRecord")
                     (cons 100 "AcDbLayerTableRecord")
                     (cons 2 (cdr (assoc "PLAYER" RFL:PROFDEFLIST)))
                     (cons 70 0)
               )
      )
     )
     (setvar "CLAYER" (cdr (assoc "PLAYER" RFL:PROFDEFLIST)))
     (if (= nil (tblsearch "BLOCK" "PVI2")) (RFL:MAKEENT "PVI2"))
     (while (< C (length RFL:PVILIST))
      (vla-insertblock ACTIVESPC
                       (vlax-3D-point (RFL:PROFPOINT (nth 0 (nth C RFL:PVILIST)) (nth 1 (nth C RFL:PVILIST))))
                       "PVI2"
                       25.4
                       25.4
                       25.4
                       0.0
      )
      (setq ENT (entlast))
      (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      (setq ENTLIST (entget ENT))
      (if (= (cdr (assoc 66 ENTLIST)) 1)
       (progn
        (if (or (= C 0) (= C (- (length RFL:PVILIST) 1)))
         (progn
          (setq L 0.0 K 0.0)
         )
         (progn
          (setq L (nth 3 (nth C RFL:PVILIST)))
          (setq G1 (/ (- (nth 1 (nth C RFL:PVILIST))
                         (nth 1 (nth (- C 1) RFL:PVILIST))
                      )
                      (- (nth 0 (nth C RFL:PVILIST))
                         (nth 0 (nth (- C 1) RFL:PVILIST))
                      )
                   )
          )
          (setq G2 (/ (- (nth 1 (nth (+ C 1) RFL:PVILIST))
                         (nth 1 (nth C RFL:PVILIST))
                      )
                      (- (nth 0 (nth (+ C 1) RFL:PVILIST))
                         (nth 0 (nth C RFL:PVILIST))
                      )
                   )
          )
          (if (= G1 G2)
           (setq K 0.0)
           (setq K (abs (/ L (- G2 G1) 100.0)))
          )
         )
        )
        (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
         (if (= (cdr (assoc 2 ENTLIST)) "LENGTH")
          (progn
           (setq ENTLIST (subst (cons 1 (rtos L 2 8)) (assoc 1 ENTLIST) ENTLIST))
           (entmod ENTLIST)
           (entupd ENT)
          )
         )
         (if (= (cdr (assoc 2 ENTLIST)) "K")
          (progn
           (setq ENTLIST (subst (cons 1 (rtos K 2 8)) (assoc 1 ENTLIST) ENTLIST))
           (entmod ENTLIST)
           (entupd ENT)
          )
         )
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
        )
       )
      )
      (setq C (+ C 1))
     )
   (setq C 1)
   (setq G1 (/ (- (nth 1 (nth C RFL:PVILIST))
                  (nth 1 (nth (- C 1) RFL:PVILIST))
               )
               (- (nth 0 (nth C RFL:PVILIST))
                  (nth 0 (nth (- C 1) RFL:PVILIST))
               )
            )
   )
   (if (= (+ C 1) (length RFL:PVILIST))
    (setq G2 0)
    (setq G2 (/ (- (nth 1 (nth (+ C 1) RFL:PVILIST))
                   (nth 1 (nth C RFL:PVILIST))
                )
                (- (nth 0 (nth (+ C 1) RFL:PVILIST))
                   (nth 0 (nth C RFL:PVILIST))
                )
             )
    )
   )
   (setq G (- G2 G1))
   (setq ANG (- (atan G2) (atan G1)))
   (if (> G 0) (setq SIGN 1.0) (setq SIGN -1.0))
   (if (= (nth 2 (nth C RFL:PVILIST)) "L")
    (progn
     (setq L3 (/ (nth 3 (nth C RFL:PVILIST)) 2.0))
     (setq L4 (/ (nth 3 (nth C RFL:PVILIST)) 2.0))
    )
    (progn
     (setq TMP (* (nth 3 (nth C RFL:PVILIST))
                (RFL:TAN (/ (abs ANG) 2.0))
             )
     )
     (setq L3 (* TMP (cos (atan (abs G1)))))
     (setq L4 (* TMP (cos (atan (abs G2)))))
    )
   )
   (setq STA1 (nth 0 (nth (- C 1) RFL:PVILIST)))
   (setq STA2 (- (nth 0 (nth C RFL:PVILIST)) L3))
   (command "._LINE"
            (RFL:PROFPOINT STA1 (RFL:ELEVATION STA1))
            (RFL:PROFPOINT STA2 (RFL:ELEVATION STA2))
            ""
   )
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (while (< C (- (length RFL:PVILIST) 1))
    (setq C (+ C 1))
    (setq G1 G2)
    (if (= (+ C 1) (length RFL:PVILIST))
     (setq G2 0)
     (setq G2 (/ (- (nth 1 (nth (+ C 1) RFL:PVILIST))
                    (nth 1 (nth C RFL:PVILIST))
                 )
                 (- (nth 0 (nth (+ C 1) RFL:PVILIST))
                    (nth 0 (nth C RFL:PVILIST))
                 )
              )
     )
    )
    (setq G (- G2 G1))
    (setq ANG (- (atan G2) (atan G1)))
    (if (> G 0) (setq SIGN 1.0) (setq SIGN -1.0))
    (if (= (nth 2 (nth C RFL:PVILIST)) "L")
     (progn
      (setq L1 L3)
      (setq L2 L4)
      (setq L3 (/ (nth 3 (nth C RFL:PVILIST)) 2.0))
      (setq L4 (/ (nth 3 (nth C RFL:PVILIST)) 2.0))
     )
     (progn
      (setq L1 L3)
      (setq L2 L4)
      (setq TMP (* (nth 3 (nth C RFL:PVILIST))
                 (RFL:TAN (/ (abs ANG) 2.0))
              )
      )
      (setq L3 (* TMP (cos (atan (abs G1)))))
      (setq L4 (* TMP (cos (atan (abs G2)))))
     )
    )
    (if (> (+ L1 L2) 0.0)
     (progn
      (entmake)
      (setq STA1 (- (nth 0 (nth (- C 1) RFL:PVILIST)) L1))
      (setq STA2 (+ (nth 0 (nth (- C 1) RFL:PVILIST)) L2))
      (RFL:DRAWPARABOLICVCURVE (RFL:PROFPOINT STA1 (RFL:ELEVATION STA1))
                               (RFL:PROFPOINT (nth 0 (nth (- C 1) RFL:PVILIST)) (nth 1 (nth (- C 1) RFL:PVILIST)))
                               (RFL:PROFPOINT STA2 (RFL:ELEVATION STA2))
      )
      (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
     )
    )
    (setq STA1 (+ (nth 0 (nth (- C 1) RFL:PVILIST)) L2))
    (setq STA2 (- (nth 0 (nth C RFL:PVILIST)) L3))
    (command "._LINE"
             (RFL:PROFPOINT STA1 (RFL:ELEVATION STA1))
             (RFL:PROFPOINT STA2 (RFL:ELEVATION STA2))
             ""
    )
    (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   )
  )
 )
 (setvar "CLAYER" CLAYER)
)
;
;
;   Program written by Robert Livingston, 98/05/14
;
;   RFL:ELEVATION returns the elevation at a specified station for the curretnly defined profile (RFL:PVILIST)
;
;
(if RFL:ELEVATION (princ "\nRFL:ELEVATION already loaded...")
(defun RFL:ELEVATION (STA / C CMDECHO D ELEV ELEV1 ELEV2 ELEV3 G1 G2 L NODE P STA1 STA2 STA3)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (/= nil RFL:PVILIST)
  (progn
   (if (or (< STA (caar RFL:PVILIST)) (> STA (car (last RFL:PVILIST))))
    (progn
     (princ "\n*** STATION OUT OF RANGE ***\n")
     (setq ELEV nil)
    )
    (progn
     (setq C 1)
     (while (> STA (+ (car (setq NODE (nth C RFL:PVILIST)))
                      (/ (if (= nil (cadddr NODE)) 0.0 (cadddr NODE)) 2.0)
                   )
            )
      (setq C (1+ C))
     )
     (if (or (= "L" (caddr (nth C RFL:PVILIST))) (= nil (caddr (nth C RFL:PVILIST))))
      (progn
       (setq NODE (nth (1- C) RFL:PVILIST))
       (setq STA1 (car NODE))
       (setq ELEV1 (cadr NODE))
       (setq NODE (nth C RFL:PVILIST))
       (setq STA2 (car NODE))
       (setq ELEV2 (cadr NODE))
       (setq L (if (= nil (cadddr NODE)) 0.0 (cadddr NODE)))
       (setq G1 (/ (- ELEV2 ELEV1) (- STA2 STA1)))
       (setq ELEV (+ ELEV1 (* G1 (- STA STA1))))
       (setq D (- STA (- STA2 (/ L 2.0))))
       (if (> D 0.0)
        (progn
         (setq NODE (nth (1+ C) RFL:PVILIST))
         (setq STA3 (car NODE))
         (setq ELEV3 (cadr NODE))
         (setq G2 (/ (- ELEV3 ELEV2) (- STA3 STA2)))
         (setq ELEV (+ ELEV (/ (* D D (- G2 G1)) (* L 2.0))))
        )
       )        
      )
      (progn
       (princ "\n*** ONLY PARABILIC VERTICAL CURVES SUPPORTED ***\n")
       (setq ELEV nil)
      )
     )
    )
   )
  )
  (progn
   (princ "\n*** PROFILE NOT SET - RUN GPROF OR RPROF ***\n")
   (setq ELEV nil)
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (eval ELEV)
)
)
;
;
;   Program written by Robert Livingston, 98/05/14
;
;   RFL:PROFDEF locates and defines a global variable RFL:PROFDEFLIST with the profile base point, stationing and elevations
;
;
(defun RFL:PROFDEF (/ BPOINT DIRECTION ELEV ELEVMAX ENT ENTLIST FNAME OBPROFILE PLAYER PTLAYER
                      SCALE STA STAH STAL STAMAX TMP VEXAG X1 X2 Y1 Y2)
 (setq RFL:PROFDEFLIST nil
       BPOINT nil
       DIRECTION nil
       ELEV nil
       FNAME ""
       PLAYER (getvar "CLAYER")
       PTLAYER (getvar "CLAYER")
       SCALE 1.0
       STA nil
       VEXAG 1.0
 )
 (setq ENT (car (entsel "\nSelect profile grid or profile definition block : ")))
 (setq ENTLIST (entget ENT))
 (setq BPOINT (cdr (assoc 10 ENTLIST)))
 (if (and (= "INSERT" (cdr (assoc 0 ENTLIST)))
          (= 1 (cdr (assoc 66 ENTLIST)))
     )
  (progn
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
    (cond ((= "DIRECTION" (strcase (cdr (assoc 2 ENTLIST))))
           (setq DIRECTION (atoi (cdr (assoc 1 ENTLIST))))
          )
          ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
           (setq ELEV (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "FNAME" (strcase (cdr (assoc 2 ENTLIST))))
           (setq FNAME (cdr (assoc 1 ENTLIST)))
          )
          ((= "PLAYER" (strcase (cdr (assoc 2 ENTLIST))))
           (setq PLAYER (cdr (assoc 1 ENTLIST)))
          )
          ((= "PTLAYER" (strcase (cdr (assoc 2 ENTLIST))))
           (setq PTLAYER (cdr (assoc 1 ENTLIST)))
          )
          ((= "SCALE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq SCALE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "STAH" (strcase (cdr (assoc 2 ENTLIST))))
           (setq STAH (cdr (assoc 1 ENTLIST)))
          )
          ((= "STAL" (strcase (cdr (assoc 2 ENTLIST))))
           (setq STAL (cdr (assoc 1 ENTLIST)))
          )
          ((= "VEXAG" (strcase (cdr (assoc 2 ENTLIST))))
           (setq VEXAG (atof (cdr (assoc 1 ENTLIST))))
          )
    )
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
   (if (and STAH STAL) (setq STA (atof (strcat STAH STAL))))
  )
  (if (= "AECC_PROFILE_VIEW" (cdr (assoc 0 ENTLIST)))
   (progn
    (setq OBPROFILE (vlax-ename->vla-object ENT))
    (setq ELEV (vlax-get OBPROFILE "ElevationMin"))
    (setq ELEVMAX (vlax-get OBPROFILE "ElevationMax"))
    (setq STA (vlax-get OBPROFILE "StationStart"))
    (setq STAMAX (vlax-get OBPROFILE "StationEnd"))
    (vlax-invoke-method OBPROFILE 'FindXYAtStationAndElevation STA ELEV 'X1 'Y1 'inside)
    (vlax-invoke-method OBPROFILE 'FindXYAtStationAndElevation STAMAX ELEVMAX 'X2 'Y2 'inside)
    (if (< X1 X2)
     (setq BPOINT (list X1 Y1)
           DIRECTION 1
     )
     (setq BPOINT (list X2 Y1)
           DIRECTION -1
           STA (vlax-get OBPROFILE "StationEnd")
           STAMAX (vlax-get OBPROFILE "StationStart")
     )
    )
    (setq VEXAG (/ (- Y2 Y1) (- ELEVMAX ELEV)))
   )
   (if (= "AECC_PROFILE" (cdr (assoc 0 ENTLIST)))
    (progn
     (setq OBPROFILE (vlax-ename->vla-object ENT))
     (setq ELEV (vlax-get OBPROFILE "ElevationMin"))
     (setq ELEVMAX (vlax-get OBPROFILE "ElevationMax"))
     (setq STA (vlax-get OBPROFILE "StartingStation"))
     (setq STAMAX (vlax-get OBPROFILE "StationEnd"))
     (vlax-invoke-method OBPROFILE 'FindXYAtStationAndElevation STA ELEV 'X1 'Y1 'inside)
     (vlax-invoke-method OBPROFILE 'FindXYAtStationAndElevation STAMAX ELEVMAX 'X2 'Y2 'inside)
     (if (< X1 X2)
      (setq BPOINT (list X1 Y1)
            DIRECTION 1
      )
      (setq BPOINT (list X2 Y1)
            DIRECTION -1
            STA (vlax-get OBPROFILE "StationEnd")
            STAMAX (vlax-get OBPROFILE "StationStart")
      )
     )
     (setq VEXAG (/ (- Y2 Y1) (- ELEVMAX ELEV)))
    )
    (if (/= nil (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT"))))))
     (if (= (cdar ENTLIST) "RFLTOOLS_DRAWGRID")
      (progn
       (setq ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             STA (cdar ENTLIST)
             ENTLIST (cdr ENTLIST)
             ELEV (cdar ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             VEXAG (cdar ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             ENTLIST (cdr ENTLIST)
             SCALE (cdar ENTLIST)
             ENTLIST (cdr ENTLIST)
             DIRECTION (cdar ENTLIST)
       )
      )
     )
    )
   )
  )
 )
 (if (and BPOINT DIRECTION ELEV FNAME PLAYER PTLAYER SCALE STA VEXAG)
  (setq RFL:PROFDEFLIST (list (cons "BPOINT" BPOINT)
                              (cons "DIRECTION" DIRECTION)
                              (cons "ELEV" ELEV)
                              (cons "FNAME" FNAME)
                              (cons "PLAYER" PLAYER)
                              (cons "PTLAYER" PTLAYER)
                              (cons "SCALE" SCALE)
                              (cons "STA" STA)
                              (cons "VEXAG" VEXAG)
                )
  )
  nil
 )
);
;
;   Program written by Robert Livingston, 99/11/15
;
;   RFL:PROFHIGHLOW draws circles at the high and low points along a profile
;
;
(defun RFL:PROFHIGHLOW (R / CLAYER ENT OSMODE G1 G2 L P1 P2 P3 PREVENT PVI STA STA1 STA2)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq PREVENT nil)
 (if (not (tblsearch "LAYER" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST))))
  (entmake (list (cons 0 "LAYER")
                 (cons 100 "AcDbSymbolTableRecord")
                 (cons 100 "AcDbLayerTableRecord")
                 (cons 2 (cdr (assoc "PTLAYER" RFL:PROFDEFLIST)))
                 (cons 70 0)
           )
  )
 )
 (setvar "CLAYER" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST)))

 (setq PVI RFL:PVILIST)
 (setq P1 (car PVI))
 (setq PVI (cdr PVI))
 (setq P2 (car PVI))
 (setq PVI (cdr PVI))
 (setq P3 (car PVI))
 (setq PVI (cdr PVI))
 (while (/= nil P3)
  (setq G1 (/ (- (nth 1 P2) (nth 1 P1)) (- (nth 0 P2) (nth 0 P1))))
  (setq G2 (/ (- (nth 1 P3) (nth 1 P2)) (- (nth 0 P3) (nth 0 P2))))
  (setq L (nth 3 P2))
  (setq STA1 (- (nth 0 P2) (/ L 2.0)))
  (setq STA2 (+ (nth 0 P2) (/ L 2.0)))
  (if (< (* G1 G2) 0.0)
   (progn
    (setq STA (+ STA1 (/ (* L G1) (- G1 G2))))
    (entmake (list (cons 0 "CIRCLE")
                   (cons 10 (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                   (cons 40 R)
             )
    )
    (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   )
  )
  (setq P1 P2)
  (setq P2 P3)
  (setq P3 (car PVI))
  (setq PVI (cdr PVI))
 )
 (setvar "OSMODE" OSMODE)
 (setvar "CLAYER" CLAYER)
);
;
;   Program written by Robert Livingston, 98/05/14
;
;   RFL:PROFPOINT returns the point at a specified station and elevation for the curretnly defined profile grid RFL:PROFDEFLIST
;
;
(defun RFL:PROFPOINT (STA ELEV / D X Y)
 (if (/= nil RFL:PROFDEFLIST)
  (progn
   (if (= (assoc "DIRECTION" RFL:PROFDEFLIST) nil)
    (setq D 1)
    (setq D (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)))
   )
   (setq X (+ (* (- STA
                    (cdr (assoc "STA" RFL:PROFDEFLIST))
                 )
                 D
              )
              (car (cdr (assoc "BPOINT" RFL:PROFDEFLIST)))
           )
   )
   (setq Y (+ (* (- ELEV
                    (cdr (assoc "ELEV" RFL:PROFDEFLIST))
                 )
                 (cdr (assoc "VEXAG" RFL:PROFDEFLIST))
              )
              (cadr (cdr (assoc "BPOINT" RFL:PROFDEFLIST)))
           )
   )
   (list X Y 0.0)
  )
  (progn
   (princ "\n*** PROFILE NOT SET - RUN GPROF OR RPROF ***\n")
   nil
  )
 )
)
;
;
;   Program written by Robert Livingston, 98/05/13
;
;   RPROF reads a vertical alignment from file INFILENAME and sets the global variable RFL:PVILIST
;
;
(defun RFL:RPROF (INFILENAME / INFILE INLINE PVIENT PVISET STA ELEV LR VAL)
 (if (/= INFILENAME nil) (setq INFILENAME (findfile INFILENAME)))
 (if (/= INFILENAME nil)
  (progn
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory INFILENAME) "\\"))
   (setq INFILE (open INFILENAME "r"))
   (setq RFL:PVILIST nil)
   (setq INLINE (read-line INFILE))
   (if (/= INLINE "#RFL VERTICAL ALIGNMENT FILE")
    (progn
     (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
    )
    (progn
     (setq INLINE (read-line INFILE))
     (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
      (setq STA (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq ELEV (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq LR INLINE)
      (setq INLINE (read-line INFILE))
      (setq VAL (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq RFL:PVILIST (append RFL:PVILIST (list (list STA ELEV LR VAL))))
     )
    )
   )
   (close INFILE)
  )
 )
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RFL:RPROFB reads a vertical profile from a RFLAlign Block
;
;
(defun RFL:RPROFB (BLKENT / ELEV ENT ENTLIST INLINE LR STA VAL)
 (setq RFL:PVILIST nil)
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "VRT" (cdr (assoc 2 ENTLIST)))
  (setq ENT (entnext ENT))
  (setq ENTLIST (entget ENT))
 )
 (setq INLINE (cdr (assoc 1 ENTLIST)))
 (setq ENT (entnext ENT))
 (setq ENTLIST (entget ENT))
 (if (/= INLINE "#RFL VERTICAL ALIGNMENT FILE")
  (progn
   (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
  )
  (progn
   (setq INLINE (cdr (assoc 1 ENTLIST)))
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
    (setq STA (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq ELEV (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq LR INLINE)
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq VAL (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq RFL:PVILIST (append RFL:PVILIST (list (list STA ELEV LR VAL))))
   )
  )
 )
)
;
;
;     Program written by Robert Livingston, 2016-07-19
;
;     RFL:RPROFC3D is a utility for reading a C3D profile and setting RFL:PVILIST
;     NOTE - Must be using C3D, will not work in straight AutoCAD
;     NOTE - Works for type 1 and type 3 vertical curves
;
;
(defun RFL:RPROFC3D (ENT / C CMAX CMDECHO ENDELEVATION ENDSTATION ENTITY ENTITYNEXT ENTLIST N1 N2 OBPROFILE OBENTITIES
                           PVISTATION PVIELEVATION PVILENGTH STARTELEVATION STARTSTATION TYPE TMP)
 (if (= nil vlax-create-object) (vl-load-com))
 
 (defun GETPVISTATION ()
  (setq PVISTATION (vlax-get-property ENTITY "PVIStation"))
 )
 
 (setq RFL:PVILIST nil)
 
 (setq ENTLIST (entget ENT))
 
 (if (/= "AECC_PROFILE" (cdr (assoc 0 ENTLIST)))
  (princ "\n*** Not a C3D Profile ***")
  (progn
   (setq OBPROFILE (vlax-ename->vla-object ENT))
   (setq STARTSTATION (vlax-get-property OBPROFILE "StartingStation"))
   (setq STARTELEVATION (vlax-invoke-method OBPROFILE "ElevationAt" STARTSTATION))
   (setq RFL:PVILIST (list (list STARTSTATION STARTELEVATION "L" 0.0)))
   (setq ENDSTATION (vlax-get-property OBPROFILE "EndingStation"))
   (setq ENDELEVATION (vlax-invoke-method OBPROFILE "ElevationAt" ENDSTATION))
   (setq OBENTITIES (vlax-get-property OBPROFILE "Entities"))
   (setq CMAX (vlax-get-property OBENTITIES "Count"))
   (setq C 0)
   (while (< C CMAX)
    (setq ENTITY (vlax-invoke-method OBENTITIES "Item" C))
    (if (= (+ C 1) CMAX) (setq ENTITYNEXT nil) (setq ENTITYNEXT (vlax-invoke-method OBENTITIES "Item" (+ C 1))))
    (cond
     ((= 1 (vlax-get-property ENTITY "Type"))
      (progn
       (if (/= ENTITYNEXT nil)
        (if (= (vlax-get-property ENTITYNEXT "Type") 1)
         (progn
          (setq PVISTATION (vlax-get-property ENTITY "EndStation"))
          (setq PVIELEVATION (vlax-get-property ENTITY "EndElevation"))
          (setq PVILENGTH 0.0)
          (setq RFL:PVILIST (append RFL:PVILIST (list (list PVISTATION PVIELEVATION "L" PVILENGTH))))
         )
        )
       )
      )
     )
     ((= 3 (vlax-get-property ENTITY "Type"))
      (progn
       (setq PVISTATION (vlax-get-property ENTITY "PVIStation"))
       (setq PVIELEVATION (vlax-get-property ENTITY "PVIElevation"))
       (setq PVILENGTH (vlax-get-property ENTITY "Length"))
       (setq RFL:PVILIST (append RFL:PVILIST (list (list PVISTATION PVIELEVATION "L" PVILENGTH))))
      )
     )
    )
    (setq C (1+ C))
   )
   
   (setq RFL:PVILIST (append RFL:PVILIST (list (list ENDSTATION ENDELEVATION "L" 0.0))))
  )
 )
 (if RFL:PVILIST
  (progn
   ; Sorting
   (setq RFL:PVILIST (vl-sort RFL:PVILIST (function (lambda (N1 N2) (< (car N1) (car N2))))))
   ; Removing extra PVIs
   (setq TMP (list (car RFL:PVILIST))
         RFL:PVILIST (cdr RFL:PVILIST)
   )
   (while (cdr RFL:PVILIST)
    (if (and (> (abs (- (caar RFL:PVILIST) (car (last TMP)))) RFL:TOL)
             (> (abs (- (caadr RFL:PVILIST) (caar RFL:PVILIST))) RFL:TOL)
             (> (abs (- (/ (- (cadar RFL:PVILIST) (cadr (last TMP))) (- (caar RFL:PVILIST) (car (last TMP))))
                        (/ (- (cadadr RFL:PVILIST) (cadar RFL:PVILIST)) (- (caadr RFL:PVILIST) (caar RFL:PVILIST)))
                     )
                )
                RFL:TOL
             )
        )
     (setq TMP (append TMP (list (car RFL:PVILIST))))
    )
    (setq RFL:PVILIST (cdr RFL:PVILIST))
   )
   (setq TMP (append TMP RFL:PVILIST))
   (setq RFL:PVILIST TMP)
  )
 )
 
 
 RFL:PVILIST
);
;
;   Program written by Robert Livingston, 98/05/13
;
;   RFL:RPROFOG reads a vertical alignment from file INFILENAME and sets the global variable RFL:OGLIST
;
;
(defun RFL:RPROFOG (INFILENAME / INFILE INLINE PVIENT PVISET STA ELEV LR VAL)
 (if (/= INFILENAME nil) (setq INFILENAME (findfile INFILENAME)))
 (if (/= INFILENAME nil)
  (progn
   (setq INFILE (open INFILENAME "r"))
   (setq RFL:OGLIST nil)
   (setq INLINE (read-line INFILE))
   (if (/= INLINE "#RFL VERTICAL ALIGNMENT FILE")
    (progn
     (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
    )
    (progn
     (setq INLINE (read-line INFILE))
     (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
      (setq STA (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq ELEV (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq LR INLINE)
      (setq INLINE (read-line INFILE))
      (setq VAL (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq RFL:OGLIST (append RFL:OGLIST (list (list STA ELEV))))
     )
    )
   )
   (close INFILE)
  )
 )
);
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RFL:RPROFOGB reads a vertical OG profile from a RFLAlign Block
;
;
(defun RFL:RPROFOGB (BLKENT / ELEV ENT ENTLIST INLINE LR STA VAL)
 (setq RFL:OGLIST nil)
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "OG" (cdr (assoc 2 ENTLIST)))
  (setq ENT (entnext ENT))
  (setq ENTLIST (entget ENT))
 )
 (setq INLINE (cdr (assoc 1 ENTLIST)))
 (setq ENT (entnext ENT))
 (setq ENTLIST (entget ENT))
 (if (/= INLINE "#RFL VERTICAL ALIGNMENT FILE")
  (progn
   (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
  )
  (progn
   (setq INLINE (cdr (assoc 1 ENTLIST)))
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
    (setq STA (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq ELEV (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq LR INLINE)
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq VAL (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq RFL:OGLIST (append RFL:OGLIST (list (list STA ELEV))))
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 98/05/14
;
;   RFL:SLOPE returns the slope at a specified station for the curretnly defined profile (RFL:PVILIST)
;
;
(if RFL:SLOPE (princ "\nRFL:SLOPE already loaded...")
(defun RFL:SLOPE (STA / C CMDECHO ELEV1 ELEV2 ELEV3 G G1 G2 L NODE P)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (/= nil RFL:PVILIST)
  (progn
   (if (or (< STA (caar RFL:PVILIST)) (> STA (car (last RFL:PVILIST))))
    (progn
     (princ "\n*** STATION OUT OF RANGE ***\n")
     (if (< STA (caar RFL:PVILIST))
      (setq G (/ (- (cadadr RFL:PVILIST) (cadar RFL:PVILIST)) (- (caadr RFL:PVILIST) (caar RFL:PVILIST))))
      (setq G (/ (- (cadadr (reverse RFL:PVILIST)) (cadar (reverse RFL:PVILIST))) (- (caadr (reverse RFL:PVILIST)) (caar (reverse RFL:PVILIST)))))
     )
    )
    (progn
     (setq C 0)
     (while (> STA (+ (car (setq NODE (nth C RFL:PVILIST)))
                      (/ (cadddr NODE) 2.0)
                   )
            )
      (setq C (1+ C))
     )
     (if (= "L" (caddr (nth C RFL:PVILIST)))
      (progn
       (setq NODE (nth (1- C) RFL:PVILIST))
       (setq STA1 (car NODE))
       (setq ELEV1 (cadr NODE))
       (setq NODE (nth C RFL:PVILIST))
       (setq STA2 (car NODE))
       (setq ELEV2 (cadr NODE))
       (setq L (cadddr NODE))
       (setq G1 (/ (- ELEV2 ELEV1) (- STA2 STA1)))
       (setq G G1)
       (setq D (- STA (- STA2 (/ L 2.0))))
       (if (> D 0.0)
        (progn
         (setq NODE (nth (1+ C) RFL:PVILIST))
         (setq STA3 (car NODE))
         (setq ELEV3 (cadr NODE))
         (setq G2 (/ (- ELEV3 ELEV2) (- STA3 STA2)))
         (setq G (+ G1 (* (/ D L) (- G2 G1))))
        )
       )        
      )
      (progn
       (princ "\n*** ONLY PARABILIC VERTICAL CURVES SUPPORTED ***\n")
       (setq ELEV nil)
      )
     )
    )
   )
  )
  (progn
   (princ "\n*** PROFILE NOT SET - RUN GPROF OR RPROF ***\n")
   (setq G nil)
  )
 )

 (setvar "CMDECHO" CMDECHO)
 G
)
)
;
;
;   Program written by Robert Livingston, 99/12/03
;
;   (RFL:VP) returns the X,Y point for a station and elevation of the currently defined vertical alignment
;
(defun RFL:VP (/ ACCEPTVP CANCEL CANCELVP DCL_ID FIXSTA FIXZ P VPPICK)
 (defun ACCEPTVP ()
  (setq CANCEL 0)
  (setq VPSTA (atof (get_tile "STATION")))
  (setq VPELEV (atof (get_tile "ELEV")))
  (done_dialog)
 )

 (defun CANCELVP ()
  (setq CANCEL 1)
  (done_dialog)
 )

 (defun VPPICK (/ P)
  (setq CANCEL -1)
  (done_dialog)
 )

 (defun FIXSTA (/ TMP)
  (set_tile "STATION" (rtos (atof (get_tile "STATION"))))
 )

 (defun FIXZ ()
  (set_tile "ELEV" (rtos (atof (get_tile "ELEV"))))
 )

 (setq CANCEL -1)

 (if (or (= RFL:PROFDEFLIST nil) (= RFL:PROFPOINT nil))
  (princ "\n*** No vertical alignment defined or utilities not loaded ***")
  (progn
   (while (= CANCEL -1)

    (if (= VPDCLNAME nil)
     (progn
      (setq VPDCLNAME (vl-filename-mktemp "rfl.dcl"))
      (RFL:MAKEDCL VPDCLNAME "VP")
     )
     (if (= nil (findfile VPDCLNAME))
      (progn
       (setq VPDCLNAME (vl-filename-mktemp "rfl.dcl"))
       (RFL:MAKEDCL VPDCLNAME "VP")
      )
     )
    )

    (setq DCL_ID (load_dialog VPDCLNAME))
    (if (not (new_dialog "VP" DCL_ID)) (exit))

    (if (= nil VPSTA) (setq VPSTA 0.0))
    (if (= nil VPELEV) (setq VPELEV 0.0))

    (set_tile "STATION" (rtos VPSTA))
    (set_tile "ELEV" (rtos VPELEV))

    (FIXSTA)
    (FIXZ)

    (action_tile "STATION" "(FIXSTA)")
    (action_tile "ELEV" "(FIXZ)")
    (action_tile "PICK" "(VPPICK)")
    (action_tile "OK" "(ACCEPTVP)")
    (action_tile "CANCEL" "(CANCELVP)")

    (start_dialog)
    (unload_dialog DCL_ID)

    (if (= CANCEL 0)
     (progn
      (command "_NON" (RFL:PROFPOINT VPSTA VPELEV))
     )
     (if (= CANCEL -1)
      (progn
       (setq P (getpoint "\nProfile point : "))
       (if (/= nil P)
        (progn
         (setq VPSTA (+ (* (cdr (assoc "DIRECTION" RFL:PROFDEFLIST))
                           (- (nth 0 P)
                              (nth 0 (cdr (assoc "BPOINT" RFL:PROFDEFLIST)))
                           )
                        )
                        (cdr (assoc "STA" RFL:PROFDEFLIST))
                     )
         )
         (setq VPELEV (+ (/ (- (nth 1 P)
                               (nth 1 (cdr (assoc "BPOINT" RFL:PROFDEFLIST)))
                            )
                            (cdr (assoc "VEXAG" RFL:PROFDEFLIST))
                         )
                         (cdr (assoc "ELEV" RFL:PROFDEFLIST))
                      )
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 99/12/03
;
;   (RFL:VPP pnt) returns the Station and Elevation of supplied point.
;
(defun RFL:VPP (P1 / STA Z)
 (if (= RFL:PROFDEFLIST nil) (RFL:PROFDEF))
 (setq STA (+ (* (cdr (assoc "DIRECTION" RFL:PROFDEFLIST))
                 (- (nth 0 P1)
                    (nth 0 (cdr (assoc "BPOINT" RFL:PROFDEFLIST)))
                 )
              )
              (cdr (assoc "STA" RFL:PROFDEFLIST))
           )
 )
 (setq Z (+ (/ (- (nth 1 P1)
                  (nth 1 (cdr (assoc "BPOINT" RFL:PROFDEFLIST)))
               )
               (cdr (assoc "VEXAG" RFL:PROFDEFLIST))
            )
            (cdr (assoc "ELEV" RFL:PROFDEFLIST))
         )
 )
 (list STA Z)
)
;
;
;   Program written by Robert Livingston, 98/05/13
;
;   RFL:WPROF writes a vertical alignment to file
;
;
(defun RFL:WPROF (OUTFILENAME / C OUTFILE)
 (if (/= OUTFILENAME nil)
  (progn
   (if (/= ".VRT" (strcase (substr OUTFILENAME (- (strlen OUTFILENAME) 3))))
    (setq OUTFILENAME (strcat OUTFILENAME ".VRT"))
   )
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory OUTFILENAME) "\\"))
   (setq C 0)
   (while (and (= nil (setq OUTFILE (open OUTFILENAME "w"))) (< C 5))
    (setq C (+ C 1))
    (princ (strcat "\nProblem openning file for writing : " (itoa C)))
   )
   (if (= nil OUTFILE)
    (alert (strcat "Error openning file for writing : " OUTFILENAME))
    (progn
     (princ "#RFL VERTICAL ALIGNMENT FILE\n" OUTFILE)
     (setq C 0)
     (while (< C (length RFL:PVILIST))
      (princ (rtos (nth 0 (nth C RFL:PVILIST)) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (rtos (nth 1 (nth C RFL:PVILIST)) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (nth 2 (nth C RFL:PVILIST)) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (rtos (nth 3 (nth C RFL:PVILIST)) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (setq C (+ C 1))
     )
     (princ "#END DEFINITION\n" OUTFILE)
     (close OUTFILE)
    )
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   RFL:WPROFB writes a vertical alinment to a RFLALIGN Block
;
;
(defun RFL:WPROFB (BLKENT / BLKENTNEW BLKENTLIST C ENT ENTLIST ENTN)
 (entmake)
 (setq BLKENTLIST (entget BLKENT))
 (setq BLKENTNEW (entmake BLKENTLIST))
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
  (if (= "VRT" (cdr (assoc 2 ENTLIST)))
   (progn
    (setq ENTLIST (subst (cons 1 "#RFL VERTICAL ALIGNMENT FILE") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq C 0)
    (while (< C (length RFL:PVILIST))
     (setq ENTLIST (subst (cons 70 1) (assoc 70 ENTLIST) ENTLIST))
     (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth C RFL:PVILIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth C RFL:PVILIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (nth 2 (nth C RFL:PVILIST))) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 3 (nth C RFL:PVILIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq C (+ C 1))
    )
    (setq ENTLIST (subst (cons 1 "#END DEFINITION") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (= "VRT" (cdr (assoc 2 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
   (progn
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
  )
 )
 (entmake ENTLIST)
 (entdel BLKENT)
 (setq BLKENTNEW (entlast))
)
;
;
;   Program written by Robert Livingston, 98/05/13
;
;   RFL:WPROFOG writes a vertical alignment to file
;
;
(defun RFL:WPROFOG (OUTFILENAME / C OUTFILE)
 (if (/= OUTFILENAME nil)
  (progn
   (if (/= ".VRT" (strcase (substr OUTFILENAME (- (strlen OUTFILENAME) 3))))
    (setq OUTFILENAME (strcat OUTFILENAME ".VRT"))
   )
   (setq C 0)
   (while (and (= nil (setq OUTFILE (open OUTFILENAME "w"))) (< C 5))
    (setq C (+ C 1))
    (princ (strcat "\nProblem openning file for writing : " (itoa C)))
   )
   (if (= nil OUTFILE)
    (alert (strcat "Error openning file for writing : " OUTFILENAME))
    (progn
     (princ "#RFL VERTICAL ALIGNMENT FILE\n" OUTFILE)
     (setq C 0)
     (while (< C (length RFL:OGLIST))
      (princ (rtos (nth 0 (nth C RFL:OGLIST)) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ (rtos (nth 1 (nth C RFL:OGLIST)) 2 16) OUTFILE)
      (princ "\n" OUTFILE)
      (princ "L\n" OUTFILE)
      (princ "0.0\n" OUTFILE)
      (setq C (+ C 1))
     )
     (princ "#END DEFINITION\n" OUTFILE)
     (close OUTFILE)
    )
   )
  )
 )
);
;
;   Program written by Robert Livingston, 2008/11/04
;
;   RFL:WPROFOGB writes a OG vertical alinment to a RFLALIGN Block
;
;
(defun RFL:WPROFOGB (BLKENT / BLKENTNEW BLKENTLIST C ENT ENTLIST ENTN)
 (entmake)
 (setq BLKENTLIST (entget BLKENT))
 (setq BLKENTNEW (entmake BLKENTLIST))
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
  (if (= "OG" (cdr (assoc 2 ENTLIST)))
   (progn
    (setq ENTLIST (subst (cons 1 "#RFL VERTICAL ALIGNMENT FILE") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq C 0)
    (while (< C (length RFL:OGLIST))
     (setq ENTLIST (subst (cons 70 1) (assoc 70 ENTLIST) ENTLIST))
     (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth C RFL:OGLIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth C RFL:OGLIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 "L") (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 "0.0") (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq C (+ C 1))
    )
    (setq ENTLIST (subst (cons 1 "#END DEFINITION") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (= "OG" (cdr (assoc 2 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
   (progn
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
  )
 )
 (entmake ENTLIST)
 (entdel BLKENT)
 (setq BLKENTNEW (entlast))
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   RFL:DSUPER inserts SUPER blocks along the current alignment
;
;
(defun RFL:DSUPER (/ ACTIVEDOC ACTIVESPACE ANGBASE ANGDIR ATTREQ DIMZIN ENT ENTLIST NODE OSMODE P1 P2 PREVENT SL)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 8)
 (setq ATTREQ (getvar "ATTREQ"))

 (setq PREVENT nil)

 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )

 (command "._UNDO" "M")

 (if (and (/= nil RFL:ALIGNLIST) (/= RFL:XY nil) (/= RFL:SUPERLIST nil))
  (progn
   (setq SL RFL:SUPERLIST)
   (while (/= SL nil)
    (setq NODE (car SL))
    (setq SL (cdr SL))
    (setq P1 (RFL:XY (list (nth 0 NODE) 0.0)))
    (if (/= P1 nil)
     (progn
      (setq P2 (RFL:XY (list (nth 0 NODE) 10.0)))
      (if (= nil (tblsearch "BLOCK" "SUPER")) (RFL:MAKEENT "SUPER"))
      (vla-insertblock ACTIVESPC
                       (vlax-3D-point P1)
                       "SUPER"
                       1.0
                       1.0
                       1.0
                       (- (angle P1 P2) (/ pi 2.0))
      )
      (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
       (if (= (cdr (assoc 2 ENTLIST)) "LEFT")
        (progn
         (setq ENTLIST (subst (cons 1 (rtos (nth 1 NODE) 2 8)) (assoc 1 ENTLIST) ENTLIST))
         (entmod ENTLIST)
         (entupd ENT)
        )
       )
       (if (= (cdr (assoc 2 ENTLIST)) "RIGHT")
        (progn
         (setq ENTLIST (subst (cons 1 (rtos (nth 2 NODE) 2 8)) (assoc 1 ENTLIST) ENTLIST))
         (entmod ENTLIST)
         (entupd ENT)
        )
       )
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
      )
     )
    )
   )
  )
  (princ "\n*** SUPERELEVATION NOT SET ***\n")
 )

 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "DIMZIN" DIMZIN)
 (setvar "ANGDIR" ATTREQ)
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   RFL:RSUPER reads the Superelevation from file
;
;
(defun RFL:RSUPER (INFILENAME / INFILE INLINE STA SUPERLEFT SUPERRIGHT)
 (if (/= INFILENAME nil) (setq INFILENAME (findfile INFILENAME)))
 (if (/= INFILENAME nil)
  (progn
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory INFILENAME) "\\"))
   (setq INFILE (open INFILENAME "r"))
   (setq RFL:SUPERLIST nil)
   (setq INLINE (read-line INFILE))
   (if (/= INLINE "#RFL SUPERELEVATION FILE")
    (progn
     (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
    )
    (progn
     (setq INLINE (read-line INFILE))
     (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
      (setq STA (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq SUPERLEFT (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq SUPERRIGHT (atof INLINE))
      (setq INLINE (read-line INFILE))
      (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list STA SUPERLEFT SUPERRIGHT))))
     )
    )
   )
   (close INFILE)
   T
  )
  nil
 )
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RFL:RSUPERB reads the Superelevation from a RFLAlign Block
;
;
(defun RFL:RSUPERB (BLKENT / ENT ENTLIST INLINE STA SUPERLEFT SUPERRIGHT)
 (setq RFL:SUPERLIST nil)
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "E" (cdr (assoc 2 ENTLIST)))
  (setq ENT (entnext ENT))
  (setq ENTLIST (entget ENT))
 )
 (setq INLINE (cdr (assoc 1 ENTLIST)))
 (setq ENT (entnext ENT))
 (setq ENTLIST (entget ENT))
 (if (/= INLINE "#RFL SUPERELEVATION FILE")
  (progn
   (princ "\n*** FILE NOT FORMATTED CORRECTLY ***\n")
  )
  (progn
   (setq INLINE (cdr (assoc 1 ENTLIST)))
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (and (/= nil INLINE) (/= INLINE "#END DEFINITION"))
    (setq STA (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq SUPERLEFT (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq SUPERRIGHT (atof INLINE))
    (setq INLINE (cdr (assoc 1 ENTLIST)))
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list STA SUPERLEFT SUPERRIGHT))))
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   RFL:SUPER returns a list (left super , right super) for the given station
;
;
(if RFL:SUPER (princ "\nRFL:SUPER already loaded...")
(defun RFL:SUPER (STA / C NODE1 NODE2 S1 S2 STA1 STA2 VAL)
 (setq VAL nil)
 (if (/= RFL:SUPERLIST nil)
  (progn
   (if (and (>= STA (car (car RFL:SUPERLIST))) (<= STA (car (last RFL:SUPERLIST))))
    (progn
     (setq C 0)
     (while (>= STA (car (nth C RFL:SUPERLIST)))
      (setq C (+ C 1))
     )
     (setq NODE1 (nth (- C 1) RFL:SUPERLIST))
     (setq NODE2 (nth C RFL:SUPERLIST))
     (setq STA1 (car NODE1))
     (setq STA2 (car NODE2))
     (setq S1 (cadr NODE1))
     (setq S2 (cadr NODE2))
     (setq VAL (list (+ S1 (* (- S2 S1) (/ (- STA STA1) (- STA2 STA1))))))
     (setq S1 (caddr NODE1))
     (setq S2 (caddr NODE2))
     (setq VAL (append VAL (list (+ S1 (* (- S2 S1) (/ (- STA STA1) (- STA2 STA1)))))))
    )
   )
  )
 )
 VAL
)
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   RFL:SUPERDEF calculating superelevations from supplied entity set and setting RFL:SUPERLIST
;
;
;(defun RFL:SUPERDEF (ENTSET / C ENT ENTLIST P PT SORTSUPER SUPERLEFT SUPERRIGHT SUPERLIST2)
(defun RFL:SUPERDEF (ENTSET)
 (defun SORTSUPER (SL / A B)
  (vl-sort SL '(lambda (A B) (< (car A) (car B))))
 )
 (setq RFL:SUPERLIST nil)
 (setq SUPERLIST2 nil)
 (if (and (/= RFL:ALIGNLIST nil) (/= RFL:STAOFF nil))
  (progn
   (setq C 0)
   (while (< C (sslength ENTSET))
    (setq ENT (ssname ENTSET C))
    (setq ENTLIST (entget ENT))
    (if (and (= (cdr (assoc 0 ENTLIST)) "INSERT")
             (= (strcase (cdr (assoc 2 ENTLIST))) "SUPER")
             (= (cdr (assoc 66 ENTLIST)) 1))
     (progn
      (setq PT (cdr (assoc 10 ENTLIST)))
      (setq P (RFL:STAOFF PT))
      ;
      ; The following are to 'nudge' the point - sometimes RFL:STAOFF returns nil when the point is an an entity endpoint
      ;
      (if (= nil P) (setq P (RFL:STAOFF (list (+ (car PT) 0.00000001) (+ (cadr PT) 0.00000001)))))
      (if (= nil P) (setq P (RFL:STAOFF (list (- (car PT) 0.00000001) (- (cadr PT) 0.00000001)))))
      (if (= nil P) (setq P (RFL:STAOFF (list (+ (car PT) 0.00000001) (- (cadr PT) 0.00000001)))))
      (if (= nil P) (setq P (RFL:STAOFF (list (- (car PT) 0.00000001) (+ (cadr PT) 0.00000001)))))
      (if (/= P nil)
       (progn
        (setq SUPERLEFT nil)
        (setq SUPERRIGHT nil)
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
        (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
         (if (= (cdr (assoc 2 ENTLIST)) "LEFT") (setq SUPERLEFT (atof (cdr (assoc 1 ENTLIST)))))
         (if (= (cdr (assoc 2 ENTLIST)) "RIGHT") (setq SUPERRIGHT (atof (cdr (assoc 1 ENTLIST)))))
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
        )
        (setq SUPERLIST2 (append SUPERLIST2 (list (list (car P) SUPERLEFT SUPERRIGHT))))
       )
      )
     )
    )
    (setq C (+ C 1))
   )
  )
 )
 (setq RFL:SUPERLIST (SORTSUPER SUPERLIST2))
 (princ (strcat "\n" (itoa (length RFL:SUPERLIST)) " nodes found."))
 T
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   RFL:WSUPER writes the superelevation to file
;
;
(defun RFL:WSUPER (OUTFILENAME / C OUTFILE)
 (if (/= OUTFILENAME nil)
  (progn
   (if (/= ".E" (strcase (substr OUTFILENAME (- (strlen OUTFILENAME) 1))))
    (setq OUTFILENAME (strcat OUTFILENAME ".e"))
   )
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory OUTFILENAME) "\\"))
   (setq OUTFILE (open OUTFILENAME "w"))
   (princ "#RFL SUPERELEVATION FILE\n" OUTFILE)
   (setq C 0)
   (while (< C (length RFL:SUPERLIST))
    (princ (rtos (nth 0 (nth C RFL:SUPERLIST)) 2 16) OUTFILE)
    (princ "\n" OUTFILE)
    (princ (rtos (nth 1 (nth C RFL:SUPERLIST)) 2 16) OUTFILE)
    (princ "\n" OUTFILE)
    (princ (rtos (nth 2 (nth C RFL:SUPERLIST)) 2 16) OUTFILE)
    (princ "\n" OUTFILE)
    (setq C (+ C 1))
   )
   (princ "#END DEFINITION\n" OUTFILE)
   (close OUTFILE)
   T
  )
  nil
 )
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   RFL:WSUPERB writes the superelevation to a RFLALIGN Block
;
;
(defun RFL:WSUPERB (BLKENT / BLKENTNEW BLKENTLIST C ENT ENTLIST ENTN)
 (entmake)
 (setq BLKENTLIST (entget BLKENT))
 (setq BLKENTNEW (entmake BLKENTLIST))
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
  (if (= "E" (cdr (assoc 2 ENTLIST)))
   (progn
    (setq ENTLIST (subst (cons 1 "#RFL SUPERELEVATION FILE") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq C 0)
    (while (< C (length RFL:SUPERLIST))
     (setq ENTLIST (subst (cons 70 1) (assoc 70 ENTLIST) ENTLIST))
     (setq ENTLIST (subst (cons 1 (rtos (nth 0 (nth C RFL:SUPERLIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 1 (nth C RFL:SUPERLIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq ENTLIST (subst (cons 1 (rtos (nth 2 (nth C RFL:SUPERLIST)) 2 16)) (assoc 1 ENTLIST) ENTLIST))
     (entmake ENTLIST)
     (setq C (+ C 1))
    )
    (setq ENTLIST (subst (cons 1 "#END DEFINITION") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (= "E" (cdr (assoc 2 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
   (progn
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
  )
 )
 (entmake ENTLIST)
 (entdel BLKENT)
 (setq BLKENTNEW (entlast))
)
;
;
;     Program written by Robert Livingston 2014-11-24
;
;     DRAPEALIGN drapes a RFL Alignment
;
;
(defun C:DRAPEALIGN (/ *error* ALSAVE ANG ANGBASE ANGDIR ATOTAL C CMAX CMDECHO L LSTEP NODE OBSURFACE OSMODE ORTHOMODE OSTOL P1 P2 R TMP TMPLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)

 (setq ALSAVE RFL:ALIGNLIST)
 
 (setq OSTOL 0.1)
 
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setq RFL:ALIGNLIST ALSAVE)
  ;(setq *error* nil)
  (print msg)
 )

 (command ".UNDO" "M")

 (if (= nil RFL:ALIGNLIST)
  (princ "\n*** Alignment not defined ***")
  (progn
   (setq OBSURFACE (RFL:GETC3DSURFACE))
   (if (= nil OBSURFACE)
    (princ "\n*** Error getting C3D Surface ***")
    (progn
     (setq OGLIST nil)
     (foreach NODE ALSAVE
      (progn
       (if (listp (last NODE))
        (progn ; SPIRAL
         (setq R (RFL:GETSPIRALR2 (nth 0 (last NODE)) (nth 1 (last NODE)) (nth 2 (last NODE))))
         (setq L (RFL:GETSPIRALLS2 (nth 0 (last NODE)) (nth 1 (last NODE)) (nth 2 (last NODE))))
         (if (not (listp (last (last NODE))))
          (setq L (- L (last (last NODE))))
         )
         (setq ANG (atan (/ (sqrt (- (* 2.0 R OSTOL) (* OSTOL OSTOL))) (- R OSTOL))))
         (setq LSTEP (* 2.0 R ANG))
         (setq CMAX (+ 1 (fix (/ L LSTEP))))
         (setq LSTEP (/ L CMAX))
         (setq RFL:ALIGNLIST (list (list 0.0 (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))))
         (setq P1 (nth 1 NODE))
         (setq C 1)
         (while (< C CMAX)
          (setq P2 (RFL:XY (list (* C LSTEP) 0.0)))
          (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
           (if (= nil OGLIST)
            (setq OGLIST (append OGLIST TMPLIST))
            (setq OGLIST (append OGLIST (cdr TMPLIST)))
           )
          )
          (setq C (+ C 1))
          (setq P1 P2)
         )
         (setq P2 (nth 2 NODE))
         (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
          (if (= nil OGLIST)
           (setq OGLIST (append OGLIST TMPLIST))
           (setq OGLIST (append OGLIST (cdr TMPLIST)))
          )
         )
        )
        (if (< (abs (last NODE)) RFL:TOL)
         (progn ; LINE
          (setq P1 (nth 1 NODE))
          (setq P2 (nth 2 NODE))
          (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
           (if (= nil OGLIST)
            (setq OGLIST (append OGLIST TMPLIST))
            (setq OGLIST (append OGLIST (cdr TMPLIST)))
           )
          )
         )
         (progn ; ARC
          (setq R (RFL:RADIUS (nth 1 NODE) (nth 2 NODE) (nth 3 NODE)))
          (setq ATOTAL (* 4 (atan (abs (nth 3 NODE)))))
          (setq L (* R ATOTAL))
          (setq ANG (atan (/ (sqrt (- (* 2.0 R OSTOL) (* OSTOL OSTOL))) (- R OSTOL))))
          (setq LSTEP (* 2.0 R ANG))
          (setq CMAX (+ 1 (fix (/ L LSTEP))))
          (setq LSTEP (/ L CMAX))
          (setq RFL:ALIGNLIST (list (list 0.0 (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))))
          (setq P1 (nth 1 NODE))
          (setq C 1)
          (while (< C CMAX)
           (setq P2 (RFL:XY (list (* C LSTEP) 0.0)))
           (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
            (if (= nil OGLIST)
             (setq OGLIST (append OGLIST TMPLIST))
             (setq OGLIST (append OGLIST (cdr TMPLIST)))
            )
           )
           (setq C (+ C 1))
           (setq P1 P2)
          )
          (setq P2 (nth 2 NODE))
          (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
           (if (= nil OGLIST)
            (setq OGLIST (append OGLIST TMPLIST))
            (setq OGLIST (append OGLIST (cdr TMPLIST)))
           )
          )
         )
        )
       )
      )
     )
     (if (/= nil OGLIST)
      (progn
       (command "._3DPOLY")
       (foreach NODE OGLIST
        (command NODE)
       )
       (command "")
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setq RFL:ALIGNLIST ALSAVE)
 (eval nil)
);
;
;     Program written by Robert Livingston 2014-11-24
;
;     DRAPEPOLY is a utility for draping a LWPolyline onto a surface to create a 3DPolyline
;
;
(defun C:DRAPEPOLY (/ ALSAVE CMDECHO ENT ENTLIST P)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ALSAVE RFL:ALIGNLIST)
 (princ "\NSelect LWPolyline : ")
 (setq ENT (entsel))
 (setq P (cadr ENT))
 (setq ENT (car ENT))
 (setq ENTLIST (entget ENT))
 (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
  (progn
   (command "._CONVERT" "P" "S" ENT "")
   (setq ENTLIST (entget ENT))
  )
 )
 (if (/= "LWPOLYLINE" (cdr (assoc 0 ENTLIST)))
  (princ "\n*** Not an usable POLYLINE! ***")
  (progn
   (if (< (distance P (cdr (assoc 10 ENTLIST)))
          (distance P (cdr (assoc 10 (reverse ENTLIST))))
       )
    (setq RFL:ALIGNLIST (RFL:ALIGNDEF ENT (cdr (assoc 10 ENTLIST)) 0.0))
    (setq RFL:ALIGNLIST (RFL:ALIGNDEF ENT (cdr (assoc 10 (reverse ENTLIST))) 0.0))
   )
   (C:DRAPEALIGN)
  )
 )
 (setq RFL:ALIGNLIST ALSAVE)
 (setvar "CMDECHO" CMDECHO)
 nil
)
;
;
;     Program written by Robert Livingston, 2011/11/22
;
;     RAB2C3D writes the current RFL alignment to a C3D Drawing.
;
;
(defun C:RAB2C3D (/ *error* ALIGNLISTSAVE ALIGNMENTNAME ALIGNMENTSTYLENAME ALIGNMENTLABELSTYLESETNAME BLKENT BLKENTLIST BULGE
                    C CCW CMAX GETOBAECC ID LANDPROFILESTYLENAME LO LS NAME NODE
                    OALIGNMENT OALIGNMENTENTITIES OALIGNMENTSTYLES OALIGNMENTLABELSTYLESETS OALIGNMENTSSITELESS OCIVILAPP ODOCUMENT OLANDPROFILESTYLES OPVIS
                    P1 P2 PLT PLTST PST PREVENT PVILISTSAVE SUPERLISTSAVE)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  ;(setq *error* nil)
  (setq RFL:ALIGNLIST ALIGNLISTSAVE)
  (setq RFL:PVILIST PVILISTSAVE)
  (setq RFL:SUPERLIST SUPERLISTSAVE)
  (princ msg)
 )

 (defun GETOBAECC (/ *acad* ACADACTIVEDOCUMENT ACADPROD ACADVER C3DOBJECT C3DDOC C3DSURFS C CMAX c3DSURF)
  (princ "\n")
  (setq ACADPROD (vlax-product-key))
  (setq ACADVER (RFL:ACADVER))
  (setq ACADPROD (strcat "AeccXUiLand.AeccApplication." ACADVER))
  (setq *acad* (vlax-get-acad-object))
  (vla-getinterfaceobject *acad* ACADPROD)
 )

 (command "._UNDO" "M")
 (setq ALIGNLISTSAVE RFL:ALIGNLIST)
 (setq PVILISTSAVE RFL:PVILIST)
 (setq SUPERLISTSAVE RFL:SUPERLIST)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block <return to use current alignment> : ")))
 (if (= nil BLKENT)
  (progn
   (setq ALIGNMENTNAME "RFL Alignment")
  )
  (progn
   (setq BLKENTLIST (entget BLKENT))
   (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
    (progn
     (RFL:RALIGNB BLKENT)
     (RFL:RPROFB BLKENT)
     (RFL:RSUPERB BLKENT)
     (setq BLKENT (entnext BLKENT))
     (setq BLKENTLIST (entget BLKENT))
     (setq ALIGNMENTNAME "")
     (while (and (= "ATTRIB" (cdr (assoc 0 BLKENTLIST))) (/= "TITLE" (cdr (assoc 2 BLKENTLIST))))
      (setq BLKENT (entnext BLKENT))
      (setq BLKENTLIST (entget BLKENT))
     )
     (if (= "TITLE" (cdr (assoc 2 BLKENTLIST)))
      (setq ALIGNMENTNAME (cdr (assoc 1 BLKENTLIST)))
     )
    )
    (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
   )
  )
 )

 (if (= nil RFL:ALIGNLIST)
  (princ "\n*****  NO RFL ALIGNMENT DEFINED  *****")
  (progn
   (textscr)
   (setq NAME (getstring T (strcat "\nEnter new alignment name <" ALIGNMENTNAME "> : ")))
   (if (= NAME "") (setq NAME ALIGNMENTNAME))
   (if (/= "" NAME)
    (progn
     (setq OCIVILAPP (GETOBAECC))
     (if (= nil OCIVILAPP)
      (alert "C3D not loaded!")
      (progn
       (setq ODOCUMENT (vlax-get-property OCIVILAPP "ActiveDocument"))
       (if (= nil ODOCUMENT)
        (alert "Error getting Document!")
        (progn
         (setq OALIGNMENTSTYLES (vlax-get-property ODOCUMENT "AlignmentStyles"))
         (if (= nil OALIGNMENTSTYLES)
          (alert "Error getting Alignment Styles!")
          (progn
           (setq CMAX (vlax-get-property OALIGNMENTSTYLES "Count"))
           (setq C 0)
           (while (< C CMAX)
            (princ (strcat (itoa (+ C 1)) " : " (vlax-get-property (vlax-get-property OALIGNMENTSTYLES "Item" C) "Name") "\n"))
            (setq C (+ C 1))
           )
           (setq C 0)
           (while (or (< C 1) (> C CMAX))
            (setq C (getint (strcat "Select Alignment Style < 1 to " (itoa CMAX) " > : ")))
           )
           (setq C (- C 1))
           (setq ALIGNMENTSTYLENAME (vlax-get-property (vlax-get-property OALIGNMENTSTYLES "Item" C) "Name"))
           (princ "\n")
           (setq OALIGNMENTLABELSTYLESETS (vlax-get-property ODOCUMENT "AlignmentLabelStyleSets"))
           (if (= nil OALIGNMENTLABELSTYLESETS)
            (alert "Error getting Alignment Label Style Sets!")
            (progn
             (setq CMAX (vlax-get-property OALIGNMENTLABELSTYLESETS "Count"))
             (setq C 0)
             (while (< C CMAX)
              (princ (strcat (itoa (+ C 1)) " : " (vlax-get-property (vlax-get-property OALIGNMENTLABELSTYLESETS "Item" C) "Name") "\n"))
              (setq C (+ C 1))
             )
             (setq C 0)
             (while (or (< C 1) (> C CMAX))
              (setq C (getint (strcat "Select Alignment Label Style Set < 1 to " (itoa CMAX) " > : ")))
             )
             (setq C (- C 1))
             (setq ALIGNMENTLABELSTYLESETNAME (vlax-get-property (vlax-get-property OALIGNMENTLABELSTYLESETS "Item" C) "Name"))
             (setq OALIGNMENTSSITELESS (vlax-get-property ODOCUMENT "AlignmentsSiteless"))
             (if (= nil OALIGNMENTSSITELESS)
              (alert "Error getting Alignments!")
              (progn
               (setq OALIGNMENT (vlax-invoke-method OALIGNMENTSSITELESS "Add" NAME (getvar "CLAYER") ALIGNMENTSTYLENAME ALIGNMENTLABELSTYLESETNAME))
               (if (= nil OALIGNMENT)
                (alert "Error creating new alignment!")
                (progn
                 (vlax-put-property OALIGNMENT "ReferencePointStation" (caar RFL:ALIGNLIST))
                 (setq OALIGNMENTENTITIES (vlax-get-property OALIGNMENT "Entities"))
                 (if (= nil OALIGNMENTENTITIES)
                  (alert "Error accessing entities!")
                  (progn
                   (setq PREVENT nil)
                   (setq C 0)
                   (while (< C (length RFL:ALIGNLIST))
                    (setq NODE (nth C RFL:ALIGNLIST))
                    (setq BULGE (nth 3 NODE))
                    (if (listp BULGE)
                     (progn  ;  Spiral
                      (setq P1 (nth 1 NODE))
                      (setq P2 (nth 2 NODE))
                      (setq PLT (nth 0 BULGE))
                      (setq PLTST (nth 1 BULGE))
                      (setq PST (nth 2 BULGE))
                      (setq LO (nth 3 BULGE))
                      (setq LS (- (RFL:GETSPIRALLS2 PLT PLTST PST) LO))
                      (if (> (distance P2 PLT) (distance P1 PLT))
                       (progn
                        (setq R2 (RFL:RADIUS P1 P2 BULGE))
                        (if (< LO RFL:TOLFINE)
                         (setq R1 0.0)
                         (setq R1 (/ (* R2 (RFL:GETSPIRALLS2 PLT PLTST PST)) LO))
                        )
                       )
                       (progn
                        (setq R1 (RFL:RADIUS P1 P2 BULGE))
                        (if (< LO RFL:TOLFINE)
                         (setq R2 0.0)
                         (setq R2 (/ (* R1 (RFL:GETSPIRALLS2 PLT PLTST PST)) LO))
                        )
                       )
                      )
                      (if (< (abs LO) RFL:TOLFINE) (setq LO 0.0))
                      (setq PLTST (RFL:GETSPIRALPI2 LO PLT PLTST PST))
                      (setq PT1 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
                      (vlax-safearray-put-element PT1 0 (car P1))
                      (vlax-safearray-put-element PT1 1 (cadr P1))
                      (vlax-safearray-put-element PT1 2 0.0)
                      (setq PT2 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
                      (vlax-safearray-put-element PT2 0 (car PLTST))
                      (vlax-safearray-put-element PT2 1 (cadr PLTST))
                      (vlax-safearray-put-element PT2 2 0.0)
                      (if (> (sin (- (angle PLTST P2) (angle P1 PLTST))) 0.0)
                       (setq CCW 0)
                       (setq CCW T)
                      )
                      (if (= nil PREVENT)
                       (setq ID 0)
                       (setq ID (vlax-get-property PREVENT "Id"))
                      )
                      (if (= 0.0 R1)
                       (setq PREVENT (vlax-invoke-method OALIGNMENTENTITIES "AddFixedSpiral1" ID PT1 PT2 R2 LS 1 CCW 1))
                       (if (= 0.0 R2)
                        (setq PREVENT (vlax-invoke-method OALIGNMENTENTITIES "AddFixedSpiral1" ID PT1 PT2 R1 LS 2 CCW 1))
                        (setq PREVENT (vlax-invoke-method OALIGNMENTENTITIES "AddFixedSpiral2" ID PT1 PT2 R1 R2 LS CCW 1))
                       )
                      )
                     )
                     (if (< (abs BULGE) RFL:TOLFINE)
                      (progn  ;  Tangent
                       (setq PT1 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
                       (vlax-safearray-put-element PT1 0 (car (nth 1 NODE)))
                       (vlax-safearray-put-element PT1 1 (cadr (nth 1 NODE)))
                       (vlax-safearray-put-element PT1 2 0.0)
                       (setq PT2 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
                       (vlax-safearray-put-element PT2 0 (car (nth 2 NODE)))
                       (vlax-safearray-put-element PT2 1 (cadr (nth 2 NODE)))
                       (vlax-safearray-put-element PT2 2 0.0)
                       (setq PREVENT (vlax-invoke-method OALIGNMENTENTITIES "AddFixedLine1" PT1 PT2))
                      )
                      (progn  ;  Arc
                       (setq PT1 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
                       (vlax-safearray-put-element PT1 0 (car (nth 1 NODE)))
                       (vlax-safearray-put-element PT1 1 (cadr (nth 1 NODE)))
                       (vlax-safearray-put-element PT1 2 0.0)
                       (setq PT2 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
                       (vlax-safearray-put-element PT2 0 (car (nth 2 NODE)))
                       (vlax-safearray-put-element PT2 1 (cadr (nth 2 NODE)))
                       (vlax-safearray-put-element PT2 2 0.0)
                       (setq PC (RFL:CENTER (nth 1 NODE) (nth 2 NODE) BULGE))
                       (setq PT3  (vlax-make-safearray vlax-vbDouble '(0 . 2)))
                       (vlax-safearray-put-element PT3 0 (car PC))
                       (vlax-safearray-put-element PT3 1 (cadr PC))
                       (vlax-safearray-put-element PT3 2 0.0)
                       (if (> BULGE 0.0) (setq CCW 0) (setq CCW T))
                       (setq PREVENT (vlax-invoke-method OALIGNMENTENTITIES "AddFixedCurve6" PT1 PT2 (RFL:RADIUS (nth 1 NODE) (nth 2 NODE) BULGE) CCW))
                      )
                     )
                    )
                    (setq C (+ C 1))
                   )
                   (if (/= nil RFL:PVILIST)
                    (progn
                     (setq OPROFILES (vlax-get-property OALIGNMENT "Profiles"))
                     (setq OLANDPROFILESTYLES (vlax-get-property ODOCUMENT "LandProfileStyles"))
                     (if (= nil OLANDPROFILESTYLES)
                      (alert "Error getting Profile Styles!")
                      (progn
                       (setq CMAX (vlax-get-property OLANDPROFILESTYLES "Count"))
                       (setq C 0)
                       (while (< C CMAX)
                        (princ (strcat (itoa (+ C 1)) " : " (vlax-get-property (vlax-get-property OLANDPROFILESTYLES "Item" C) "Name") "\n"))
                        (setq C (+ C 1))
                       )
                       (setq C 0)
                       (while (or (< C 1) (> C CMAX))
                        (setq C (getint (strcat "Select Profile Style < 1 to " (itoa CMAX) " > : ")))
                       )
                       (setq C (- C 1))
                       (setq LANDPROFILESTYLENAME (vlax-get-property (vlax-get-property OLANDPROFILESTYLES "Item" C) "Name"))
                       (princ "\n")
                       (setq OPROFILE (vlax-invoke-method OPROFILES "Add" NAME 2 LANDPROFILESTYLENAME))
                       (setq OPVIS (vlax-get-property OPROFILE "PVIs"))
                       (setq NODE (car RFL:PVILIST))
                       (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 1)
                       (setq NODE (last RFL:PVILIST))
                       (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 1)
                       (setq C 1)
                       (while (< C (- (length RFL:PVILIST) 1))
                        (setq NODE (nth C RFL:PVILIST))
                        (if (< (nth 3 NODE) RFL:TOLFINE)
                         (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 1)
                         (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 3 (nth 3 NODE))
                        )
                        (setq C (+ C 1))
                       )
                      )
                     )
                    )
                   )
;                   (if (/= nil RFL:SUPERLIST)
;                    (progn
;                     (setq OSUPERELEVATIONDATA (vlax-get-property OALIGNMENT "SuperelevationData"))
;                     (setq C 0)
;                     (while (< C (length RFL:SUPERLIST))
;                      (setq NODE (nth C RFL:SUPERLIST))
;                      (setq SUPERDATA (vlax-make-variant vlax-vbArray))
;                      (vlax-invoke-method OSUPERELEVATIONDATA "Add" (car NODE) SUPERDATA)
;                      (setq C (+ C 1))
;                     )
;                    )
;                   )
                  )
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (graphscr)
 (setq RFL:ALIGNLIST ALIGNLISTSAVE)
 (setq RFL:PVILIST PVILISTSAVE)
 (setq RFL:SUPERLIST SUPERLISTSAVE)
 (eval T)
);
;
;     Program written by Robert Livingston, 2016-11-02
;
;     WPROFC3D writes the current RFL profile as the design centerline of a selected C3D alignment
;
;
(defun C:WPROFC3D (/ C CMAX FLAG GETOBAECC LANDPROFILESTYLENAME NAME NODE OALIGNMENT OALIGNMENTS
                     OCIVILAPP ODOCUMENT OLANDPROFILESTYLES OPROFILE OPROFILES OPVIS PROFNAME TOL)
 (setq TOL 0.000001)
 (defun GETOBAECC (/ *acad* ACADACTIVEDOCUMENT ACADPROD ACADVER C3DOBJECT C3DDOC C3DSURFS C CMAX C3DSURF)
  (princ "\n")
  (setq ACADPROD (vlax-product-key))
  (setq ACADVER (RFL:ACADVER))
  (setq ACADPROD (strcat "AeccXUiLand.AeccApplication." ACADVER))
  (setq *acad* (vlax-get-acad-object))
  (vla-getinterfaceobject *acad* ACADPROD)
 )

 (if (/= nil RFL:PVILIST)
  (progn
   (setq OCIVILAPP (GETOBAECC))
   (if (= nil OCIVILAPP)
    (alert "C3D not loaded!")
    (progn
     (setq ODOCUMENT (vlax-get-property OCIVILAPP "ActiveDocument"))
     (if (= nil ODOCUMENT)
      (alert "Error getting Document!")
      (progn
       (setq OALIGNMENTS (vlax-get-property ODOCUMENT "AlignmentsSiteless"))
       (if (= nil OALIGNMENTS)
        (alert "Error getting Alignments!")
        (progn
         (textscr)
         (setq CMAX (vlax-get-property OALIGNMENTS "Count"))
         (setq C 0)
         (while (< C CMAX)
          (princ (strcat (itoa (+ C 1)) " : " (vlax-get-property (vlax-invoke-method OALIGNMENTS "Item" C) "Name") "\n"))
          (setq C (+ C 1))
         )
         (setq C 0)
         (while (or (< C 1) (> C CMAX))
          (setq C (getint (strcat "Select Alignment < 1 to " (itoa CMAX) " > : ")))
         )
         (setq C (- C 1))
         (setq OALIGNMENT (vlax-invoke-method OALIGNMENTS "Item" C))
         (setq NAME (vlax-get-property OALIGNMENT "Name"))
         (princ "\n")
         (setq OPROFILES (vlax-get-property OALIGNMENT "Profiles"))
         (setq PROFNAME (getstring T "\nEnter new profile name : "))
         (setq FLAG nil)
         (setq CMAX (vlax-get-property OPROFILES "Count"))
         (setq C 0)
         (while (< C CMAX)
          (if (= (strcase PROFNAME) (strcase (vlax-get-property (vlax-invoke-method OPROFILES "Item" C) "Name")))
           (setq FLAG T)
          )
          (setq C (1+ C))
         )
         (if FLAG
          (princ "\nProfile already exists for this alignment - you must enter a new name.")
          (progn
           (setq OLANDPROFILESTYLES (vlax-get-property ODOCUMENT "LandProfileStyles"))
           (if (= nil OLANDPROFILESTYLES)
            (alert "Error getting Profile Styles!")
            (progn
             (setq CMAX (vlax-get-property OLANDPROFILESTYLES "Count"))
             (setq C 0)
             (while (< C CMAX)
              (princ (strcat (itoa (+ C 1)) " : " (vlax-get-property (vlax-get-property OLANDPROFILESTYLES "Item" C) "Name") "\n"))
              (setq C (+ C 1))
             )
             (setq C 0)
             (while (or (< C 1) (> C CMAX))
              (setq C (getint (strcat "Select Profile Style < 1 to " (itoa CMAX) " > : ")))
             )
             (setq C (- C 1))
             (setq LANDPROFILESTYLENAME (vlax-get-property (vlax-get-property OLANDPROFILESTYLES "Item" C) "Name"))
             (princ "\n")
             (setq OPROFILE (vlax-invoke-method OPROFILES "Add" PROFNAME 2 LANDPROFILESTYLENAME))
             (setq OPVIS (vlax-get-property OPROFILE "PVIs"))
             (setq NODE (car RFL:PVILIST))
             (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 1)
             (setq NODE (last RFL:PVILIST))
             (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 1)
             (setq C 1)
             (while (< C (- (length RFL:PVILIST) 1))
              (setq NODE (nth C RFL:PVILIST))
              (if (< (nth 3 NODE) TOL)
               (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 1)
               (vlax-invoke-method OPVIS "Add" (nth 0 NODE) (nth 1 NODE) 3 (nth 3 NODE))
              )
              (setq C (+ C 1))
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
;
;
;     Program written by Robert Livingston, 2015-03-13
;
;     RFL:FIX+ modifies a text entity to adjust it's '+' to align with its insertion point.
;
;
(defun RFL:FIX+ (ENT / ANG ANG1 CODE ENTLIST D H P P0 STR TB TB1 TB2 W WL WP WR)
 (setq ENTLIST (entget ENT))
 (if (= "TEXT" (cdr (assoc 0 ENTLIST)))
  (if (/= nil (vl-string-search "+" (setq STR (cdr (assoc 1 ENTLIST)))))
   (progn
    (setq ANG (cdr (assoc 50 ENTLIST)))
    (if (or (/= 0 (cdr (assoc 72 ENTLIST))) (/= 0 (cdr (assoc 73 ENTLIST))))
     (setq CODE 11)
     (setq CODE 10)
    )
    (setq P (cdr (assoc CODE ENTLIST)))
    (setq P0 (cdr (assoc 10 ENTLIST)))
    (setq D (distance P0 P))
    (setq ANG1 (angle P0 P))
    (setq TB (textbox ENTLIST))
    (setq W (- (caadr TB) (caar TB)))
    (setq H (* D (sin (- ANG1 ANG))))
    (setq WP (* D (cos (- ANG1 ANG))))
    (setq TBL (textbox (subst (cons 1 (substr STR 1 (+ (vl-string-search "+" STR) 1))) (assoc 1 ENTLIST) ENTLIST)))
    (setq WL (- (caadr TBL) (caar TBL)))
    (setq TBR (textbox (subst (cons 1 (substr STR (+ (vl-string-search "+" STR) 1))) (assoc 1 ENTLIST) ENTLIST)))
    (setq WR (- (caadr TBR) (caar TBR)))
    (setq W+ (- (+ WR WL) W))
    (setq ENTLIST (subst (list CODE
                               (+ (car P) (* 1.0 (- WP (+ (- WL (/ W+ 2.0)) (caar TBL))) (cos ANG)))
                               (+ (cadr P) (* 1.0 (- WP (+ (- WL (/ W+ 2.0)) (caar TBL))) (sin ANG)))
                               (caddr P)
                         )
                         (assoc CODE ENTLIST)
                         ENTLIST
                  )
    )
    (entmod ENTLIST)
    (entupd ENT)
   )
  )
 )
)
;
;
;     Program written by Robert Livingston, 2015-10-09
;
;     GETxxxSUPER returns the design superelevation or Ls for a given radius and design speed
;
;
(setq RFL:TAC6TABLE (list (list 40
                                   (list 700 "NC" 0.0 0.0)
                                   (list 600 "NC" 120.0 120.0)
                                   (list 500 "RC" 100.0 100.0)
                                   (list 400 0.023 90.0 90.0)
                                   (list 350 0.025 90.0 90.0)
                                   (list 300 0.028 80.0 80.0)
                                   (list 250 0.031 75.0 80.0)
                                   (list 220 0.034 70.0 80.0)
                                   (list 200 0.036 70.0 75.0)
                                   (list 180 0.038 60.0 75.0)
                                   (list 160 0.04 60.0 75.0)
                                   (list 140 0.043 60.0 70.0)
                                   (list 120 0.046 60.0 65.0)
                                   (list 100 0.049 50.0 65.0)
                                   (list 90 0.051 50.0 60.0)
                                   (list 80 0.054 50.0 60.0)
                                   (list 70 0.056 50.0 60.0)
                                   (list 60 0.059 50.0 60.0)
                                   (list 55 0.06 50.0 60.0)
                          )
                          (list 50
                                   (list 1200 "NC" 0.0 0.0)
                                   (list 1000 "RC" 170.0 170.0)
                                   (list 900 "RC" 150.0 150.0)
                                   (list 800 "RC" 150.0 150.0)
                                   (list 700 0.021 140.0 140.0)
                                   (list 600 0.024 125.0 125.0)
                                   (list 500 0.027 120.0 120.0)
                                   (list 400 0.031 100.0 100.0)
                                   (list 350 0.034 100.0 100.0)
                                   (list 300 0.037 90.0 100.0)
                                   (list 250 0.04 85.0 90.0)
                                   (list 220 0.043 80.0 90.0)
                                   (list 200 0.045 75.0 90.0)
                                   (list 180 0.047 70.0 90.0)
                                   (list 160 0.049 70.0 85.0)
                                   (list 140 0.052 65.0 80.0)
                                   (list 120 0.055 65.0 75.0)
                                   (list 100 0.058 65.0 70.0)
                                   (list 90 0.060 65.0 70.0)
                          )
                          (list 60
                                   (list 2000 "NC" 0.0 0.0)
                                   (list 1500 "RC" 225.0 225.0)
                                   (list 1200 "RC" 200.0 200.0)
                                   (list 1000 0.021 175.0 175.0)
                                   (list 900 0.023 175.0 175.0)
                                   (list 800 0.025 160.0 160.0)
                                   (list 700 0.027 150.0 150.0)
                                   (list 600 0.03 140.0 140.0)
                                   (list 500 0.034 125.0 125.0)
                                   (list 400 0.038 115.0 120.0)
                                   (list 350 0.041 110.0 115.0)
                                   (list 300 0.044 100.0 110.0)
                                   (list 250 0.048 90.0 100.0)
                                   (list 220 0.05 90.0 100.0)
                                   (list 200 0.052 85.0 100.0)
                                   (list 180 0.054 85.0 90.0)
                                   (list 160 0.056 85.0 90.0)
                                   (list 140 0.059 85.0 90.0)
                                   (list 130 0.06 85.0 90.0)
                          )
                          (list 70
                                   (list 3000 "NC" 0.0 0.0)
                                   (list 2000 "RC" 275.0 275.0)
                                   (list 1500 "RC" 250.0 250.0)
                                   (list 1200 0.023 225.0 225.0)
                                   (list 1000 0.027 200.0 200.0)
                                   (list 900 0.029 180.0 180.0)
                                   (list 800 0.031 175.0 175.0)
                                   (list 700 0.034 175.0 175.0)
                                   (list 600 0.037 150.0 150.0)
                                   (list 500 0.041 150.0 150.0)
                                   (list 400 0.045 125.0 135.0)
                                   (list 350 0.048 120.0 125.0)
                                   (list 300 0.051 120.0 125.0)
                                   (list 250 0.055 110.0 120.0)
                                   (list 220 0.057 110.0 110.0)
                                   (list 200 0.059 110.0 110.0)
                                   (list 190 0.060 110.0 110.0)
                          )
                          (list 80
                                   (list 3000 "NC" 0.0 0.0)
                                   (list 2000 "RC" 300.0 300.0)
                                   (list 1500 0.024 250.0 250.0)
                                   (list 1200 0.028 225.0 225.0)
                                   (list 1000 0.032 200.0 200.0)
                                   (list 900 0.034 200.0 200.0)
                                   (list 800 0.036 175.0 175.0)
                                   (list 700 0.039 175.0 175.0)
                                   (list 600 0.042 175.0 175.0)
                                   (list 500 0.046 150.0 160.0)
                                   (list 400 0.051 135.0 150.0)
                                   (list 350 0.054 125.0 140.0)
                                   (list 300 0.057 125.0 135.0)
                                   (list 250 0.06 125.0 125.0)
                          )
                          (list 90
                                   (list 4000 "NC" 0.0 0.0)
                                   (list 3000 "RC" 390.0 400.0)
                                   (list 2000 0.023 300.0 350.0)
                                   (list 1500 0.029 270.0 275.0)
                                   (list 1200 0.033 240.0 240.0)
                                   (list 1000 0.037 225.0 225.0)
                                   (list 900 0.039 200.0 200.0)
                                   (list 800 0.042 200.0 200.0)
                                   (list 700 0.045 185.0 195.0)
                                   (list 600 0.048 175.0 185.0)
                                   (list 500 0.052 160.0 175.0)
                                   (list 400 0.057 160.0 165.0)
                                   (list 350 0.059 160.0 160.0)
                                   (list 340 0.06 160.0 160.0)
                          )
                          (list 100
                                   (list 5000 "NC" 0.0 0.0)
                                   (list 4000 "RC" 475.0 475.0)
                                   (list 3000 "RC" 410.0 410.0)
                                   (list 2000 0.03 335.0 335.0)
                                   (list 1500 0.029 290.0 290.0)
                                   (list 1200 0.034 260.0 260.0)
                                   (list 1000 0.04 235.0 235.0)
                                   (list 900 0.043 225.0 225.0)
                                   (list 800 0.046 210.0 215.0)
                                   (list 700 0.05 200.0 210.0)
                                   (list 600 0.054 190.0 200.0)
                                   (list 500 0.059 190.0 190.0)
                                   (list 440 0.06 190.0 190.0)
                          )
                          (list 110
                                   (list 7000 "NC" 0.0 0.0)
                                   (list 5000 "RC" 555.0 555.0)
                                   (list 4000 "RC" 495.0 495.0)
                                   (list 3000 0.02 430.0 430.0)
                                   (list 2000 0.029 350.0 350.0)
                                   (list 1500 0.036 305.0 305.0)
                                   (list 1200 0.043 270.0 270.0)
                                   (list 1000 0.048 245.0 255.0)
                                   (list 900 0.051 235.0 250.0)
                                   (list 800 0.054 220.0 240.0)
                                   (list 700 0.058 220.0 235.0)
                                   (list 600 0.06 220.0 220.0)
                          )
                          (list 120
                                   (list 7000 "NC" 0.0 0.0)
                                   (list 5000 "RC" 580.0 580.0)
                                   (list 4000 "RC" 515.0 515.0)
                                   (list 3000 0.024 450.0 450.0)
                                   (list 2000 0.034 365.0 365.0)
                                   (list 1500 0.042 315.0 315.0)
                                   (list 1200 0.049 285.0 290.0)
                                   (list 1000 0.054 260.0 280.0)
                                   (list 900 0.057 250.0 270.0)
                                   (list 800 0.059 250.0 260.0)
                                   (list 750 0.06 250.0 260.0)
                          )
                          (list 130
                                   (list 10000 "NC" 0.0 0.0)
                                   (list 7000 "RC" 710.0 710.0)
                                   (list 5000 "RC" 600.0 600.0)
                                   (list 4000 0.023 540.0 540.0)
                                   (list 3000 0.028 465.0 465.0)
                                   (list 2000 0.04 380.0 380.0)
                                   (list 1500 0.049 330.0 335.0)
                                   (list 1200 0.055 295.0 320.0)
                                   (list 1000 0.058 280.0 300.0)
                                   (list 950 0.06 280.0 300.0)
                          )
                    )
)
(setq RFL:BC6TABLE (list (list 40
                                  (list 700 "NC" 0.0 0.0 0.0)
                                  (list 500 "RC" 30.0 30.0 30.0)
                                  (list 475 0.02 30.0 30.0 30.0)
                                  (list 450 0.021 30.0 30.0 30.0)
                                  (list 425 0.022 30.0 30.0 30.0)
                                  (list 400 0.023 30.0 30.0 30.0)
                                  (list 380 0.024 30.0 30.0 30.0)
                                  (list 360 0.025 30.0 30.0 30.0)
                                  (list 340 0.026 30.0 30.0 30.0)
                                  (list 320 0.027 30.0 30.0 30.0)
                                  (list 300 0.028 30.0 30.0 30.0)
                                  (list 290 0.028 30.0 30.0 30.0)
                                  (list 280 0.029 30.0 30.0 30.0)
                                  (list 270 0.03 30.0 30.0 30.0)
                                  (list 260 0.03 30.0 30.0 30.0)
                                  (list 250 0.031 30.0 30.0 40.0)
                                  (list 240 0.032 30.0 30.0 40.0)
                                  (list 230 0.033 30.0 30.0 40.0)
                                  (list 220 0.034 30.0 30.0 40.0)
                                  (list 210 0.035 30.0 30.0 40.0)
                                  (list 200 0.036 30.0 30.0 40.0)
                                  (list 190 0.037 30.0 30.0 40.0)
                                  (list 180 0.038 30.0 30.0 40.0)
                                  (list 170 0.039 30.0 30.0 40.0)
                                  (list 160 0.04 30.0 30.0 40.0)
                                  (list 150 0.041 30.0 30.0 50.0)
                                  (list 145 0.042 30.0 40.0 50.0)
                                  (list 140 0.043 30.0 40.0 50.0)
                                  (list 135 0.044 30.0 40.0 50.0)
                                  (list 130 0.044 30.0 40.0 50.0)
                                  (list 125 0.045 30.0 40.0 50.0)
                                  (list 120 0.046 30.0 40.0 50.0)
                                  (list 115 0.047 30.0 40.0 50.0)
                                  (list 110 0.048 30.0 40.0 50.0)
                                  (list 105 0.049 30.0 40.0 50.0)
                                  (list 100 0.05 30.0 40.0 50.0)
                                  (list 95 0.051 30.0 40.0 60.0)
                                  (list 90 0.052 30.0 40.0 60.0)
                                  (list 85 0.053 30.0 40.0 60.0)
                                  (list 80 0.054 30.0 40.0 60.0)
                                  (list 75 0.055 30.0 50.0 60.0)
                                  (list 70 0.056 40.0 50.0 60.0)
                                  (list 65 0.058 40.0 50.0 60.0)
                                  (list 60 0.059 40.0 50.0 60.0)
                                  (list 55 0.06 40.0 50.0 60.0)
                         )
                         (list 50
                                  (list 1100 "NC" 0.0 0.0 0.0)
                                  (list 750 "RC" 30.0 30.0 30.0)
                                  (list 700 0.021 30.0 30.0 30.0)
                                  (list 650 0.022 30.0 30.0 30.0)
                                  (list 600 0.023 30.0 30.0 30.0)
                                  (list 550 0.025 30.0 30.0 30.0)
                                  (list 500 0.027 30.0 30.0 30.0)
                                  (list 475 0.028 30.0 30.0 30.0)
                                  (list 450 0.029 30.0 30.0 30.0)
                                  (list 425 0.03 30.0 30.0 40.0)
                                  (list 400 0.031 30.0 30.0 40.0)
                                  (list 380 0.032 30.0 30.0 40.0)
                                  (list 360 0.033 30.0 30.0 40.0)
                                  (list 340 0.034 30.0 30.0 40.0)
                                  (list 320 0.035 30.0 30.0 40.0)
                                  (list 300 0.037 30.0 30.0 40.0)
                                  (list 290 0.037 30.0 30.0 40.0)
                                  (list 280 0.038 30.0 30.0 50.0)
                                  (list 270 0.039 30.0 40.0 50.0)
                                  (list 260 0.04 30.0 40.0 50.0)
                                  (list 250 0.04 30.0 40.0 50.0)
                                  (list 240 0.041 30.0 40.0 50.0)
                                  (list 230 0.042 30.0 40.0 50.0)
                                  (list 220 0.043 30.0 40.0 50.0)
                                  (list 210 0.044 30.0 40.0 50.0)
                                  (list 200 0.045 30.0 40.0 50.0)
                                  (list 190 0.046 30.0 40.0 50.0)
                                  (list 180 0.047 30.0 40.0 60.0)
                                  (list 170 0.048 30.0 40.0 60.0)
                                  (list 160 0.049 30.0 40.0 60.0)
                                  (list 150 0.051 30.0 50.0 60.0)
                                  (list 145 0.051 30.0 50.0 60.0)
                                  (list 140 0.052 30.0 50.0 60.0)
                                  (list 135 0.053 40.0 50.0 60.0)
                                  (list 130 0.054 40.0 50.0 60.0)
                                  (list 125 0.054 40.0 50.0 60.0)
                                  (list 120 0.055 40.0 50.0 60.0)
                                  (list 115 0.056 40.0 50.0 60.0)
                                  (list 110 0.057 40.0 50.0 70.0)
                                  (list 105 0.057 50.0 50.0 70.0)
                                  (list 100 0.058 50.0 50.0 70.0)
                                  (list 95 0.059 50.0 50.0 70.0)
                                  (list 90 0.06 50.0 50.0 70.0)
                         )
                         (list 60
                                  (list 2000 "NC" 0.0 0.0 0.0)
                                  (list 1100 "RC" 40.0 40.0 40.0)
                                  (list 1050 0.02 40.0 40.0 40.0)
                                  (list 1000 0.021 40.0 40.0 40.0)
                                  (list 950 0.022 40.0 40.0 40.0)
                                  (list 900 0.023 40.0 40.0 40.0)
                                  (list 850 0.024 40.0 40.0 40.0)
                                  (list 800 0.025 40.0 40.0 40.0)
                                  (list 750 0.026 40.0 40.0 40.0)
                                  (list 700 0.027 40.0 40.0 40.0)
                                  (list 650 0.029 40.0 40.0 40.0)
                                  (list 600 0.03 40.0 40.0 40.0)
                                  (list 550 0.032 40.0 40.0 40.0)
                                  (list 500 0.034 40.0 40.0 40.0)
                                  (list 475 0.035 40.0 40.0 40.0)
                                  (list 450 0.036 40.0 40.0 50.0)
                                  (list 425 0.037 40.0 40.0 50.0)
                                  (list 400 0.038 40.0 40.0 50.0)
                                  (list 380 0.039 40.0 40.0 50.0)
                                  (list 360 0.041 40.0 40.0 50.0)
                                  (list 340 0.042 40.0 40.0 50.0)
                                  (list 320 0.043 40.0 40.0 50.0)
                                  (list 300 0.044 40.0 40.0 60.0)
                                  (list 290 0.045 40.0 40.0 60.0)
                                  (list 280 0.046 40.0 40.0 60.0)
                                  (list 270 0.047 40.0 40.0 60.0)
                                  (list 260 0.047 40.0 50.0 60.0)
                                  (list 250 0.048 40.0 50.0 60.0)
                                  (list 240 0.049 40.0 50.0 60.0)
                                  (list 230 0.05 40.0 50.0 60.0)
                                  (list 220 0.051 40.0 50.0 60.0)
                                  (list 210 0.052 40.0 50.0 60.0)
                                  (list 200 0.053 40.0 50.0 70.0)
                                  (list 190 0.054 40.0 50.0 70.0)
                                  (list 180 0.055 50.0 50.0 70.0)
                                  (list 170 0.056 50.0 50.0 70.0)
                                  (list 160 0.057 50.0 50.0 70.0)
                                  (list 150 0.058 50.0 60.0 70.0)
                                  (list 145 0.059 60.0 60.0 70.0)
                                  (list 140 0.059 60.0 60.0 70.0)
                                  (list 135 0.06 60.0 60.0 70.0)
                                  (list 130 0.06 60.0 60.0 70.0)
                         )
                         (list 70
                                  (list 3000 "NC" 0.0 0.0 0.0)
                                  (list 1500 "RC" 40.0 40.0 40.0)
                                  (list 1300 0.022 40.0 40.0 40.0)
                                  (list 1250 0.023 40.0 40.0 40.0)
                                  (list 1200 0.023 40.0 40.0 40.0)
                                  (list 1150 0.024 40.0 40.0 40.0)
                                  (list 1100 0.025 40.0 40.0 40.0)
                                  (list 1050 0.026 40.0 40.0 40.0)
                                  (list 1000 0.027 40.0 40.0 40.0)
                                  (list 950 0.027 40.0 40.0 40.0)
                                  (list 900 0.028 40.0 40.0 40.0)
                                  (list 850 0.03 40.0 40.0 40.0)
                                  (list 800 0.031 40.0 40.0 40.0)
                                  (list 750 0.032 40.0 40.0 40.0)
                                  (list 700 0.033 40.0 40.0 50.0)
                                  (list 650 0.035 40.0 40.0 50.0)
                                  (list 600 0.037 40.0 40.0 50.0)
                                  (list 550 0.038 40.0 40.0 50.0)
                                  (list 500 0.04 40.0 40.0 60.0)
                                  (list 475 0.041 40.0 40.0 60.0)
                                  (list 450 0.043 40.0 40.0 60.0)
                                  (list 425 0.044 40.0 50.0 60.0)
                                  (list 400 0.045 40.0 50.0 60.0)
                                  (list 380 0.046 40.0 50.0 60.0)
                                  (list 360 0.047 40.0 50.0 60.0)
                                  (list 340 0.048 40.0 50.0 70.0)
                                  (list 320 0.05 40.0 50.0 70.0)
                                  (list 300 0.051 40.0 50.0 70.0)
                                  (list 290 0.052 50.0 50.0 70.0)
                                  (list 280 0.052 50.0 50.0 70.0)
                                  (list 270 0.053 50.0 60.0 70.0)
                                  (list 260 0.054 50.0 60.0 70.0)
                                  (list 250 0.055 50.0 60.0 70.0)
                                  (list 240 0.055 50.0 60.0 80.0)
                                  (list 230 0.056 60.0 60.0 80.0)
                                  (list 220 0.057 60.0 60.0 80.0)
                                  (list 210 0.058 60.0 60.0 80.0)
                                  (list 200 0.059 60.0 60.0 80.0)
                                  (list 190 0.06 70.0 70.0 80.0)
                         )
                         (list 80
                                  (list 3000 "NC" 0.0 0.0 0.0)
                                  (list 2000 "RC" 50.0 50.0 50.0)
                                  (list 1500 0.024 50.0 50.0 50.0)
                                  (list 1300 0.027 50.0 50.0 50.0)
                                  (list 1250 0.027 50.0 50.0 50.0)
                                  (list 1200 0.028 50.0 50.0 50.0)
                                  (list 1150 0.029 50.0 50.0 50.0)
                                  (list 1100 0.03 50.0 50.0 50.0)
                                  (list 1050 0.031 50.0 50.0 50.0)
                                  (list 1000 0.032 50.0 50.0 50.0)
                                  (list 950 0.033 50.0 50.0 50.0)
                                  (list 900 0.034 50.0 50.0 50.0)
                                  (list 850 0.035 50.0 50.0 50.0)
                                  (list 800 0.036 50.0 50.0 60.0)
                                  (list 750 0.038 50.0 50.0 60.0)
                                  (list 700 0.039 50.0 50.0 60.0)
                                  (list 650 0.041 50.0 50.0 60.0)
                                  (list 600 0.042 50.0 50.0 60.0)
                                  (list 550 0.044 50.0 50.0 70.0)
                                  (list 500 0.046 50.0 50.0 70.0)
                                  (list 475 0.047 50.0 50.0 70.0)
                                  (list 450 0.049 50.0 60.0 70.0)
                                  (list 425 0.05 50.0 60.0 70.0)
                                  (list 400 0.051 50.0 60.0 80.0)
                                  (list 380 0.052 50.0 60.0 80.0)
                                  (list 360 0.053 50.0 60.0 80.0)
                                  (list 340 0.054 60.0 60.0 80.0)
                                  (list 320 0.056 60.0 60.0 80.0)
                                  (list 300 0.057 60.0 60.0 80.0)
                                  (list 290 0.057 70.0 70.0 90.0)
                                  (list 280 0.058 70.0 70.0 90.0)
                                  (list 270 0.059 70.0 70.0 90.0)
                                  (list 260 0.059 70.0 70.0 90.0)
                                  (list 250 0.06 80.0 80.0 90.0)
                         )
                         (list 90
                                  (list 5000 "NC" 0.0 0.0 0.0)
                                  (list 3000 "RC" 50.0 50.0 50.0)
                                  (list 2000 0.023 50.0 50.0 50.0)
                                  (list 1500 0.029 50.0 50.0 50.0)
                                  (list 1300 0.031 50.0 50.0 50.0)
                                  (list 1250 0.032 50.0 50.0 50.0)
                                  (list 1200 0.033 50.0 50.0 50.0)
                                  (list 1150 0.034 50.0 50.0 50.0)
                                  (list 1100 0.035 50.0 50.0 60.0)
                                  (list 1050 0.036 50.0 50.0 60.0)
                                  (list 1000 0.037 50.0 50.0 60.0)
                                  (list 950 0.038 50.0 50.0 60.0)
                                  (list 900 0.039 50.0 50.0 60.0)
                                  (list 850 0.04 50.0 50.0 60.0)
                                  (list 800 0.042 50.0 50.0 70.0)
                                  (list 750 0.043 50.0 50.0 70.0)
                                  (list 700 0.045 50.0 50.0 70.0)
                                  (list 650 0.046 50.0 60.0 70.0)
                                  (list 600 0.048 50.0 60.0 80.0)
                                  (list 550 0.05 50.0 60.0 80.0)
                                  (list 500 0.052 60.0 60.0 80.0)
                                  (list 475 0.053 60.0 60.0 80.0)
                                  (list 450 0.054 60.0 60.0 80.0)
                                  (list 425 0.055 60.0 70.0 90.0)
                                  (list 400 0.057 70.0 70.0 90.0)
                                  (list 380 0.058 70.0 70.0 90.0)
                                  (list 360 0.059 80.0 80.0 90.0)
                                  (list 340 0.06 80.0 80.0 90.0)
                         )
                         (list 100
                                   (list 5000 "NC" 0.0 0.0 0.0)
                                   (list 3000 "RC" 60.0 60.0 60.0)
                                   (list 2000 0.027 60.0 60.0 60.0)
                                   (list 1500 0.033 60.0 60.0 60.0)
                                   (list 1300 0.036 60.0 60.0 60.0)
                                   (list 1250 0.037 60.0 60.0 60.0)
                                   (list 1200 0.038 60.0 60.0 60.0)
                                   (list 1150 0.039 60.0 60.0 70.0)
                                   (list 1100 0.04 60.0 60.0 70.0)
                                   (list 1050 0.041 60.0 60.0 70.0)
                                   (list 1000 0.042 60.0 60.0 70.0)
                                   (list 950 0.043 60.0 60.0 70.0)
                                   (list 900 0.044 60.0 60.0 70.0)
                                   (list 850 0.046 60.0 60.0 80.0)
                                   (list 800 0.047 60.0 60.0 80.0)
                                   (list 750 0.048 60.0 60.0 80.0)
                                   (list 700 0.05 60.0 60.0 80.0)
                                   (list 650 0.052 60.0 60.0 90.0)
                                   (list 600 0.053 60.0 70.0 90.0)
                                   (list 550 0.055 70.0 70.0 90.0)
                                   (list 500 0.057 70.0 70.0 90.0)
                                   (list 475 0.058 80.0 80.0 100.0)
                                   (list 450 0.059 80.0 80.0 100.0)
                                   (list 440 0.06 80.0 80.0 100.0)
                         )
                         (list 110
                                   (list 8000 "NC" 0.0 0.0 0.0)
                                   (list 5000 "RC" 60.0 60.0 60.0)
                                   (list 3000 0.024 60.0 60.0 60.0)
                                   (list 2000 0.032 60.0 60.0 60.0)
                                   (list 1500 0.038 60.0 60.0 70.0)
                                   (list 1300 0.042 60.0 60.0 70.0)
                                   (list 1250 0.042 60.0 60.0 80.0)
                                   (list 1200 0.043 60.0 60.0 80.0)
                                   (list 1150 0.044 60.0 60.0 80.0)
                                   (list 1100 0.046 60.0 60.0 80.0)
                                   (list 1050 0.047 60.0 60.0 80.0)
                                   (list 1000 0.048 60.0 60.0 80.0)
                                   (list 950 0.049 60.0 70.0 90.0)
                                   (list 900 0.05 60.0 70.0 90.0)
                                   (list 850 0.052 60.0 70.0 90.0)
                                   (list 800 0.053 60.0 70.0 90.0)
                                   (list 750 0.055 70.0 70.0 100.0)
                                   (list 700 0.056 70.0 80.0 100.0)
                                   (list 650 0.058 80.0 80.0 100.0)
                                   (list 600 0.06 80.0 80.0 110.0)
                         )
                         (list 120
                                   (list 8000 "NC" 0.0 0.0 0.0)
                                   (list 5000 "RC" 70.0 70.0 70.0)
                                   (list 3000 0.027 70.0 70.0 70.0)
                                   (list 2000 0.036 70.0 70.0 70.0)
                                   (list 1500 0.043 70.0 70.0 80.0)
                                   (list 1300 0.047 70.0 70.0 90.0)
                                   (list 1250 0.048 70.0 70.0 90.0)
                                   (list 1200 0.049 70.0 70.0 90.0)
                                   (list 1150 0.05 70.0 70.0 90.0)
                                   (list 1100 0.051 70.0 70.0 90.0)
                                   (list 1050 0.052 70.0 70.0 100.0)
                                   (list 1000 0.053 70.0 70.0 100.0)
                                   (list 950 0.054 70.0 80.0 100.0)
                                   (list 900 0.056 70.0 80.0 100.0)
                                   (list 850 0.057 80.0 80.0 110.0)
                                   (list 800 0.059 80.0 80.0 110.0)
                                   (list 760 0.06 80.0 80.0 110.0)
                         )
                   )
)
(defun RFL:GETTACSUPER (R VDES / C NODE S STABLE TOL)
 (setq VDES (fix VDES))
 (setq R (float R))
 (setq STABLE (cdr (assoc VDES RFL:TAC6TABLE)))
 (if (= nil STABLE)
  nil
  (progn
   (setq TOL 0.00000001)
   (if (< (abs R) TOL)
    (setq S (cadar STABLE))
    (setq S nil)
   )
   (setq C 0)
   (while (and (= nil S) (< C (length STABLE)))
    (progn
     (if (>= (abs R) (car (nth C STABLE)))
      (setq S (cadr (nth C STABLE)))
     )
     (setq C (+ C 1))
    )
   )
   (if (= nil S)
    (setq S (cadr (last STABLE)))
   )
   (if (= "NC" S)
    (list -2.0 -2.0)
    (if (= "RC" S)
     (if (< R 0.0)
      (list -2.0 2.0)
      (list 2.0 -2.0)
     )
     (if (< R 0.0)
      (list (* 100.0 S) (* -100.0 S))
      (list (* -100.0 S) (* 100.0 S))
     )
    )
   )
  )
 )
)
(defun RFL:GETBCSUPER (R VDES / C NODE S STABLE TOL)
 (setq VDES (fix VDES))
 (setq R (float R))
 (setq STABLE (cdr (assoc VDES RFL:BC6TABLE)))
 (if (= nil STABLE)
  nil
  (progn
   (setq TOL 0.00000001)
   (if (< (abs R) TOL)
    (setq S (cadar STABLE))
    (setq S nil)
   )
   (setq C 0)
   (while (and (= nil S) (< C (length STABLE)))
    (progn
     (if (>= (abs R) (car (nth C STABLE)))
      (setq S (cadr (nth C STABLE)))
     )
     (setq C (+ C 1))
    )
   )
   (if (= nil S)
    (setq S (cadr (last STABLE)))
   )
   (if (= "NC" S)
    (list -2.0 -2.0)
    (if (= "RC" S)
     (if (< R 0.0)
      (list -2.0 2.0)
      (list 2.0 -2.0)
     )
     (if (< R 0.0)
      (list (* 100.0 S) (* -100.0 S))
      (list (* -100.0 S) (* 100.0 S))
     )
    )
   )
  )
 )
)
;
;
;     Program written by Robert Livingston, 2016-09-23
;
;     RFL:INTERS returns the intersection of a line defined by P1/P2 and an RFL alignment
;
;
(defun RFL:ALINTERS (P1 P2 RFL:ALIGNLIST / ALSAVE C OS P SWAP TOL)
 (setq TOL 0.00001)
 (defun SWAP (/ TMP)
  (setq TMP RFL:ALIGNLIST RFL:ALIGNLIST ALSAVE ALSAVE TMP)
 )
 (setq C 0)
 (setq P (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))
 (setq ALSAVE (list (list 0.0 P1 P2 0.0)))
 (setq P (RFL:STAOFF P))
 (while (and P
             (> (abs (cadr P)) TOL)
             (< C 100)
        )
  (setq P (RFL:XY (list (car P) 0.0)))
  (SWAP)
  (setq P (RFL:STAOFF P))
  (setq C (+ C 1))
  (if (>= C 100)
   (princ (strcat "\n*** Warning - Maximum number of iterations reached at station " (rtos STA) "\n"))
  )
 )
 (if P (setq P (RFL:XY (list (car P) 0.0))))
 P
)
(defun RFL:INTERS2 (NODE1 NODE2 / ANG1 ANG2 A B C CHECKARC CHECKLINE M P1 P2 P11 P12 BULGE1 P21 P22 BULGE2 P1C P2C PM P1M P2M R1 R2 TMP X Y)
 (defun CHECKLINE (P P1 P2)
  (if (or (> (distance P P1) (distance P1 P2)) (> (distance P P2) (distance P1 P2)))
   (eval nil)
   (setq P P)
  )
 )
 (defun CHECKARC (P PC A1 A2 BULGE / A)
  (setq A (angle PC P))
  (if (> BULGE 0.0)
   (progn
    (if (> A1 A2)
     (progn
      (setq A1 (- A1 pi pi))
      (if (> A pi) (setq A (- A pi pi)))
     )
    )
    (if (and (> A A1) (< A A2))
     (setq P P)
     (eval nil)
    )
   )
   (progn
    (if (> A2 A1)
     (progn
      (setq A2 (- A2 pi pi))
      (if (> A pi) (setq A (- A pi pi)))
     )
    )
    (if (and (> A A2) (< A A1))
     (setq P P)
     (eval nil)
    )
   )
  )
 )
 (if (or (listp (last NODE1)) (listp (last NODE2)))
  (progn
   (princ "*** WILL NOT EVALUATE FOR SPIRAL! ***")
   (eval nil)
  )
  (progn
    (setq P11 (nth 1 NODE1))
    (setq P12 (nth 2 NODE1))
    (setq BULGE1 (nth 3 NODE1))
    (setq P21 (nth 1 NODE2))
    (setq P22 (nth 2 NODE2))
    (setq BULGE2 (nth 3 NODE2))
   (if (and (< (abs BULGE1) RFL:TOL) (< (abs BULGE2) RFL:TOL))
    (progn
;  LINE-LINE
     (inters P11 P12 P21 P22 T)
    )
    (progn
     (if (and (> (abs BULGE1) RFL:TOL) (> (abs BULGE2) RFL:TOL))
      (progn
;  ARC-ARC
       (princ "*** WILL NOT EVALUATE FOR ARC-ARC! ***")
       (eval nil)
      )
      (progn
;  LINE-ARC
       (if (> (abs BULGE1) RFL:TOL)
        (progn
         (setq TMP P11 P11 P21 P21 TMP)
         (setq TMP P12 P12 P22 P22 TMP)
         (setq TMP BULGE1 BULGE1 BULGE2 BULGE2 TMP)
        )
       )
       (setq P2C (RFL:CENTER P21 P22 BULGE2))
       (setq R2 (RFL:RADIUS P21 P22 BULGE2))
       (setq ANG1 (angle P2C P21))
       (setq ANG2 (angle P2C P22))
       (setq A (distance P2C P11))
       (setq B (distance P2C P12))
       (setq C (distance P11 P12))
       (setq M (/ (- (* B B) (* A A) (* C C)) (* -2.0 C)))
       (setq P1M (list (+ (car P11) (* (/ M C) (- (car P12) (car P11))))
                       (+ (cadr P11) (* (/ M C) (- (cadr P12) (cadr P11))))
                 )
       )
       (if (> (distance P2C P1M) R2)
        (progn
         (eval nil)
        )
        (if (< (abs (- (distance P2C P1M) R2)) RFL:TOL)
         (progn
;          (CHECK P1M P2C ANG1 ANG2)
;  TANGENT TO ARC (work in progress)
          (princ "*** WILL NOT EVALUATE FOR Sightline tangent to arc! ***")
          (eval nil)
         )
         (progn
          (setq Y (distance P2C P1M))
          (setq X (sqrt (- (* R2 R2) (* Y Y))))
          (setq P1 (list (+ (car P11) (* (/ (- M X) C) (- (car P12) (car P11))))
                         (+ (cadr P11) (* (/ (- M X) C) (- (cadr P12) (cadr P11))))
                   )
          )
          (setq P2 (list (+ (car P11) (* (/ (+ M X) C) (- (car P12) (car P11))))
                         (+ (cadr P11) (* (/ (+ M X) C) (- (cadr P12) (cadr P11))))
                   )
          )
          (setq P1 (CHECKLINE P1 P11 P12))
          (if (/= P1 nil) (setq P1 (CHECKARC P1 P2C ANG1 ANG2 BULGE2)))
          (setq P2 (CHECKLINE P2 P11 P12))
          (if (/= P2 nil) (setq P2 (CHECKARC P2 P2C ANG1 ANG2 BULGE2)))
          (if (and (= nil P1) (= nil P2))
           (eval nil)
           (if (= P2 nil)
            (setq P1 P1)
            (if (= P1 nil)
             (setq P2 P2)
             (list P1 P2)
            )
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
);
;
;     Program written by Robert Livingston, 2017-04-10
;
;     RFL:MIDPLIST computes a the mid points between 2 point lists
;
;
(defun RFL:MIDPLIST (PLIST1 PLIST2 / 2D D D1 D2 NODE P1 P2 PLAST PLISTM TMP)
 (setq 2D nil)
 (if (or (= nil (caddar PLIST1))
         (= nil (caddar PLIST2))
     )
  (progn
   (setq 2D T)
   (if (caddar PLIST1)
    (progn
     (setq TMP nil)
     (foreach NODE PLIST1
      (setq TMP (append TMP (list (list (car NODE) (cadr NODE)))))
     )
     (setq PLIST1 TMP)
    )
   )
   (if (caddar PLIST2)
    (progn
     (setq TMP nil)
     (foreach NODE PLIST2
      (setq TMP (append TMP (list (list (car NODE) (cadr NODE)))))
     )
     (setq PLIST2 TMP)
    )
   )
  )
 )
 (if (< (distance (car PLIST1) (last PLIST2))
        (distance (car PLIST1) (car PLIST2))
     )
  (setq PLIST2 (reverse PLIST2))
 )
 (setq P1 (car PLIST1)
       PLIST1 (cdr PLIST1)
       P2 (car PLIST2)
       PLIST2 (cdr PLIST2)
 )
 (if 2D
  (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))))
  (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0) (/ (+ (caddr P1) (caddr P2)) 2.0)))))
 )
 (if 2D
  (setq PLAST (list (/ (+ (car (last PLIST1)) (car (last PLIST2))) 2.0) (/ (+ (cadr (last PLIST1)) (cadr (last PLIST2))) 2.0)))
  (setq PLAST (list (/ (+ (car (last PLIST1)) (car (last PLIST2))) 2.0) (/ (+ (cadr (last PLIST1)) (cadr (last PLIST2))) 2.0) (/ (+ (caddr (last PLIST1)) (caddr (last PLIST2))) 2.0)))
 )
 (while (and PLIST1 PLIST2)
  (cond ((and (/= nil PLIST1) (= nil PLIST2))
         (setq D nil
               D1 nil
               D2 (distance P2 (car PLIST1))
         )
        )
        ((and (= nil PLIST1) (/= nil PLIST2))
         (setq D nil
               D1 (distance P1 (car PLIST2))
               D2 nil
         )
        )
        (T
         (setq D (distance (car PLIST1) (car PLIST2))
               D1 (distance P1 (car PLIST2))
               D2 (distance P2 (car PLIST1))
         )
        )
  )
  (if D
   (cond ((and (< D1 D) (< D1 D2))
          (progn
           (setq P2 (car PLIST2)
                 PLIST2 (cdr PLIST2)
           )
           (if 2D
            (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))))
            (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0) (/ (+ (caddr P1) (caddr P2)) 2.0)))))
           )
          )
         )
         ((and (< D2 D) (< D2 D1))
          (progn
           (setq P1 (car PLIST1)
                 PLIST1 (cdr PLIST1)
           )
           (if 2D
            (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))))
            (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0) (/ (+ (caddr P1) (caddr P2)) 2.0)))))
           )
          )
         )
         (T
          (progn
           (setq P1 (car PLIST1)
                 PLIST1 (cdr PLIST1)
                 P2 (car PLIST2)
                 PLIST2 (cdr PLIST2)
           )
           (if 2D
            (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))))
            (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0) (/ (+ (caddr P1) (caddr P2)) 2.0)))))
           )
          )
         )
   )
   (if D2
    (progn
     (setq P1 (car PLIST1)
           PLIST1 (cdr PLIST1)
     )
     (if 2D
      (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))))
      (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0) (/ (+ (caddr P1) (caddr P2)) 2.0)))))
     )
    )
    (progn
     (setq P2 (car PLIST2)
           PLIST2 (cdr PLIST2)
     )
     (if 2D
      (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))))
      (setq PLISTM (append PLISTM (list (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0) (/ (+ (caddr P1) (caddr P2)) 2.0)))))
     )
    )
   )
  )
 )
 (setq PLISTM (append PLISTM (list PLAST)))
 PLISTM
);
;
;     Program written by Robert Livingston, 2015-03-13
;
;     RFL:POINTINSIDE checks if a point is inside a polyline formed by PLIST
;
;
(defun RFL:POINTINSIDE (P PLIST / CROSSINGCOUNT P0 P1 PBASE PTMP)
 (setq P0 (last PLIST))
 ;  Subtracted/added pi from to the 'X' and 'Y' coordinate to have a point that is outside PLIST and 'hopefully' prevent on edge case
 (setq PBASE (list (- (apply 'min (mapcar '(lambda (PTMP) (car PTMP)) PLIST)) pi)
                   (+ (apply 'min (mapcar '(lambda (PTMP) (cadr PTMP)) PLIST)) pi)
             )
 )
 (setq CROSSINGCOUNT 0)
 (foreach P1 PLIST
  (progn
   (if (inters PBASE P P0 P1)
    (setq CROSSINGCOUNT (1+ CROSSINGCOUNT))
   )
   (setq P0 P1)
  )
 )
 (if (= 0 (rem CROSSINGCOUNT 2))
  nil
  T
 )
)
;
;
;     Program written by Robert Livingston, 2008-11-04
;
;     RFL:RABKILL removes alignment definition lists from RFLALIGN blocks
;
;
(defun RFL:RABKILL (BLKENT NODE / BLKENTNEW BLKENTLIST ENT ENTLIST ENTN)
 (entmake)
 (setq BLKENTLIST (entget BLKENT))
 (setq BLKENTNEW (entmake BLKENTLIST))
 (setq ENT (entnext BLKENT))
 (setq ENTLIST (entget ENT))
 (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
  (if (= NODE (cdr (assoc 2 ENTLIST)))
   (progn
    (setq ENTLIST (subst (cons 1 "N/A") (assoc 1 ENTLIST) ENTLIST))
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (= NODE (cdr (assoc 2 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
   (progn
    (entmake ENTLIST)
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
  )
 )
 (entmake ENTLIST)
 (entdel BLKENT)
 (setq BLKENTNEW (entlast))
)
(defun RFL:SELECTLINKED (/ C C2 ENT ENTSET LINKEDSET SOURCESET)
 (if (setq SOURCESET (ssget "I"))
  (progn
   (setq LINKEDSET (ssadd))
   (setq C 0)
   (while (< C (sslength SOURCESET))
    (setq ENT (ssname SOURCESET C))
    (setq ENTSET (RFL:GETALLENT ENT))
    (setq C2 0)
    (while (< C2 (sslength ENTSET))
     (ssadd (ssname ENTSET C2) LINKEDSET)
     (setq C2 (1+ C2))
    )
    (setq C (1+ C))
   )
   (sssetfirst nil LINKEDSET)
   LINKEDSET
  )
  nil
 )
)
;
;
;     Program written by Robert Livingston, 2014-11-20
;
;     RFL:STATXT converts a real to a station string
;
;
(setq RFL:STAPOS nil)
(defun RFL:STATXT (STA / C DIMZIN S STAH STAL)
 (if (= nil RFL:STAPOS) (if (= nil (setq RFL:STAPOS (getint "\nStation label '+' location <3> : "))) (setq RFL:STAPOS 3)))
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 8)
 (if (< RFL:STAPOS 1)
  (rtos STA)
  (progn
   (if (< STA 0.0)
    (setq S "-")
    (setq S "")
   )
   (setq STAH (fix (/ (abs STA) (expt 10 RFL:STAPOS))))
   (setq STAL (- (abs STA) (* STAH (expt 10 RFL:STAPOS))))
   (if (= (substr (rtos STAL) 1 (+ RFL:STAPOS 1)) (itoa (expt 10 RFL:STAPOS)))
    (progn
     (setq STAL 0.0)
     (setq STAH (+ STAH (RFL:SIGN STAH)))
    )
   )
   (setq STAH (itoa STAH))
   (setq C (- RFL:STAPOS (strlen (itoa (fix STAL)))))
   (setq STAL (rtos STAL 2 (getvar "LUPREC")))
   (while (> C 0)
    (setq STAL (strcat "0" STAL))
    (setq C (- C 1))
   )
   (setvar "DIMZIN" DIMZIN)
   (setq RFLSTAHTXT (strcat S STAH) RFLSTALTXT STAL)
   (strcat S STAH "+" STAL)
  )
 )
)
;
;
;     Program written by Robert Livingston, 2016/07/06
;
;     RFL:xxxENT is a collection of routines for adding extended data for linking entities
;
;     (RFL:PUTENT E1 E2 E3)   :  Adds handle of E2 as the next entity, E3 as the previous entity to E1
;     (RFL:PUTNEXTENT E1 E2)  :  Adds handle of E2 as the next entity to E1
;     (RFL:PUTPREVENT E1 E2)  :  Adds handle of E2 as the previous entity to E1
;     (RFL:GETNEXTENT E1)     :  Returns the next entity of E1
;     (RFL:GETPREVENT E1)     :  Returns the previous entity of E1
;     (RFL:GETALLNEXTENT E1)  :  Returns all the next entities of E1
;     (RFL:GETALLPREVENT E1)  :  Returns all the previous entities of E1
;     (RFL:GETALLENT E1)      :  Returns all the entities linked to E1 (including E1)
;     (RFL:BREAKENT E1)       :  Removes all the links to E1 and relinks the previous and next to eachother
;     (RFL:GETFIRSTENT E1)    :  Returns the first linked entity
;     (RFL:GETLASTENT E1)     :  Returns the last linked entity
;
(defun RFL:PUTENT (ENT NEXTENT PREVENT / ENTLIST)
 (vl-load-com)
 (if (not (tblsearch "APPID" "RFLTOOLS_XENT"))
  (regapp "RFLTOOLS_XENT")
 )
 (setq ENTLIST nil)
 (if (= (type ENT) 'ENAME)
  (progn
   (cond ((and (= (type NEXTENT) 'ENAME)
               (= (type PREVENT) 'ENAME)
          )
          (setq ENTLIST (append (entget ENT)
                                (list
                                      (list -3 
                                            (list "RFLTOOLS_XENT"
                                                  (cons 1000 "RFLTOOLS_NEXTENT")
                                                  (cons 1005 (cdr (assoc 5 (entget NEXTENT))))
                                                  (cons 1000 "RFLTOOLS_PREVENT")
                                                  (cons 1005 (cdr (assoc 5 (entget PREVENT))))
                                            )
                                      )
                                )
                        )
          )
         )
         ((and (= (type NEXTENT) 'ENAME)
               (= PREVENT nil)
          )
          (setq ENTLIST (append (entget ENT)
                                (list
                                      (list -3 
                                            (list "RFLTOOLS_XENT"
                                                  (cons 1000 "RFLTOOLS_NEXTENT")
                                                  (cons 1005 (cdr (assoc 5 (entget NEXTENT))))
                                            )
                                      )
                                )
                        )
          )
         )
         ((and (= NEXTENT nil)
               (= (type PREVENT) 'ENAME)
          )
          (setq ENTLIST (append (entget ENT)
                                (list
                                      (list -3 
                                            (list "RFLTOOLS_XENT"
                                                  (cons 1000 "RFLTOOLS_PREVENT")
                                                  (cons 1005 (cdr (assoc 5 (entget PREVENT))))
                                            )
                                      )
                                )
                        )
          )
         )
         ((and (= NEXTENT nil)
               (= PREVENT nil)
          )
          (setq ENTLIST (list (cons -1 ENT) (list -3 (list "RFLTOOLS_XENT"))))
         )
   )
  )
 )
 (if ENTLIST
  (progn
   (entmod ENTLIST)
   ENT
  )
  nil
 )
)
(defun RFL:PUTNEXTENT (ENT NEXTENT / ENTLIST PREVENT)
 (if (= (type ENT) 'ENAME)
  (progn
   (setq PREVENT (RFL:GETPREVENT ENT))
   (RFL:PUTENT ENT NEXTENT PREVENT)
   ENT
  )
  nil
 )
)
(defun RFL:PUTPREVENT (ENT PREVENT / ENTLIST NEXTENT)
 (if (= (type ENT) 'ENAME)
  (progn
   (setq NEXTENT (RFL:GETNEXTENT ENT))
   (RFL:PUTENT ENT NEXTENT PREVENT)
   ENT
  )
  nil
 )
)
(defun RFL:GETNEXTENT (ENT / ENTLIST)
 (if (= (type ENT) 'ENAME)
  (progn
   (if (/= nil (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT"))))))
    (while (and ENTLIST (/= (cdar ENTLIST) "RFLTOOLS_NEXTENT"))
     (setq ENTLIST (cdr ENTLIST))
    )
   )
   (setq ENTLIST (cdr ENTLIST))
   (if ENTLIST
    (handent (cdar ENTLIST))
    nil
   )
  )
  nil
 )
)
(defun RFL:GETPREVENT (ENT / ENTLIST)
 (if (= (type ENT) 'ENAME)
  (progn
   (if (/= nil (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT"))))))
    (while (and ENTLIST (/= (cdar ENTLIST) "RFLTOOLS_PREVENT"))
     (setq ENTLIST (cdr ENTLIST))
    )
   )
   (setq ENTLIST (cdr ENTLIST))
   (if ENTLIST
    (handent (cdar ENTLIST))
    nil
   )
  )
  nil
 )
)
(defun RFL:GETALLNEXTENT (ENT / ENT2 ENTSET)
 (if (= (type ENT) 'ENAME)
  (progn
   (setq ENTSET (ssadd)
         ENT2 ENT
   )
   (while (setq ENT2 (RFL:GETNEXTENT ENT2))
    (ssadd ENT2 ENTSET)
   )
   ENTSET
  )
  nil
 )
)
(defun RFL:GETALLPREVENT (ENT / ENT2 ENTSET)
 (if (= (type ENT) 'ENAME)
  (progn
   (setq ENTSET (ssadd)
         ENT2 ENT
   )
   (while (setq ENT2 (RFL:GETPREVENT ENT2))
    (ssadd ENT2 ENTSET)
   )
   ENTSET
  )
  nil
 )
)
(defun RFL:GETALLENT (ENT / ENT2 ENTSET)
 (if (= (type ENT) 'ENAME)
  (progn
   (setq ENTSET (ssadd ENT)
         ENT2 ENT
   )
   (while (setq ENT2 (RFL:GETNEXTENT ENT2))
    (ssadd ENT2 ENTSET)
   )
   (setq ENT2 ENT)
   (while (setq ENT2 (RFL:GETPREVENT ENT2))
    (ssadd ENT2 ENTSET)
   )
   ENTSET
  )
 )
)
(defun RFL:BREAKENT (ENT / NEXTENT PREVENT)
 (if (= (type ENT) 'ENAME)
  (progn
   (setq NEXTENT (RFL:GETNEXTENT ENT))
   (setq PREVENT (RFL:GETPREVENT ENT))
   (RFL:PUTNEXTENT PREVENT NEXTENT)
   (RFL:PUTPREVENT NEXTENT PREVENT)
   (entmod (list (cons -1 ENT) (list -3 (list "RFLTOOLS_XENT"))))
   ENT
  )
  nil
 )
)
(defun RFL:GETFIRSTENT (ENT / ENTLIST)
 (setq ENTLIST T)
 (if (= (type ENT) 'ENAME)
  (while (/= nil ENTLIST)
   (if (/= nil (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT"))))))
    (while (and ENTLIST (/= (cdar ENTLIST) "RFLTOOLS_PREVENT"))
     (setq ENTLIST (cdr ENTLIST))
    )
   )
   (setq ENTLIST (cdr ENTLIST))
   (if ENTLIST
    (setq ENT (handent (cdar ENTLIST)))
    nil
   )
  )
  nil
 )
 ENT
)
(defun RFL:GETLASTENT (ENT / ENTLIST)
 (setq ENTLIST T)
 (if (= (type ENT) 'ENAME)
  (while (/= nil ENTLIST)
   (if (/= nil (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT"))))))
    (while (and ENTLIST (/= (cdar ENTLIST) "RFLTOOLS_NEXTENT"))
     (setq ENTLIST (cdr ENTLIST))
    )
   )
   (setq ENTLIST (cdr ENTLIST))
   (if ENTLIST
    (setq ENT (handent (cdar ENTLIST)))
    nil
   )
  )
  nil
 )
 ENT
);
;
;     Program written by Robert Livingston
;
;
(defun RFL:ACADVER (/ ACADPROD)
 (if (= nil vlax-machine-product-key)
  (setq ACADPROD (vlax-product-key))
  (setq ACADPROD (vlax-machine-product-key))
 )
 (cond ;;2008
       ((vl-string-search "\\R17.1\\" ACADPROD)
        "5.0"
       )
       
       ;;2009
       ((vl-string-search "\\R17.2\\" ACADPROD)
        "6.0"
       )
       
       ;;2010
       ((vl-string-search "\\R18.0\\" ACADPROD)
        "7.0"
       )
       
       ;;2011
       ((vl-string-search "\\R18.1\\" ACADPROD)
        "8.0"
       )
       
       ;;2012
       ((vl-string-search "\\R18.2\\" ACADPROD)
        "9.0"
       )
       
       ;;2013
       ((vl-string-search "\\R19.0\\" ACADPROD)
        "10.0"
       )
       
       ;;2014
       ((vl-string-search "\\R19.1\\" ACADPROD)
        "10.3"
       )
       
       ;;2015
       ((vl-string-search "\\R20.0\\" ACADPROD)
        "10.4"
       )
       
       ;;2016
       ((vl-string-search "\\R20.1\\" ACADPROD)
        "10.5"
       )
       
       ;;2017
       ((vl-string-search "\\R21.0\\" ACADPROD)
        "11.0"
       )
       
       ;;2018
       ((vl-string-search "\\R22.0\\" ACADPROD)
        "12.0"
       )
       
       ;;2019
       ((vl-string-search "\\R23.0\\" ACADPROD)
        "13.0"
       )
       
 )
)
;
;
;     Program written by Robert Livingston
;
;
(defun RFL:GETC3DALIGNMENT (/ ENT ENTLIST GETFROMLIST OBALIGNMENT)
 (defun GETFROMLIST (/ *acad* ACADACTIVEDOCUMENT ACADPROD ACADVER C3DOBJECT C3DDOC C3DALIGNS C CMAX C3DALIGN)
  (textscr)
  (princ "\n")
  (setq ACADPROD (strcat "AeccXUiLand.AeccApplication." (RFL:ACADVER)))
  (setq *acad* (vlax-get-acad-object))
  (setq C3DOBJECT (vla-getinterfaceobject *acad* ACADPROD))
  (setq C3DDOC (vla-get-activedocument C3DOBJECT))
  (setq C3DALIGNS (vlax-get C3DDOC 'alignmentssiteless))
  (setq CMAX (vlax-get-property C3DALIGNS "Count"))
  (setq C 0)
  (while (< C CMAX)
   (setq C3DALIGN (vlax-invoke-method C3DALIGNS "Item" C))
   (setq C (+ C 1))
   (princ (strcat (itoa C) " - " (vlax-get-property C3DALIGN "DisplayName") "\n"))
  )
  (if (setq C (getint "Enter alignment number : "))
   (setq OBALIGNMENT (vlax-invoke-method C3DALIGNS "Item" (- C 1)))
   nil
  )
  (graphscr)
 )
 (setq OBALIGNMENT nil)
 (setq ENT (car (entsel "\nSelect C3D alignment (<return> to choose from list) : ")))
 (if (= nil ENT)
  (GETFROMLIST)
  (progn
   (setq ENTLIST (entget ENT))
   (if (/= "AECC_ALIGNMENT" (cdr (assoc 0 ENTLIST)))
    (princ "\n*** Not a C3D Alignment ***")
    (setq OBALIGNMENT (vlax-ename->vla-object ENT))
   )
  )
 )
 OBALIGNMENT
)
;
;
;     Program written by Robert Livingston
;
;
(defun RFL:GETC3DSURFACE (/ ENT ENTLIST GETFROMLIST OBSURFACE)
 (defun GETFROMLIST (/ *acad* ACADPROD C3DOBJECT C3DDOC C3DSURFS C CMAX C3DSURF)
  (textscr)
  (princ "\n")
  (setq ACADPROD (strcat "AeccXUiLand.AeccApplication." (RFL:ACADVER)))
  (setq *acad* (vlax-get-acad-object))
  (setq C3DOBJECT (vla-getinterfaceobject *acad* ACADPROD))
  (setq C3DDOC (vla-get-activedocument C3DOBJECT))
  (setq C3DSURFS (vlax-get C3DDOC 'surfaces))
  (setq CMAX (vlax-get-property C3DSURFS "Count"))
  (setq C 0)
  (while (< C CMAX)
   (setq C3DSURF (vlax-get-property C3DSURFS "Item" C))
   (setq C (+ C 1))
   (princ (strcat (itoa C) " - " (vlax-get-property C3DSURF "DisplayName") "\n"))
  )
  (if (setq C (getint "Enter surface number : "))
   (setq OBSURFACE (vlax-get-property C3DSURFS "Item" (- C 1)))
   nil
  )
  (graphscr)
 )

 (setq OBSURFACE nil)

 (setq ENT (car (entsel "\nSelect C3D surface or <return> to select from list : ")))
 (if (= nil ENT)
  (GETFROMLIST)
  (progn
   (setq ENTLIST (entget ENT))
   (if (/= "AECC_TIN_SURFACE" (cdr (assoc 0 ENTLIST)))
    (if (/= "AECC_GRID_SURFACE" (cdr (assoc 0 ENTLIST)))
     (princ "\n*** Not a C3D Surface ***")
     (setq OBSURFACE (vlax-ename->vla-object ENT))
    )
    (setq OBSURFACE (vlax-ename->vla-object ENT))
   )
  )
 )
 OBSURFACE
)
;
;
;     Program written by Robert Livingston
;
;
(defun RFL:GETSECTIONSET (STASTART STAEND SWATH STEP OBSURFACE RFL:ALIGNLIST / P1 P2 PLIST SECTIONSET STA SLIST)
 (princ "\nGetting sections : ")
 (setq STA STASTART)
 (while (<= STA STAEND)
  (princ (strcat "\n" (RFL:STATXT STA) "..."))
  (setq P1 (RFL:XY (list STA (/ SWATH -2.0))))
  (setq P2 (RFL:XY (list STA (/ SWATH 2.0))))
  (if (and (/= nil P1) (/= nil P2))
   (progn
    (setq PLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE))
    (setq SLIST nil)
    (foreach NODE PLIST
     (progn
      (setq P (list (car NODE) (cadr NODE)))
      (setq SLIST (append SLIST (list (list (- (distance P1 P) (/ SWATH 2.0)) (last NODE)))))
     )
    )
    (setq SECTIONSET (append SECTIONSET (list (list STA SLIST))))
   )
  )
  (setq STA (+ STA STEP))
 )
 SECTIONSET
)
;
;
;     Program written by Robert Livingston
;
;
(defun RFL:GETSURFACELINE (P1 P2 OBSURFACE / C CATCHERROR OGLINE OGLINELIST VARLIST)
 (setq OGLINE nil)
 (setq VARLIST (list OBSURFACE "SampleElevations" (car P1) (cadr p1) (car P2) (cadr p2)))
 (setq OGLINE (vl-catch-all-apply 'vlax-invoke-method VARLIST))
 (if (not (vl-catch-all-error-p OGLINE))
  (if (/= nil OGLINE)
   (if (/= 0 (vlax-variant-type OGLINE))
    (progn
     (setq OGLINELIST nil)
     (setq OGLINE (vlax-variant-value OGLINE))
     (setq C (vlax-safearray-get-l-bound OGLINE 1))
     (while (<= C (vlax-safearray-get-u-bound OGLINE 1))
      (setq OGLINELIST (append OGLINELIST (list (list (vlax-safearray-get-element OGLINE C)
                                                      (vlax-safearray-get-element OGLINE (+ C 1))
                                                      (vlax-safearray-get-element OGLINE (+ C 2))))))
      (setq C (+ C 3))
     )
    )
   )
  )
 )
 OGLINELIST
)
;
;
;     Program written by Robert Livingston
;
;
(defun RFL:GETSURFACEPOINT (P OBSURFACE / VARLIST)
 (setq VARLIST (list OBSURFACE "FindElevationAtXY" (car P) (cadr P)))
 (setq Z (vl-catch-all-apply 'vlax-invoke-method VARLIST))
 (if (vl-catch-all-error-p Z)
  nil
  Z
 )
)
;
;
;     Program written by Robert Livingston, 2001/01/11
;
;     C:3DP2ALIGN converts a 3d polyline to horizontal and vertical alignments
;
;
(defun C:3DP2ALIGN (/ CMDECHO ENT FILENAME STA)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq ENT (car (entsel "\nSelect 3d polyline : ")))
 (setq STA (getreal "\nEnter starting chainage : "))
 (RFL:3DP2ALIGN ENT STA)

 (setvar "CMDECHO" CMDECHO)
)
;
;
;     Program written by Robert Livingston, 2015-08-19
;
;     C:3DP2MINPROF generates a profile by projecting selected 3DPolyline points to the proposed alignment
;
;
(defun C:3DP2MINPROF (/ *error* ALINTERS ALPLALPLLIST ALSAVE C ENT ENTLIST INC NODE ORTHOMODE OS OSMODE P P1 P2 PLIST PVIPL PVIPLLIST PVISAVE S STA STAEND SWATH TMP Z Z1 Z2 ZLIST ZMAX)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 
 (defun *error* (msg)
  (setq RFL:ALIGNLIST ALSAVE)
  (setq PVISAVE RFL:PVILIST)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (print msg)
  ;(setq *error* nil)
 )
 
 (defun ALINTERS (P1 P2 RFL:ALIGNLIST / C OS OS1 OS2 P)
  (setq P nil)
  (while (and (/= nil RFL:ALIGNLIST)
              (= nil (setq P (inters P1 P2 (cadr (car RFL:ALIGNLIST)) (caddr (car RFL:ALIGNLIST)))))
         )
   (setq RFL:ALIGNLIST (cdr RFL:ALIGNLIST))
  )
  P
 )
 
 (setq ALSAVE RFL:ALIGNLIST)
 (setq PVISAVE RFL:PVILIST)
 (if (= nil RFL:ALIGNLIST)
  (princ "\n!!! NO ALIGNMENT DEFINED !!!\n")
  (progn
   (setq INC 0.0)
   (while (= INC 0.0)
    (setq INC (getdist "\nStation increment <10.0> : "))
    (if (= INC nil) (setq INC 10.0))
   )
   (setq TMP (+ INC (* INC (fix (/ (caar RFL:ALIGNLIST) INC)))))
   (setq STA (getreal (strcat "\nStart Station <" (rtos TMP 2 3) "> : ")))
   (if (= nil STA) (setq STA TMP))
   (setq TMP (* INC (fix (/ (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)) INC))))
   (setq STAEND (getreal (strcat "\nEnd Station <" (rtos TMP 2 3) "> : ")))
   (if (= nil STAEND) (setq STAEND TMP))
   (setq ALPLLIST nil)
   (setq PVIPLLIST nil)
   (RFL:PROFDEF)
   (while (/= nil (setq ENT (car (entsel "\nSelect Polyline : "))))
    (setq ENTLIST (entget ENT))
    (if (= (cdr (assoc 0 ENTLIST)) "POLYLINE")
     (if (/= 0 (logand (cdr (assoc 70 ENTLIST)) 8))
      (progn
       (setq ALPL nil)
       (setq PVIPL nil)
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P1 nil)
       (setq Z1 nil)
       (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
        (setq P2 (cdr (assoc 10 ENTLIST)))
        (setq Z2 (caddr P2))
        (if (= Z2 nil) (setq Z2 0.0))
        (setq P2 (list (car P2) (cadr P2)))
        (if (/= P1 nil)
         (if (= nil ALPL)
          (setq ALPL (list (list 0.0 P1 P2 0.0)))
          (setq ALPL (append ALPL (list (list (+ (car (last ALPL)) (distance (cadr (last ALPL)) (caddr (last ALPL)))) P1 P2 0.0))))
         )
        )
        (if (= nil PVIPL)
         (setq PVIPL (list (list 0.0 Z2 "L" 0.0)))
         (setq PVIPL (append PVIPL (list (list (+ (car (last ALPL)) (distance P1 P2)) Z2 "L" 0.0))))
        )
        (setq P1 P2)
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
       )
       (setq ALPLLIST (append ALPLLIST (list ALPL)))
       (setq PVIPLLIST (append PVIPLLIST (list PVIPL)))
      )
      (princ "\n!!! NOT a 3D POLYLINE !!!\n")
     )
    )
   )
   (if (/= nil ALPLLIST)
    (progn
     (command "._PLINE")
     (setq SWATH (getdist "\nSwath with <100.0> : "))
     (if (= nil SWATH) (setq SWATH 100.0))
     (while (<= STA STAEND)
      (setq RFL:ALIGNLIST ALSAVE)
      (setq P1 (RFL:XY (list STA (/ SWATH -2.0))))
      (setq P2 (RFL:XY (list STA (/ SWATH 2.0))))
      (setq PLIST nil)
      (setq ZLIST nil)
      (setq C 0)
      (while (< C (length ALPLLIST))
       (setq RFL:ALIGNLIST (nth C ALPLLIST))
       (setq RFL:PVILIST (nth C PVIPLLIST))
       (setq P (ALINTERS P1 P2 RFL:ALIGNLIST))
       (if (/= nil P)
        (progn
         (setq Z (RFL:ELEVATION (car (RFL:STAOFF P))))
         (if (/= nil Z)
          (progn
           (setq PLIST (append PLIST (list P)))
           (setq ZLIST (append ZLIST (list Z)))
          )
         )
        )
       )
       (setq C (+ C 1))
      )
      (setq RFL:ALIGNLIST ALSAVE)
      (if (and (/= nil PLIST) (/= nil ZLIST))
       (progn
        (setq ZMAX nil)
        (if (/= nil (setq P (RFL:XY (list STA 0.0))))
         (if (/= nil (setq S (RFL:SUPER STA)))
          (progn
           (setq C 0)
           (while (< C (length PLIST))
            (setq P1 (nth C PLIST))
            (setq Z1 (nth C ZLIST))
            (if (/= nil (setq OS (cadr (RFL:STAOFF P1))))
             (progn
              (if (< OS 0.0)
               (setq Z (+ Z1 (* (abs OS) (car S) -0.01)))
               (setq Z (+ Z1 (* (abs OS) (cadr S) -0.01)))
              )
              (if (= ZMAX nil)
               (setq ZMAX Z)
               (if (> Z ZMAX)
                (setq ZMAX Z)
               )
              )
             )
            )
            (setq C (+ C 1))
           )
           (if (/= nil ZMAX)
            (command (RFL:PROFPOINT STA ZMAX))
           )
          )
         )
        )
       )
      )
      (princ (strcat "\nSta : " (RFL:STATXT STA)))
      (setq STA (+ STA INC))
     )
     (command "")
    )
   )
  )
 )
 (setq RFL:ALIGNLIST ALSAVE)
 (setq PVISAVE RFL:PVILIST)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 T
);
;
;   Program written by Robert Livingston, 01/03/05
;
;   3DP2PROF is a routine for drawing 3D polyline control lines on a profile
;
;
(defun C:3DP2PROF (/ C CLAYER CMDECHO ENT ENTLIST LAYER LR ORTHOMODE OSMODE P S)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (if (= nil RFL:ALIGNLIST)
  (princ "\n***** Alignment not set! *****\n")
  (progn
   (RFL:PROFDEF)
   (while (/= (setq ENT (car (entsel "\nSelect 3D polyline : "))) nil)
    (setq ENTLIST (entget ENT))
    (if (/= (cdr (assoc 0 ENTLIST)) "POLYLINE")
     (princ "\n***** Not a polyline! *****\n")
     (progn
      (if (= 0 (logand (cdr (assoc 70 ENTLIST)) 8))
       (princ "\n***** Not a 3D polyline! *****\n")
       (progn
        (command "._PLINE")
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
        (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
         (setq P (cdr (assoc 10 ENTLIST)))
         (setq S (RFL:STAOFF P))
         (if (/= S nil)
          (command (RFL:PROFPOINT (nth 0 S) (nth 2 P)))
         )
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
        )
        (command "")
       )
      )
     )
    ) 
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "CLAYER" CLAYER)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
);
;
;    Program Written by Robert Livingston 00/03/07
;    AARC is a utility for attaching an arc to the end of a line or arc
;
;
(defun C:AARC (/ *error* ANG ANG1 ANG2 ANGBASE ANGDIR CMDECHO DELTA DIR DRAWARC DX DY ENT ENTLIST L OSMODE P P1 P2 PC R R2 TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (princ msg)
  ;(setq *error* nil)
 )

 (defun DRAWARC (P1 P2 R / ANG D PC X Y)
  (setq D (distance P1 P2)
        X (/ D 2.0)
        Y (* (RFL:SIGN R) (sqrt (- (* R R) (* X X))))
        ANG (angle P1 P2)
        PC (list (+ (car P1) (* X (cos ANG)) (* -1.0 Y (sin ANG)))
                 (+ (cadr P1) (* X (sin ANG)) (* Y (cos ANG)))
           )
  )
  
  (if (> R 0.0)
   (entmake (list (cons 0 "ARC")
                  (cons 10 PC)
                  (cons 40 (abs R))
                  (cons 50 (angle PC P1))
                  (cons 51 (angle PC P2))
            )
   )
   (entmake (list (cons 0 "ARC")
                  (cons 10 PC)
                  (cons 40 (abs R))
                  (cons 50 (angle PC P2))
                  (cons 51 (angle PC P1))
            )
   )
  )
 )
 
 (command "._UCS" "W")

 (setq ENT (entsel))
 (if (/= ENT nil)
  (progn
   (setq P (nth 1 ENT))
   (setq P (list (nth 0 P) (nth 1 P)))
   (setq ENT (car ENT))
   (setq ENTLIST (entget ENT))
   (setq R nil)
   (if (and (setq R (getdist "\nEnter radius :")) (> R 0.0))
    (progn
     (initget "Left Right")
     (if (= (setq DIR (getkword "\nLeft or Right <Left> : ")) "Right") (setq R (* -1.0 R)))
     (setq DELTA 1 L nil)
     (while (or (= DELTA nil) (= L nil))
      (if (= L nil)
       (progn
        (setq DELTA (getangle "\nEnter DELTA (<return> for L) :"))
        (if (= DELTA nil)
         (progn
          (setq DELTA nil)
          (setq L 1)
         )
         (progn
          (setq DELTA (abs DELTA))
          (setq L (abs (* R DELTA)))
         )
        )
       )
       (progn
        (setq L (getreal "\nEnter L (<return> for DELTA) :"))
        (if (= L nil)
         (progn
          (setq DELTA 1)
          (setq L nil)
         )
         (progn
          (setq L (abs L))
          (setq DELTA (abs (/ L R)))
         )
        )
       )
      )
     )
    )
    (progn
     (princ "\nR must be greater than 0.0!\n")
     (setq R nil)
    )
   )
   (if (/= R nil)
    (if (= (cdr (assoc 0 ENTLIST)) "LINE")
     (progn
      (setq P1 (cdr (assoc 10 ENTLIST)))
      (setq P1 (list (nth 0 P1) (nth 1 P1)))
      (setq P2 (cdr (assoc 11 ENTLIST)))
      (setq P2 (list (nth 0 P2) (nth 1 P2)))
      (if (< (distance P P2) (distance P P1))
       (progn
        (setq TMP P1)
        (setq P1 P2)
        (setq P2 TMP)
       )
      )
      (setq ANG (angle P2 P1))
      (setq DX (* (abs R) (sin DELTA)))
      (setq DY (* R (- 1.0 (cos DELTA))))
      (setq P (list (+ (nth 0 P1) (- (* DX (cos ANG)) (* DY (sin ANG))))
                    (+ (nth 1 P1) (+ (* DX (sin ANG)) (* DY (cos ANG))))
              )
      )
      (DRAWARC P1 P R)
     )
     (progn
      (if (= (cdr (assoc 0 ENTLIST)) "ARC")
       (progn
        (setq PC (cdr (assoc 10 ENTLIST)))
        (setq PC (list (nth 0 PC) (nth 1 PC)))
        (setq R2 (cdr (assoc 40 ENTLIST)))
        (setq ANG1 (cdr (assoc 50 ENTLIST)))
        (setq ANG2 (cdr (assoc 51 ENTLIST)))
        (setq P1 (list (+ (nth 0 PC) (* R2 (cos ANG1)))
                       (+ (nth 1 PC) (* R2 (sin ANG1)))))
        (setq ANG1 (- ANG1 (/ pi 2.0)))
        (setq P2 (list (+ (nth 0 PC) (* R2 (cos ANG2)))
                       (+ (nth 1 PC) (* R2 (sin ANG2)))))
        (setq ANG2 (+ ANG2 (/ pi 2.0)))
        (setq ANG ANG1)
        (if (< (distance P P2) (distance P P1))
         (progn
          (setq TMP P1)
          (setq P1 P2)
          (setq P2 TMP)
          (setq ANG ANG2)
         )
        )
        (setq DX (* (abs R) (sin DELTA)))
        (setq DY (* R (- 1.0 (cos DELTA))))
        (setq P (list (+ (nth 0 P1) (- (* DX (cos ANG)) (* DY (sin ANG))))
                      (+ (nth 1 P1) (+ (* DX (sin ANG)) (* DY (cos ANG))))
                )
        )
        (DRAWARC P1 P R)
       )
       (progn
        (if (/= (setq ENTLIST (RFL:GETSPIRALDATA ENT)) nil)
         (progn
          (setq TMP (nth 0 (RFL:SPIRALSTAOFF P ENT)))
          (if (< (- TMP (nth 3 ENTLIST)) (- (RFL:GETSPIRALLS ENT) TMP))
           (progn
            (setq P1 (RFL:SPIRALXY (list (nth 3 ENTLIST) 0.0) ENT))
            (setq ANG (angle (nth 1 ENTLIST) (nth 0 ENTLIST)))
            (if (> (nth 3 ENTLIST) 0.0)
             (progn
              (if (> (sin (- (angle (nth 1 ENTLIST) (nth 0 ENTLIST)) (angle (nth 2 ENTLIST) (nth 1 ENTLIST)))) 0.0)
               (setq TMP -1.0)
               (setq TMP 1.0)
              )
              (setq ANG (+ ANG
                           (* TMP
                              (expt (nth 3 ENTLIST) 2)
                              (RFL:GETSPIRALTHETA ENT)
                              (/ 1.0 (expt (RFL:GETSPIRALLS ENT) 2))
                           )
                        )
              )
             )
            )
           )
           (progn
            (setq P1 (nth 2 ENTLIST))
            (setq ANG (angle (nth 1 ENTLIST) (nth 2 ENTLIST)))
           )
          )
          (setq DX (* (abs R) (sin DELTA)))
          (setq DY (* R (- 1.0 (cos DELTA))))
          (setq P (list (+ (nth 0 P1) (- (* DX (cos ANG)) (* DY (sin ANG))))
                        (+ (nth 1 P1) (+ (* DX (sin ANG)) (* DY (cos ANG))))
                  )
          )
          (DRAWARC P1 P R)
         )
         (progn
          (princ "\n*** ENTITY NOT SPIRAL/ARC/LINE ***")
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 P2
)
;
;
;   Program written by Robert Livingston, 00-10-27
;
;   AIPROF is a utility for drawing and labelling vertical profiles
;
;          Modified 06-06-12 definable labelling precisions.
;
(setq RFL:AIPROFLIST nil)
(defun C:AIPROF (/ ANG ANGBASE ANGDIR C CANCEL CLAYER CMDECHO DIMZIN DIRECTIONT DIRECTIONS ENT FIXNUMBER FONTNAME G1 G2 K L1 L2 L3 LUPREC MLMR OSMODE P P1 P2 PLINETYPE PREVENT REGENMODE REP
                   SCALETEXT SIDE SIGN STA STA1 STA2 STA3 STAH STAL STATXT STAHTXT SPLINETYPE SPLINESEGS TEXTSTYLE TOL Z1 Z2 Z3 ZMAX ZMIN)
 (setq REGENMODE (getvar "REGENMODE"))
 (setvar "REGENMODE" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq SPLINETYPE (getvar "SPLINETYPE"))
 (setvar "SPLINETYPE" 5)
 (setq SPLINESEGS (getvar "SPLINESEGS"))
 (setvar "SPLINESEGS" 65)
 (setq PLINETYPE (getvar "PLINETYPE"))
 (setvar "PLINETYPE" 0)
 (setq TEXTSTYLE (getvar "TEXTSTYLE"))

 (setq TOL 0.000001)
 
 (setq PREVENT nil)
 
 (command "._UNDO" "M")

 (if (= nil (findfile "LEROY.SHX"))
  (if (= nil (findfile "SIMPLEX.SHX"))
   (progn
    (princ "\n!!!!!  Warning - LEROY.SHX not found, subsituting TXT.SHX")
    (setq FONTNAME "TXT.SHX")
   )
   (progn
    (princ "\n!!!!!  Warning - LEROY.SHX not found, subsituting SIMPLEX.SHX")
    (setq FONTNAME "SIMPLEX.SHX")
   )
  )
  (progn
   (setq FONTNAME "LEROY.SHX")
  )
 )

 (defun SIGN (X)
  (if (< X 0)
   (eval -1.0)
   (eval 1.0)
  )
 )

 (defun FIXNUMBER (TILE)
  (set_tile TILE (itoa (atoi (get_tile TILE))))
 )

 (defun STATXT (STA / STAH STAL TMP)
  (setq STA (/ (fix (+ 0.5
                       (* STA
                          (expt 10.0 (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))))
                       )
                    )
               )
               (expt 10.0 (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))))
            )
  )
  (setq STAH (fix (/ STA 1000.0)))
  (setq STAL (abs (- STA (* STAH 1000.0))))
  (if (= (substr (rtos STAL) 1 4) "1000")
   (progn
    (setq STAL 0.0)
    (setq STAH (+ STAH (SIGN STAH)))
   )
  )
  (setq STAH (itoa (fix STAH)))
  (if (and (= STAH "0") (< STA 0.0)) (setq STAH (strcat "-" STAH)))
  (setq TMP STAL)
  (setq STAL (rtos STAL 2 (if (> (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))) 0)))
  (if (< TMP 10.0) (setq STAL (strcat "0" STAL)))
  (if (< TMP 100.0) (setq STAL (strcat "0" STAL)))
  (eval STAL)
 )

 (defun STAHTXT (STA / STAH STAL TMP)
  (setq STA (/ (fix (+ 0.5
                       (* STA
                          (expt 10.0 (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))))
                       )
                    )
               )
               (expt 10.0 (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))))
            )
  )
  (setq STAH (fix (/ STA 1000.0)))
  (setq STAL (abs (- STA (* STAH 1000.0))))
  (if (= (substr (rtos STAL) 1 4) "1000")
   (progn
    (setq STAL 0.0)
    (setq STAH (+ STAH (SIGN STAH)))
   )
  )
  (setq STAH (itoa (fix STAH)))
  (if (and (= STAH "0") (< STA 0.0)) (setq STAH (strcat "-" STAH)))
  (setq TMP STAL)
  (setq STAL (rtos STAL 2 (if (> (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "STAPREC" RFL:AIPROFLIST))) 0)))
  (if (< TMP 10.0) (setq STAL (strcat "0" STAL)))
  (if (< TMP 100.0) (setq STAL (strcat "0" STAL)))
  (if (= (cdr (assoc "LHIGH" RFL:AIPROFLIST)) "1")
   (eval STAH)
   (eval "")
  )
 )

 (defun SCALETEXT (H / ENT ENTLIST)
  (setq ENT (entlast))
  (setq ENTLIST (entget ENT))
  (setq ENTLIST (subst (cons 40 (* (cdr (assoc "SCALE" RFL:PROFDEFLIST)) H))
                       (assoc 40 ENTLIST)
                       ENTLIST
                )
  )
  (entmod ENTLIST)
  (entupd ENT)
 )

 (defun SETAIPROFLIST (/ ACCEPTAIPROF CANCELAIPROF DCLID)
  (defun ACCEPTAIPROF ()
   (setq RFL:AIPROFLIST
    (list
     (cons "DPROF" (get_tile "DPROF"))
     (cons "LSLOPE" (get_tile "LSLOPE"))
     (cons "LL" (get_tile "LL"))
     (cons "LK" (get_tile "LK"))
     (cons "CNODES" (get_tile "CNODES"))
     (cons "DPVI" (get_tile "DPVI"))
     (cons "LPVI" (get_tile "LPVI"))
     (cons "LBVC" (get_tile "LBVC"))
     (cons "LHIGH" (get_tile "LHIGH"))
     (cons "LELEVATIONS" (get_tile "LELEVATIONS"))
     (cons "RAB" (get_tile "RAB"))
     (cons "DIRECTION" (cond ((= (get_tile "DIRLEFT") "1") "DIRLEFT")
                             ((= (get_tile "DIRRIGHT") "1") "DIRRIGHT")
                             ((= (get_tile "DIRUP") "1") "DIRUP")
                             ((= (get_tile "DIRDOWN") "1") "DIRDOWN")
                       )
     )
     (cons "KPREC" (get_tile "KPREC"))
     (cons "LPREC" (get_tile "LPREC"))
     (cons "SLOPEPREC" (get_tile "SLOPEPREC"))
     (cons "STAPREC" (get_tile "STAPREC"))
     (cons "ELEVPREC" (get_tile "ELEVPREC"))
    )
   )
   (setq CANCEL 0)
   (done_dialog)
   (unload_dialog DCL_ID)
  )

  (defun CANCELAIPROF ()
   (setq CANCEL 1)
   (done_dialog)
   (unload_dialog DCL_ID)
  )

  (if (= nil RFL:AIPROFLIST)
   (setq RFL:AIPROFLIST
    (list
     (cons "DPROF" "1")
     (cons "LSLOPE" "1")
     (cons "LL" "0")
     (cons "LK" "1")
     (cons "CNODES" "1")
     (cons "DPVI" "1")
     (cons "LPVI" "1")
     (cons "LBVC" "1")
     (cons "LHIGH" "0")
     (cons "LELEVATIONS" "1")
     (cons "RAB" "0")
     (cons "DIRECTION" "DIRUP")
     (cons "KPREC" "3")
     (cons "LPREC" "3")
     (cons "SLOPEPREC" "2")
     (cons "STAPREC" "3")
     (cons "ELEVPREC" "3")
    )
   )
  )

  (if (= AIPROFDCLNAME nil)
   (progn
    (setq AIPROFDCLNAME (vl-filename-mktemp "rfl.dcl"))
    (RFL:MAKEDCL AIPROFDCLNAME "AIPROF")
   )
   (if (= nil (findfile AIPROFDCLNAME))
    (progn
     (setq AIPROFDCLNAME (vl-filename-mktemp "rfl.dcl"))
     (RFL:MAKEDCL AIPROFDCLNAME "AIPROF")
    )
   )
  )
  (setq DCL_ID (load_dialog AIPROFDCLNAME))
  (if (not (new_dialog "AIPROF" DCL_ID)) (exit))

  (setq RFLALIGNSLBNAME "rflAlign.slb")
  (if (= nil (findfile RFLALIGNSLBNAME))
   (progn
    (setq RFLALIGNSLBNAME (vl-filename-mktemp "rfl.slb"))
    (RFL:MAKERFLSLB RFLALIGNSLBNAME)
   )
  )
  (start_image "IMAGE")
  (slide_image 0 0 (- (dimx_tile "IMAGE") 1) (- (dimy_tile "IMAGE") 1) (strcat RFLALIGNSLBNAME "(AIPROF)"))
  (end_image)

  (set_tile "DPROF" (cdr (assoc "DPROF" RFL:AIPROFLIST)))
  (set_tile "LSLOPE" (cdr (assoc "LSLOPE" RFL:AIPROFLIST)))
  (set_tile "LL" (cdr (assoc "LL" RFL:AIPROFLIST)))
  (set_tile "LK" (cdr (assoc "LK" RFL:AIPROFLIST)))
  (set_tile "CNODES" (cdr (assoc "CNODES" RFL:AIPROFLIST)))
  (set_tile "DPVI" (cdr (assoc "DPVI" RFL:AIPROFLIST)))
  (set_tile "LPVI" (cdr (assoc "LPVI" RFL:AIPROFLIST)))
  (set_tile "LBVC" (cdr (assoc "LBVC" RFL:AIPROFLIST)))
  (set_tile "LHIGH" (cdr (assoc "LHIGH" RFL:AIPROFLIST)))
  (set_tile "LELEVATIONS" (cdr (assoc "LELEVATIONS" RFL:AIPROFLIST)))
  (set_tile "RAB" (cdr (assoc "RAB" RFL:AIPROFLIST)))
  (set_tile (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "1")
  (set_tile "KPREC" (cdr (assoc "KPREC" RFL:AIPROFLIST)))
  (set_tile "LPREC" (cdr (assoc "LPREC" RFL:AIPROFLIST)))
  (set_tile "SLOPEPREC" (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST)))
  (set_tile "STAPREC" (cdr (assoc "STAPREC" RFL:AIPROFLIST)))
  (set_tile "ELEVPREC" (cdr (assoc "ELEVPREC" RFL:AIPROFLIST)))

  (action_tile "KPREC" "(FIXNUMBER \"KPREC\")")
  (action_tile "LPREC" "(FIXNUMBER \"LPREC\")")
  (action_tile "SLOPEPREC" "(FIXNUMBER \"SLOPEPREC\")")
  (action_tile "STAPREC" "(FIXNUMBER \"STAPREC\")")
  (action_tile "ELEVPREC" "(FIXNUMBER \"ELEVPREC\")")
  (action_tile "OK" "(ACCEPTAIPROF)")
  (action_tile "CANCEL" "(CANCELAIPROF)")

  (start_dialog)
 )

 (if (= nil C:RPROF)
  (progn
   (princ "\n*****  PROFILE UTILITIES NOT LOADED  *****")
  )
  (progn
   (C:RPROF)
   (if (= nil RFL:PVILIST)
    (progn
     (princ "\n*****  PROFILE NOT DEFINED  *****")
    )
    (progn
     (RFL:PROFDEF)
     (if (= nil RFL:PROFDEFLIST)
      (progn
       (princ "\n*****  PROFILE LOCATION NOT DEFINED  *****")
      )
      (progn
       (SETAIPROFLIST)
       (if (and (= (cdr (assoc "DPROF" RFL:AIPROFLIST)) "1")
                (= CANCEL 0)
           )
        (progn
         (if (= (tblsearch "LAYER" (cdr (assoc "PLAYER" RFL:PROFDEFLIST))) nil)
          (progn
           (command "._LAYER" "M" (cdr (assoc "PLAYER" RFL:PROFDEFLIST)) "")
          )
          (progn
           (setvar "CLAYER" (cdr (assoc "PLAYER" RFL:PROFDEFLIST)))
          )
         )
         (setq C 1)
         (while (< (+ C 1) (length RFL:PVILIST))
          (setq P1 (RFL:PROFPOINT (+ (nth 0 (nth (- C 1) RFL:PVILIST))
                                     (/ (nth 3 (nth (- C 1) RFL:PVILIST))
                                        2.0
                                     )
                                  )
                                  (RFL:ELEVATION (+ (nth 0 (nth (- C 1) RFL:PVILIST))
                                                (/ (nth 3 (nth (- C 1) RFL:PVILIST))
                                                   2.0
                                                )
                                             )
                                  )
                   )
          )
          (setq P2 (RFL:PROFPOINT (- (nth 0 (nth C RFL:PVILIST))
                                     (/ (nth 3 (nth C RFL:PVILIST))
                                        2.0
                                     )
                                  )
                                  (RFL:ELEVATION (- (nth 0 (nth C RFL:PVILIST))
                                                (/ (nth 3 (nth C RFL:PVILIST))
                                                   2.0
                                                )
                                             )
                                  )
                       )
          )
          (if (> (distance P1 P2) TOL)
               (progn
                (command "._LINE" P1 P2 "")
                (setq ENT (entlast))
                (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
               )
          )
          (command "._PLINE"
                   (RFL:PROFPOINT (- (nth 0 (nth C RFL:PVILIST))
                                 (/ (nth 3 (nth C RFL:PVILIST))
                                    2.0
                                 )
                              )
                              (RFL:ELEVATION (- (nth 0 (nth C RFL:PVILIST))
                                            (/ (nth 3 (nth C RFL:PVILIST))
                                               2.0
                                            )
                                         )
                              )
                   )
                   (RFL:PROFPOINT (nth 0 (nth C RFL:PVILIST))
                              (nth 1 (nth C RFL:PVILIST))
                   )
                   (RFL:PROFPOINT (+ (nth 0 (nth C RFL:PVILIST))
                                 (/ (nth 3 (nth C RFL:PVILIST))
                                    2.0
                                 )
                              )
                              (RFL:ELEVATION (+ (nth 0 (nth C RFL:PVILIST))
                                            (/ (nth 3 (nth C RFL:PVILIST))
                                               2.0
                                            )
                                         )
                              )
                   )
                   ""
          )
          (command "._PEDIT" (entlast) "S" "")
          (setq ENT (entlast))
          (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          (setq C (+ C 1))
         )
	 (setq P1 (RFL:PROFPOINT (+ (nth 0 (nth (- C 1) RFL:PVILIST))
                                (/ (nth 3 (nth (- C 1) RFL:PVILIST))
                                   2.0
                                )
                             )
                             (RFL:ELEVATION (+ (nth 0 (nth (- C 1) RFL:PVILIST))
                                           (/ (nth 3 (nth (- C 1) RFL:PVILIST))
                                              2.0
                                           )
                                        )
                             )
                  )
	 )
	 (setq P2 (RFL:PROFPOINT (- (nth 0 (nth C RFL:PVILIST))
                                (/ (nth 3 (nth C RFL:PVILIST))
                                   2.0
                                )
                             )
                             (RFL:ELEVATION (- (nth 0 (nth C RFL:PVILIST))
                                           (/ (nth 3 (nth C RFL:PVILIST))
                                              2.0
                                           )
                                        )
                             )
                  )
	 )
	 (if (> (distance P1 P2) TOL)
          (progn
           (command "._LINE" P1 P2 "")
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          )
	 )
        )
       )
       (if (and (or (= (cdr (assoc "LSLOPE" RFL:AIPROFLIST)) "1")
                    (= (cdr (assoc "LL" RFL:AIPROFLIST)) "1")
                    (= (cdr (assoc "LK" RFL:AIPROFLIST)) "1")
                    (= (cdr (assoc "CNODES" RFL:AIPROFLIST)) "1")
                    (= (cdr (assoc "DPVI" RFL:AIPROFLIST)) "1")
                    (= (cdr (assoc "LPVI" RFL:AIPROFLIST)) "1")
                    (= (cdr (assoc "LBVC" RFL:AIPROFLIST)) "1")
                    (= (cdr (assoc "LELEVATIONS" RFL:AIPROFLIST)) "1")
                )
                (= CANCEL 0)
           )
        (progn
         (if (or (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) 1)
                 (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) nil)
             )
          (cond ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRLEFT")
                 (setq DIRECTIONT 1 DIRECTIONS 1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRRIGHT")
                 (setq DIRECTIONT -1 DIRECTIONS 1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRUP")
                 (setq DIRECTIONT 1 DIRECTIONS 1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRDOWN")
                 (setq DIRECTIONT -1 DIRECTIONS 1)
                )
          )
          (cond ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRLEFT")
                 (setq DIRECTIONT 1 DIRECTIONS -1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRRIGHT")
                 (setq DIRECTIONT -1 DIRECTIONS -1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRUP")
                 (setq DIRECTIONT -1 DIRECTIONS -1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:AIPROFLIST)) "DIRDOWN")
                 (setq DIRECTIONT 1 DIRECTIONS -1)
                )
          )
         )
         (if (= DIRECTIONT 1)
          (progn
           (if (= (cdr (assoc "RAB" RFL:AIPROFLIST)) "0")
            (progn
             (setq MLMR "MR")
             (setq SIDE 1)
            )
            (progn
             (setq MLMR "ML")
             (setq SIDE -1)
            )
           )
          )
          (progn
           (if (= (cdr (assoc "RAB" RFL:AIPROFLIST)) "0")
            (progn
             (setq MLMR "ML")
             (setq SIDE 1)
            )
            (progn
             (setq MLMR "MR")
             (setq SIDE -1)
            )
           )
          )
         )
         (setq ZMAX (nth 1 (nth 0 RFL:PVILIST)))
         (setq ZMIN (nth 1 (nth 0 RFL:PVILIST)))
         (setq C 1)
         (while (< C (length RFL:PVILIST))
          (if (> (nth 1 (nth C RFL:PVILIST)) ZMAX)
           (setq ZMAX (nth 1 (nth C RFL:PVILIST)))
          )
          (if (< (nth 1 (nth C RFL:PVILIST)) ZMIN)
           (setq ZMIN (nth 1 (nth C RFL:PVILIST)))
          )
          (setq C (+ C 1))
         )
         (setq C 1)
         (if (= (tblsearch "LAYER" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST))) nil)
          (progn
           (command "._LAYER" "M" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST)) "")
          )
          (progn
           (setvar "CLAYER" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST)))
          )
         )
         (if (or (= (cdr (assoc "CNODES" RFL:AIPROFLIST)) "1")
                 (= (cdr (assoc "DPVI" RFL:AIPROFLIST)) "1")
             )
          (if (= (tblsearch "BLOCK" "CIRC") nil)
           (progn
            (entmake)
            (setq ENTLIST (list (cons 0 "BLOCK")
                                (cons 2 "CIRC")
                                (list 10 0.0 0.0 0.0)
                                (cons 70 0)
                          )
            )
            (entmake ENTLIST)
            (setq ENTLIST (list (cons 0 "CIRCLE")
                                (cons 8 "0")
                                (list 10 0.0 0.0 0.0)
                                (cons 40 5.0)
                          )
            )
            (entmake ENTLIST)
            (setq ENTLIST (list (cons 0 "ENDBLK")
                          )
            )
            (entmake ENTLIST)
           )
          )
         )
         (if (= (tblsearch "STYLE" "L100") nil)
          (progn
           (command "._STYLE" "L100" FONTNAME "12.7" "1.0" "0.0" "N" "N" "N")
          )
          (progn
           (setvar "TEXTSTYLE" "L100")
          )
         )
         (setq STA1 (nth 0 (nth 0 RFL:PVILIST)))
         (setq Z1 (nth 1 (nth 0 RFL:PVILIST)))
         (setq L1 (nth 3 (nth 0 RFL:PVILIST)))
         (setq P (RFL:PROFPOINT STA1 Z1))
         (if (= (cdr (assoc "CNODES" RFL:AIPROFLIST)) "1")
          (progn
           (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
           (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          )
         )
         (if (= (cdr (assoc "LBVC" RFL:AIPROFLIST)) "1")
          (progn
           (setq TMP (/ (fix (+ 0.5
                                (* Z1
                                   (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                                )
                             )
                        )
                        (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                     )
           )
           (command "._TEXT"
                    MLMR
                    (list (nth 0 P) (+ (nth 1 P) (* SIDE 100.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                    (if (= DIRECTIONT 1)
                     "-90.0"
                     "90.0"
                    )
                    (strcat (STAHTXT STA1) "+" (STATXT STA1) " " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0)))
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 12.7)
          )
         )
         (while (< (+ C 1) (length RFL:PVILIST))
          (if (= (tblsearch "STYLE" "L100") nil)
           (progn
            (command "._STYLE" "L100" FONTNAME "12.7" "1.0" "0.0" "N" "N" "N")
           )
           (progn
            (setvar "TEXTSTYLE" "L100")
           )
          )
          (setq STA1 (nth 0 (nth (- C 1) RFL:PVILIST)))
          (setq Z1 (nth 1 (nth (- C 1) RFL:PVILIST)))
          (setq L1 (nth 3 (nth (- C 1) RFL:PVILIST)))
          (setq STA2 (nth 0 (nth C RFL:PVILIST)))
          (setq Z2 (nth 1 (nth C RFL:PVILIST)))
          (setq L2 (nth 3 (nth C RFL:PVILIST)))
          (setq STA3 (nth 0 (nth (+ C 1) RFL:PVILIST)))
          (setq Z3 (nth 1 (nth (+ C 1) RFL:PVILIST)))
          (setq L3 (nth 3 (nth (+ C 1) RFL:PVILIST)))
          (setq G1 (* (/ (- Z2 Z1) (- STA2 STA1)) 100.0))
          (setq G2 (* (/ (- Z3 Z2) (- STA3 STA2)) 100.0))
          (setq STA (/ (+ (+ STA1
                             (/ L1 2.0)
                          )
                          (- STA2
                             (/ L2 2.0)
                          )
                       )
                       2.0
                    )
          )
          (if (= (cdr (assoc "LSLOPE" RFL:AIPROFLIST)) "1")
           (progn
;            (setq TMP (/ (fix (+ 0.5
;                                 (* G1
;                                    (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))))
;                                 )
;                              )
;                         )
;                         (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))))
;                      )
;            )
            (command "._TEXT"
                     (if (= SIDE 1) "BC" "TC")
                     (RFL:PROFPOINT STA (RFL:ELEVATION STA))
                     (if (= DIRECTIONS 1)
                      (* (angle (RFL:PROFPOINT STA1 Z1) (RFL:PROFPOINT STA2 Z2)) (/ 180.0 pi))
                      (* (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)) (/ 180.0 pi))
                     )
                     (strcat (if (> G1 0.0) "+" "") (rtos G1 2 (if (> (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))) 0)) "%")
            )
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (SCALETEXT 12.7)
           )
          )
          (setq P (RFL:PROFPOINT STA2 Z2))
          (if (= (cdr (assoc "LPVI" RFL:AIPROFLIST)) "1")
           (progn
            (setq TMP (/ (fix (+ 0.5
                                 (* Z2
                                    (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                                 )
                              )
                         )
                         (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                      )
            )
            (command "._TEXT"
                     MLMR
                     (list (nth 0 P) (+ (nth 1 P) (* SIDE 100.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                     (if (= DIRECTIONT 1)
                      "-90.0"
                      "90.0"
                     )
                     (strcat (STAHTXT STA2) "+" (STATXT STA2) " P.I. " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0)))
            )
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (SCALETEXT 12.7)
           )
          )
          (if (= (cdr (assoc "DPVI" RFL:AIPROFLIST)) "1")
           (progn
            (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
            (command "._INSERT" "CIRC" (RFL:PROFPOINT STA2 Z2) (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (if (> L2 0.0)
           (progn
            (setq K (abs (/ L2
                            (- G2 G1)
                         )
                    )
            )
            (if (= (cdr (assoc "LL" RFL:AIPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* L2
                                      (expt 10.0 (atoi (cdr (assoc "LPREC" RFL:AIPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "LPREC" RFL:AIPROFLIST))))
                        )
              )
              (command "._TEXT"
                       "C"
                       (list (nth 0 P) (- (nth 1 P) (* SIDE 100.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                       "0.0"
                       (strcat "L = "(rtos TMP 2 (if (> (atoi (cdr (assoc "LPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "LPREC" RFL:AIPROFLIST))) 0)))
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 12.7)
             )
            )
            (if (= (cdr (assoc "LK" RFL:AIPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* K
                                      (expt 10.0 (atoi (cdr (assoc "KPREC" RFL:AIPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "KPREC" RFL:AIPROFLIST))))
                        )
              )
              (command "._TEXT"
                       "C"
                       (if (= (cdr (assoc "LL" RFL:AIPROFLIST)) "1")
                        (list (nth 0 P) (- (nth 1 P) (* (+ (* SIDE 100.0) (* 12.7 (/ 12.0 7.0))) (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                        (list (nth 0 P) (- (nth 1 P) (* SIDE 100.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                       )
                       "0.0"
                       (strcat "K = "(rtos TMP 2 (if (> (atoi (cdr (assoc "KPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "KPREC" RFL:AIPROFLIST))) 0)))
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 12.7)
             )
            )
            (if (= (cdr (assoc "DPVI" RFL:AIPROFLIST)) "1")
             (progn
              (setq ANG (angle P (RFL:PROFPOINT STA1 Z1)))
              (command "._LINE"
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   5.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   5.0
                                   (sin ANG)
                                )
                             )
                       )
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   13.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   13.0
                                   (sin ANG)
                                )
                             )
                       )
                       ""
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (setq ANG (angle P (RFL:PROFPOINT STA3 Z3)))
              (command "._LINE"
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   5.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   5.0
                                   (sin ANG)
                                )
                             )
                       )
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   13.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   13.0
                                   (sin ANG)
                                )
                             )
                       )
                       ""
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             )
            )
            (setq P (RFL:PROFPOINT (- STA2 (/ L2 2.0)) (RFL:ELEVATION (- STA2 (/ L2 2.0)))))
            (if (= (cdr (assoc "LBVC" RFL:AIPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* (RFL:ELEVATION (- STA2 (/ L2 2.0)))
                                      (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                        )
              )
              (command "._TEXT"
;                       (if (= DIRECTIONT 1)
;                        "MR"
;                        "ML"
;                       )
                       MLMR
                       (list (nth 0 P) (+ (nth 1 P) (* SIDE 100.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                       (if (= DIRECTIONT 1)
                        "-90.0"
                        "90.0"
                       )
                       (strcat (STAHTXT (- STA2 (/ L2 2.0))) "+" (STATXT (- STA2 (/ L2 2.0))) " " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0)))
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 12.7)
             )
            )
            (if (= (cdr (assoc "CNODES" RFL:AIPROFLIST)) "1")
             (progn
              (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
              (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             )
            )
            (setq P (RFL:PROFPOINT (+ STA2 (/ L2 2.0)) (RFL:ELEVATION (+ STA2 (/ L2 2.0)))))
            (if (= (cdr (assoc "LBVC" RFL:AIPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* (RFL:ELEVATION (+ STA2 (/ L2 2.0)))
                                      (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                        )
              )
              (command "._TEXT"
                       MLMR
                       (list (nth 0 P) (+ (nth 1 P) (* SIDE 100.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                       (if (= DIRECTIONT 1)
                        "-90.0"
                        "90.0"
                       )
                       (strcat (STAHTXT (+ STA2 (/ L2 2.0))) "+" (STATXT (+ STA2 (/ L2 2.0))) " " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0)))
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 12.7)
             )
            )
            (if (= (cdr (assoc "CNODES" RFL:AIPROFLIST)) "1")
             (progn
              (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
              (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             )
            )
            (if (= (cdr (assoc "LELEVATIONS" RFL:AIPROFLIST)) "1")
             (progn
              (if (= (tblsearch "STYLE" "L80") nil)
               (progn
                (command "._STYLE" "L80" FONTNAME "10.16" "1.0" "0.0" "N" "N" "N")
               )
               (progn
                (setvar "TEXTSTYLE" "L80")
               )
              )
              (setq STA (float (* (+ (fix (/ (- STA2 (/ L2 2.0)) 20.0)) 1) 20.0)))
              (while (< STA (+ STA2 (/ L2 2.0)))
               (if (= SIDE 1)
                (setq P (RFL:PROFPOINT STA ZMAX))
                (setq P (RFL:PROFPOINT STA ZMIN))
               )
               (setq TMP (/ (fix (+ 0.5
                                    (* (RFL:ELEVATION STA)
                                       (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                                    )
                                 )
                            )
                            (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))))
                         )
               )
               (command "._TEXT"
                        MLMR
                        (list (nth 0 P) (+ (nth 1 P) (* SIDE 400.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                        (if (= DIRECTIONT 1)
                         "-90.0"
                         "90.0"
                        )
                        (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0))
               )
               (setq ENT (entlast))
               (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
               (SCALETEXT 10.16)
               (setq STA (+ STA 20.0))
              )
             )
            )
           )
          )
          (setq C (+ C 1))
         )
         (setq STA (/ (+ (+ STA2
                            (/ L2 2.0)
                         )
                         (- STA3
                            (/ L3 2.0)
                         )
                      )
                      2.0
                   )
         )
         (if (= (tblsearch "STYLE" "L100") nil)
          (progn
           (command "._STYLE" "L100" FONTNAME "12.7" "1.0" "0.0" "N" "N" "N")
          )
          (progn
           (setvar "TEXTSTYLE" "L100")
          )
         )
         (if (= (cdr (assoc "LSLOPE" RFL:AIPROFLIST)) "1")
          (progn
;           (setq TMP (/ (fix (+ 0.5
;                                (* G2
;                                   (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))))
;                                )
;                             )
;                        )
;                        (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))))
;                     )
;           )
           (command "._TEXT"
                    (if (= SIDE 1) "BC" "TC")
                    (RFL:PROFPOINT STA (RFL:ELEVATION STA))
                    (if (= DIRECTIONS 1)
                     (* (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA3 Z3)) (/ 180.0 pi))
                     (* (angle (RFL:PROFPOINT STA3 Z3) (RFL:PROFPOINT STA2 Z2)) (/ 180.0 pi))
                    )
                    (strcat (if (> G2 0.0) "+" "") (rtos G2 2 (if (> (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))) 0)) "%")
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 12.7)
          )
         )
         (setq P (RFL:PROFPOINT STA3 Z3))
         (if (= (cdr (assoc "CNODES" RFL:AIPROFLIST)) "1")
          (progn
           (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
           (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          )
         )
         (if (= (cdr (assoc "LBVC" RFL:AIPROFLIST)) "1")
          (progn
           (setq TMP (/ (fix (+ 0.5
                                (* Z3
                                   (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))))
                                )
                             )
                        )
                        (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:AIPROFLIST))))
                     )
           )
           (command "._TEXT"
                    MLMR
                    (list (nth 0 P) (+ (nth 1 P) (* SIDE 100.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                    (if (= DIRECTIONT 1)
                     "-90.0"
                     "90.0"
                    )
                    (strcat (STAHTXT STA3) "+" (STATXT STA3) " " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:AIPROFLIST))) 0)))
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 12.7)
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "REGENMODE" REGENMODE)
 (setvar "CMDECHO" CMDECHO)
 (setvar "DIMZIN" DIMZIN)
 (setvar "CLAYER" CLAYER)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "SPLINETYPE" SPLINETYPE)
 (setvar "SPLINESEGS" SPLINESEGS)
 (setvar "PLINETYPE" PLINETYPE)
 (setvar "TEXTSTYLE" TEXTSTYLE)
);
;
;    Program Written by Robert Livingston 00/03/07
;
;    ALINE is a utility for attaching a line to the end of a line or arc
;
;
(defun C:ALINE (/ *error* ANG ANG1 ANG2 ANGBASE ANGDIR CMDECHO DELTA DRAWLINE
                  DX DY ENT ENTLIST L OSMODE P P1 P2 PC R R2 TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (princ msg)
  ;(setq *error* nil)
 )

 (defun DRAWLINE (P1 P2)
  (entmake (list (cons 0 "LINE")
                 (cons 10 P1)
                 (cons 11 P2)
           )
  )
 )
 
 (command "._UCS" "W")

 (setq ENT (entsel))
 (if (/= ENT nil)
  (progn
   (setq P (nth 1 ENT))
   (setq P (list (nth 0 P) (nth 1 P)))
   (setq ENT (car ENT))
   (setq ENTLIST (entget ENT))
   (if (/= (setq L (getdist "\nEnter length :")) nil)
    (progn
     (if (= (cdr (assoc 0 ENTLIST)) "LINE")
      (progn
       (setq P1 (cdr (assoc 10 ENTLIST)))
       (setq P1 (list (nth 0 P1) (nth 1 P1)))
       (setq P2 (cdr (assoc 11 ENTLIST)))
       (setq P2 (list (nth 0 P2) (nth 1 P2)))
       (if (< (distance P P2) (distance P P1))
        (progn
         (setq TMP P1)
         (setq P1 P2)
         (setq P2 TMP)
        )
       )
       (setq ANG (angle P2 P1))
       (setq P (list (+ (nth 0 P1) (+ (* L (cos ANG))))
                     (+ (nth 1 P1) (+ (* L (sin ANG))))
               )
       )
       (DRAWLINE P1 P)
      )
      (progn
       (if (= (cdr (assoc 0 ENTLIST)) "ARC")
        (progn
         (setq PC (cdr (assoc 10 ENTLIST)))
         (setq PC (list (nth 0 PC) (nth 1 PC)))
         (setq R2 (cdr (assoc 40 ENTLIST)))
         (setq ANG1 (cdr (assoc 50 ENTLIST)))
         (setq ANG2 (cdr (assoc 51 ENTLIST)))
         (setq P1 (list (+ (nth 0 PC) (* R2 (cos ANG1)))
                        (+ (nth 1 PC) (* R2 (sin ANG1)))))
         (setq ANG1 (- ANG1 (/ pi 2.0)))
         (setq P2 (list (+ (nth 0 PC) (* R2 (cos ANG2)))
                        (+ (nth 1 PC) (* R2 (sin ANG2)))))
         (setq ANG2 (+ ANG2 (/ pi 2.0)))
         (setq ANG ANG1)
         (if (< (distance P P2) (distance P P1))
          (progn
           (setq TMP P1)
           (setq P1 P2)
           (setq P2 TMP)
           (setq ANG ANG2)
          )
         )
         (setq P (list (+ (nth 0 P1) (+ (* L (cos ANG))))
                       (+ (nth 1 P1) (+ (* L (sin ANG))))
                 )
         )
         (DRAWLINE P1 P)
        )
        (progn
         (if (/= (setq ENTLIST (RFL:GETSPIRALDATA ENT)) nil)
          (progn
           (setq TMP (nth 0 (RFL:SPIRALSTAOFF P ENT)))
           (if (< (- TMP (nth 3 ENTLIST)) (- (RFL:GETSPIRALLS ENT) TMP))
            (progn
             (setq P1 (RFL:SPIRALXY (list (nth 3 ENTLIST) 0.0) ENT))
             (setq ANG (angle (nth 1 ENTLIST) (nth 0 ENTLIST)))
             (if (> (nth 3 ENTLIST) 0.0)
              (progn
               (if (> (sin (- (angle (nth 1 ENTLIST) (nth 0 ENTLIST)) (angle (nth 2 ENTLIST) (nth 1 ENTLIST)))) 0.0)
                (setq TMP -1.0)
                (setq TMP 1.0)
               )
               (setq ANG (+ ANG
                            (* TMP
                               (expt (nth 3 ENTLIST) 2)
                               (RFL:GETSPIRALTHETA ENT)
                               (/ 1.0 (expt (RFL:GETSPIRALLS ENT) 2))
                            )
                         )
               )
              )
             )
            )
            (progn
             (setq P1 (nth 2 ENTLIST))
             (setq ANG (angle (nth 1 ENTLIST) (nth 2 ENTLIST)))
            )
           )
           (setq P (list (+ (nth 0 P1) (* L (cos ANG)))
                         (+ (nth 1 P1) (* L (sin ANG)))))
           (DRAWLINE P1 P)
          )
          (progn
           (princ "\n*** ENTITY NOT SPIRAL/ARC/LINE ***")
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setq P2 P2)
)
;
;
;    Program Written by Robert Livingston 00/03/07
;
;    ASPIRAL is a utility for attaching a spiral
;
;
(defun C:ASPIRAL (/ *error* A ANG ANG1 ANG2 ANGBASE ANGDIR CMDECHO DIR ENT ENTLIST
                    GETR L L0 LR LS MSG OSMODE P P1 P2 PC R R1 R2 SR1 SR2 THETA TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (princ msg)
  ;(setq *error* nil)
 )

 (command "._UCS" "W")

 (defun GETR (ENT P / ENTLIST)
  (setq ENTLIST (entget ENT))
  (if (= "LINE" (cdr (assoc 0 ENTLIST)))
   (eval 0.0)
   (if (= "ARC" (cdr (assoc 0 ENTLIST)))
    (eval (cdr (assoc 40 ENTLIST)))
    (if (/= (setq ENTLIST (RFL:GETSPIRALDATA ENT)) nil)
     (if (< (- (distance P (nth 0 ENTLIST)) (last ENTLIST)) (distance P (nth 2 ENTLIST)))
      (if (= 0.0 (last ENTLIST))
       (eval 0.0)
       (/ (* (RFL:GETSPIRALR ENT) (RFL:GETSPIRALLS ENT)) (last ENTLIST))
      )
      (RFL:GETSPIRALR ENT)
     )
     (eval 0.0)
    )
   )
  )
 )

 (setq ENT (entsel))
 (if (/= ENT nil)
  (progn
   (setq P (nth 1 ENT))
   (setq P (list (nth 0 P) (nth 1 P)))
   (setq ENT (car ENT))
   (setq ENTLIST (entget ENT))
   (setq SR1 (getreal (strcat "\nEnter start radius (enter 0 for tangent) <" (rtos (GETR ENT P)) "> :")))
   (if (= SR1 nil) (setq SR1 (GETR ENT P)))
   (if (/= (setq SR2 (getreal "\nEnter end radius (enter 0 for tangent) :")) nil)
    (if (= SR1 SR2)
     (princ "\n*** Both ends can not be same radius! ***")
     (progn
      (setq LS nil)
      (while (= LS nil)
       (if (= AL "L")
        (progn
         (setq LS (getreal "Spiral length <return for A>:"))
         (if (= LS nil)
          (progn
           (setq AL "A")
          )
          (if (or (= 0.0 SR1) (= 0.0 SR2))
           (setq A (sqrt (* LS (max SR1 SR2))))
           (setq A (sqrt (abs (/ (* LS SR1 SR2) (- SR2 SR1)))))
          )
         )
        )
        (progn
         (setq A (getreal "Spiral A <return for length>:"))
         (if (= A nil)
          (progn
           (setq AL "L")
          )
          (if (or (= 0.0 SR1) (= 0.0 SR2))
           (setq LS (/ (* A A) (max SR1 SR2)))
           (setq LS (abs (/ (* A A (- SR2 SR1)) SR1 SR2)))
          )
         )
        )
       )
      )
      (if (or (= 0.0 SR1) (= 0.0 SR2))
       (setq L0 0.0)
       (setq L0 (- (/ (* A A) (min SR1 SR2)) LS))
      )
      (setq LS (+ LS L0))
      (initget 1 "Left Right")
      (setq LR (getkword "\n Left or Right : "))
      (if (= LR "Left")
       (setq DIR -1.0)
       (setq DIR 1.0)
      )
      (setq P1 nil ANG nil)
      (if (= (cdr (assoc 0 ENTLIST)) "LINE")
       (progn
        (setq P1 (cdr (assoc 10 ENTLIST)))
        (setq P1 (list (nth 0 P1) (nth 1 P1)))
        (setq P2 (cdr (assoc 11 ENTLIST)))
        (setq P2 (list (nth 0 P2) (nth 1 P2)))
        (if (< (distance P P2) (distance P P1))
         (progn
          (setq TMP P1)
          (setq P1 P2)
          (setq P2 TMP)
         )
        )
        (setq ANG (angle P2 P1))
       )
       (if (= (cdr (assoc 0 ENTLIST)) "ARC")
        (progn
         (setq PC (cdr (assoc 10 ENTLIST)))
         (setq PC (list (nth 0 PC) (nth 1 PC)))
         (setq R2 (cdr (assoc 40 ENTLIST)))
         (setq ANG1 (cdr (assoc 50 ENTLIST)))
         (setq ANG2 (cdr (assoc 51 ENTLIST)))
         (setq P1 (list (+ (nth 0 PC) (* R2 (cos ANG1)))
                        (+ (nth 1 PC) (* R2 (sin ANG1)))))
         (setq ANG1 (- ANG1 (/ pi 2.0)))
         (setq P2 (list (+ (nth 0 PC) (* R2 (cos ANG2)))
                        (+ (nth 1 PC) (* R2 (sin ANG2)))))
         (setq ANG2 (+ ANG2 (/ pi 2.0)))
         (setq ANG ANG1)
         (if (< (distance P P2) (distance P P1))
          (progn
           (setq TMP P1)
           (setq P1 P2)
           (setq P2 TMP)
           (setq ANG ANG2)
          )
         )
        )
        (if (/= (setq ENTLIST (RFL:GETSPIRALDATA ENT)) nil)
         (progn
          (setq TMP (nth 0 (RFL:SPIRALSTAOFF P ENT)))
          (if (< (- TMP (nth 3 ENTLIST)) (- (RFL:GETSPIRALLS ENT) TMP))
           (progn
            (setq P1 (RFL:SPIRALXY (list (nth 3 ENTLIST) 0.0) ENT))
            (setq ANG (angle (nth 1 ENTLIST) (nth 0 ENTLIST)))
            (if (> (nth 3 ENTLIST) 0.0)
             (progn
              (if (> (sin (- (angle (nth 1 ENTLIST) (nth 0 ENTLIST)) (angle (nth 2 ENTLIST) (nth 1 ENTLIST)))) 0.0)
               (setq TMP -1.0)
               (setq TMP 1.0)
              )
              (setq ANG (+ ANG
                           (* TMP
                              (expt (nth 3 ENTLIST) 2)
                              (RFL:GETSPIRALTHETA ENT)
                              (/ 1.0 (expt (RFL:GETSPIRALLS ENT) 2))
                           )
                        )
              )
             )
            )
           )
           (progn
            (setq P1 (nth 2 ENTLIST))
            (setq ANG (angle (nth 1 ENTLIST) (nth 2 ENTLIST)))
           )
          )
         )
         (progn
          (princ "\n*** ENTITY NOT SPIRAL/ARC/LINE ***")
         )
        )
       )
      )
      (if (/= nil P)
       (if (or (= SR1 0.0) (and (/= SR2 0.0) (> SR1 SR2)))
        (progn
         (if (= L0 0.0)
          (progn
           (setq R (max SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
           (setq P P1)
          )
          (progn
           (setq R (min SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
           (setq ANG2 (/ L0 (* 2.0 (max SR1 SR2))))
           (setq ANG (+ ANG (* DIR ANG2)))
           (setq P (list (+ (nth 0 P1) (* -1.0 (max SR1 SR2) (RFL:SPIRALFXR ANG2) (cos ANG)) (* -1.0 DIR (max SR1 SR2) (RFL:SPIRALFYR ANG2) (sin ANG)))
                         (+ (nth 1 P1) (* -1.0 (max SR1 SR2) (RFL:SPIRALFXR ANG2) (sin ANG)) (* DIR (max SR1 SR2) (RFL:SPIRALFYR ANG2) (cos ANG)))
                   )
           )
          )
         )
         (setq PLT P)
         (setq PST (list (+ (nth 0 P) (* R (RFL:SPIRALFXR THETA) (cos ANG)) (* DIR R (RFL:SPIRALFYR THETA) (sin ANG)))
                         (+ (nth 1 P) (* R (RFL:SPIRALFXR THETA) (sin ANG)) (* -1.0 DIR R (RFL:SPIRALFYR THETA) (cos ANG)))
                   )
         )
         (setq TMP (- (* R (RFL:SPIRALFXR THETA)) (/ (* R (RFL:SPIRALFYR THETA)) (RFL:TAN THETA))))
         (setq PLTST (list (+ (nth 0 P) (* TMP (cos ANG)))
                           (+ (nth 1 P) (* TMP (sin ANG)))
                     )
         )
         (RFL:DRAWSPIRAL PLT PLTST PST L0 0.0)
        )
        (progn
         (if (= L0 0.0)
          (progn
           (setq R (max SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
          )
          (progn
           (setq R (min SR1 SR2))
           (setq THETA (/ LS (* 2.0 R)))
          )
         )
         (setq PST P1)
         (setq TMP (/ (* R (RFL:SPIRALFYR THETA)) (sin THETA)))
         (setq PLTST (list (+ (nth 0 P1) (* TMP (cos ANG)))
                           (+ (nth 1 P1) (* TMP (sin ANG)))
                     )
         )
         (setq TMP (- (* R (RFL:SPIRALFXR THETA)) (/ (* R (RFL:SPIRALFYR THETA)) (RFL:TAN THETA))))
         (setq ANG (+ (* -1.0 DIR THETA) ANG))
         (setq PLT (list (+ (nth 0 PLTST) (* TMP (cos ANG)))
                         (+ (nth 1 PLTST) (* TMP (sin ANG)))
                   )
         )
         (RFL:DRAWSPIRAL PLT PLTST PST L0 0.0)
        )
       )
      )
     )
    )
   )
  )
 )



 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
)
;
;
;     Program written by Robert Livingston, 05-09-15
;
;     C:ALIGN23DP creats a 3D polyline based on an alignment and profile
;
;
(defun C:ALIGN23DP (/ *error* ANGDIR ANGBASE CMDECHO OSMODE P OS REGENMODE S STEP STA STA1 STA2 STAMIN STAMAX Z1 Z2)
 (setq REGENMODE (getvar "REGENMODE"))
 (setvar "REGENMODE" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 
 (command "._UNDO" "M")

 (defun *error* (msg)
  (setvar "REGENMODE" REGENMODE)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  ;(setq *error* nil)
  (print msg)
 )

 (if (and (/= nil RFL:ALIGNLIST) (= nil RFL:PVILIST))
  (progn
   (princ "\nNo vertical alignment exists - setting up interpretation...")
   (setq STA1 (car (RFL:STAOFF (setq Z1 (getpoint "\nSelect point near start of alignment : ")))))
   (if (= nil STA1)
    (princ "Problem computing station...")
    (progn
     (setq Z1 (caddr Z1))
     (if (= Z1 0.0)
      (progn
       (setq Z1 (getreal "\n0.000 elevation found for start point, press <return> to accept or enter another value : "))
       (if (= nil Z1) (setq Z1 0.0))
      )
     )
     (setq STA2 (car (RFL:STAOFF (setq Z2 (getpoint "\nSelect point near end of alignment : ")))))
     (if (= nil STA2)
      (princ "Problem computing station...")
      (progn
       (setq Z2 (caddr Z2))
       (if (= Z2 0.0)
        (progn
         (setq Z2 (getreal "\n0.000 elevation found for end point, press <return> to accept or enter another value : "))
         (if (= nil Z2) (setq Z2 0.0))
        )
       )
       (setq RFL:PVILIST (list (list STA1 Z1 "L" 0.0) (list STA2 Z2 "L" 0.0)))
      )
     )
    )
   )
  )
 )

 (if (or (= nil RFL:ALIGNLIST) (= nil RFL:PVILIST))
  (alert "Profile and/or Alignment not defined")
  (progn
   (setq STEP 0.0)
   (while (= 0.0 STEP) (setq STEP (getdist "Enter step size (> zero) : ")))
   (setq OS (getreal "O/S (<return> = 0.0) : "))
   (if (= OS nil) (setq OS 0.0))
   (setq STAMIN (max (caar RFL:ALIGNLIST) (caar RFL:PVILIST)))
   (setq STAMAX (min (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)) (caar (reverse RFL:PVILIST))))
   (setq STA STAMIN)
   (command "._3DPOLY")
   (while (< STA STAMAX)
    (setq P (append (RFL:XY (list STA OS)) (list (RFL:ELEVATION STA))))
    (if (/= OS 0.0)
     (progn
      (setq S (RFL:SUPER STA))
      (if (= nil S) (setq S (list 0.0 0.0)))
      (if (< OS 0.0)
       (setq S (car S))
       (setq S (cadr S))
      )
      (setq P (list (car P)
                    (cadr P)
                    (+ (caddr P) (* (abs OS) S 0.01))
              )
      )
     )
    )
    (command P)
    (setq STA (+ STA STEP))
   )
   (if (/= STAEND (+ STA STEP))
    (progn
     (setq P (append (RFL:XY (list STAEND 0.0)) (list (RFL:ELEVATION STAEND))))
     (command P)
    )
   )
   (command "")
  )
 )

 (setvar "REGENMODE" REGENMODE)
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 99/06/21
;
;     C:ALIGN2PROF utilizes the (RFL:PROFPOINT) command to creat a profile from points along an alignment
;
;
(defun C:ALIGN2PROF (/ ATTREQ CMDECHO ELEV ENT ENTLIST OSMODE P1 P2 PPICK PT STATION)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))

 (command "LINE")
 (princ "\nSelect spot elevation block :")
 (setq ENT (entsel))
 (setq PPICK (car (cdr ENT)))
 (setq PPICK (list (nth 0 PPICK) (nth 1 PPICK) 0.0))
 (setq ENT (car ENT))
 (while (/= ENT nil)
  (setq ENTLIST (entget ENT))
  (if (or (= "AECC_POINT" (cdr (assoc 0 ENTLIST)))
          (and (= 1 (cdr (assoc 66 ENTLIST)))
               (= "INSERT" (cdr (assoc 0 ENTLIST)))
          )
          (= "LINE" (cdr (assoc 0 ENTLIST)))
      )
   (progn
    (if (= "AECC_POINT" (cdr (assoc 0 ENTLIST)))
     (progn
      (setq PT (cdr (assoc 11 ENTLIST)))
      (setq ELEV (nth 2 PT))
     )
     (progn
      (if (= "LINE" (cdr (assoc 0 ENTLIST)))
       (progn
        (setq P1 (cdr (assoc 10 ENTLIST)))
        (setq P1 (list (nth 0 P1) (nth 1 P1) 0.0))
        (setq P2 (cdr (assoc 11 ENTLIST)))
        (setq P2 (list (nth 0 P2) (nth 1 P2) 0.0))
        (if (< (distance P1 PPICK) (distance P2 PPICK))
         (progn
          (setq PT P1)
          (setq ELEV (last (cdr (assoc 10 ENTLIST))))
         )
         (progn
          (setq PT P2)
          (setq ELEV (last (cdr (assoc 11 ENTLIST))))
         )
        )
       )
       (progn
        (setq PT (cdr (assoc 10 ENTLIST)))
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
        (setq ELEV nil)
        (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
         (if (or (= "ELEV" (cdr (assoc 2 ENTLIST))) (= "ELEVATION" (cdr (assoc 2 ENTLIST))))
          (setq ELEV (atof (if (= (substr (cdr (assoc 1 ENTLIST)) 1 1) "(")
                            (substr (cdr (assoc 1 ENTLIST)) 2)
                            (cdr (assoc 1 ENTLIST))
                           )
                     )
          )
         )
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
        )
       )
      )
     )
    )
    (if (= ELEV nil)
     (princ "\n*** NO ELEVATION FOR THIS BLOCK ***")
     (progn
      (setq STATION nil)
      (setq STATION (car (RFL:STAOFF PT)))
      (if (= STATION nil)
       (princ "\n*** POINT NOT ON ALIGNMENT ***")
       (progn
        (command (RFL:PROFPOINT STATION ELEV))
       )
      )
     )
    )
   )
   (princ "\n*** NOT A VALID BLOCK ***")
  )
  (princ "\nSelect spot elevation block :")
  (setq ENT (car (entsel)))
 )
 (command "")

 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
);
;
;   Program written by Robert Livingston, 15-02-03
;
;   CBCPROF is a utility for drawing and labelling vertical profiles
;
;
;
(setq RFL:BCPROFLIST nil)
(defun C:BCPROF (/ ANG ANGBASE ANGDIR C CANCEL CIRCDIA CLAYER CMDECHO DIMZIN DIRECTIONT DIRECTIONS ENT
                   FIXNUMBER FONTNAME G1 G2 K L1 L2 L3 LUPREC MLMR MLMRT MLMRB OSMODE P P1 P2 PLINETYPE PREVENT
                   REGENMODE REP SCALETEXT SIDE SIGN STA STA1 STA2 STA3 SPLINETYPE
                   SPLINESEGS TEXTSTYLE TOL Z1 Z2 Z3 ZMAX ZMIN)
 (setq REGENMODE (getvar "REGENMODE"))
 (setvar "REGENMODE" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq SPLINETYPE (getvar "SPLINETYPE"))
 (setvar "SPLINETYPE" 5)
 (setq SPLINESEGS (getvar "SPLINESEGS"))
 (setvar "SPLINESEGS" 65)
 (setq PLINETYPE (getvar "PLINETYPE"))
 (setvar "PLINETYPE" 0)
 (setq TEXTSTYLE (getvar "TEXTSTYLE"))

 (setq TOL 0.000001)
 
 (setq CIRCDIA 1.0)
 
 (setq PREVENT nil)
 
 (command "._UNDO" "M")

; (if (= nil (findfile "BC MoT.shx"))
  (if (= nil (findfile "ROMANS.SHX"))
   (progn
    (princ "\n!!!!!  Warning - BC MoT.SHX not found, subsituting TXT.SHX")
    (setq FONTNAME "TXT.SHX")
   )
   (progn
    (princ "\n!!!!!  Warning - BC MoT.SHX not found, subsituting ROMANS.SHX")
    (setq FONTNAME "ROMANS.SHX")
   )
  )
;  (progn
;   (setq FONTNAME "BC MoT.SHX")
;  )
; )

 (defun SIGN (X)
  (if (< X 0)
   (eval -1.0)
   (eval 1.0)
  )
 )

 (defun FIXNUMBER (TILE)
  (set_tile TILE (itoa (atoi (get_tile TILE))))
 )

 (defun SCALETEXT (H / ENT ENTLIST)
  (setq ENT (entlast))
  (setq ENTLIST (entget ENT))
  (setq ENTLIST (subst (cons 40 (* (cdr (assoc "SCALE" RFL:PROFDEFLIST)) H))
                       (assoc 40 ENTLIST)
                       ENTLIST
                )
  )
  (entmod ENTLIST)
  (entupd ENT)
 )

 (defun SETBCPROFLIST (/ ACCEPTBCPROF CANCELBCPROF DCLID)
  (defun ACCEPTBCPROF ()
   (setq RFL:BCPROFLIST
    (list
     (cons "DPROF" (get_tile "DPROF"))
     (cons "LSLOPE" (get_tile "LSLOPE"))
     (cons "LL" (get_tile "LL"))
     (cons "LK" (get_tile "LK"))
     (cons "CNODES" (get_tile "CNODES"))
     (cons "DPVI" (get_tile "DPVI"))
     (cons "LPVI" (get_tile "LPVI"))
     (cons "LBVC" (get_tile "LBVC"))
     (cons "LHIGH" (get_tile "LHIGH"))
     (cons "LELEVATIONS" (get_tile "LELEVATIONS"))
     (cons "RAB" (get_tile "RAB"))
     (cons "DIRECTION" (cond ((= (get_tile "DIRLEFT") "1") "DIRLEFT")
                             ((= (get_tile "DIRRIGHT") "1") "DIRRIGHT")
                             ((= (get_tile "DIRUP") "1") "DIRUP")
                             ((= (get_tile "DIRDOWN") "1") "DIRDOWN")
                       )
     )
     (cons "KPREC" (get_tile "KPREC"))
     (cons "LPREC" (get_tile "LPREC"))
     (cons "SLOPEPREC" (get_tile "SLOPEPREC"))
     (cons "STAPREC" (get_tile "STAPREC"))
     (cons "ELEVPREC" (get_tile "ELEVPREC"))
    )
   )
   (setq CANCEL 0)
   (done_dialog)
   (unload_dialog DCL_ID)
  )

  (defun CANCELBCPROF ()
   (setq CANCEL 1)
   (done_dialog)
   (unload_dialog DCL_ID)
  )

  (if (= nil RFL:BCPROFLIST)
   (setq RFL:BCPROFLIST
    (list
     (cons "DPROF" "0")
     (cons "LSLOPE" "1")
     (cons "LL" "1")
     (cons "LK" "1")
     (cons "CNODES" "1")
     (cons "DPVI" "1")
     (cons "LPVI" "1")
     (cons "LBVC" "1")
     (cons "LHIGH" "1")
     (cons "LELEVATIONS" "0")
     (cons "RAB" "0")
     (cons "DIRECTION" "DIRRIGHT")
     (cons "KPREC" "1")
     (cons "LPREC" "0")
     (cons "SLOPEPREC" "3")
     (cons "STAPREC" "3")
     (cons "ELEVPREC" "3")
    )
   )
  )

  (if (= BCPROFDCLNAME nil)
   (progn
    (setq BCPROFDCLNAME (vl-filename-mktemp "rfl.dcl"))
    (RFL:MAKEDCL BCPROFDCLNAME "BCPROF")
   )
   (if (= nil (findfile BCPROFDCLNAME))
    (progn
     (setq BCPROFDCLNAME (vl-filename-mktemp "rfl.dcl"))
     (RFL:MAKEDCL BCPROFDCLNAME "BCPROF")
    )
   )
  )
  (setq DCL_ID (load_dialog BCPROFDCLNAME))
  (if (not (new_dialog "BCPROF" DCL_ID)) (exit))

  (setq RFLALIGNSLBNAME "rflAlign.slb")
  (if (= nil (findfile RFLALIGNSLBNAME))
   (progn
    (setq RFLALIGNSLBNAME (vl-filename-mktemp "rfl.slb"))
    (RFL:MAKERFLSLB RFLALIGNSLBNAME)
   )
  )
  (start_image "IMAGE")
  (slide_image 0 0 (- (dimx_tile "IMAGE") 1) (- (dimy_tile "IMAGE") 1) (strcat RFLALIGNSLBNAME "(BCPROF)"))
  (end_image)

  (set_tile "DPROF" (cdr (assoc "DPROF" RFL:BCPROFLIST)))
  (set_tile "LSLOPE" (cdr (assoc "LSLOPE" RFL:BCPROFLIST)))
  (set_tile "LL" (cdr (assoc "LL" RFL:BCPROFLIST)))
  (set_tile "LK" (cdr (assoc "LK" RFL:BCPROFLIST)))
  (set_tile "CNODES" (cdr (assoc "CNODES" RFL:BCPROFLIST)))
  (set_tile "DPVI" (cdr (assoc "DPVI" RFL:BCPROFLIST)))
  (set_tile "LPVI" (cdr (assoc "LPVI" RFL:BCPROFLIST)))
  (set_tile "LBVC" (cdr (assoc "LBVC" RFL:BCPROFLIST)))
  (set_tile "LHIGH" (cdr (assoc "LHIGH" RFL:BCPROFLIST)))
  (set_tile "LELEVATIONS" (cdr (assoc "LELEVATIONS" RFL:BCPROFLIST)))
  (set_tile "RAB" (cdr (assoc "RAB" RFL:BCPROFLIST)))
  (set_tile (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "1")
  (set_tile "KPREC" (cdr (assoc "KPREC" RFL:BCPROFLIST)))
  (set_tile "LPREC" (cdr (assoc "LPREC" RFL:BCPROFLIST)))
  (set_tile "SLOPEPREC" (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST)))
  (set_tile "STAPREC" (cdr (assoc "STAPREC" RFL:BCPROFLIST)))
  (set_tile "ELEVPREC" (cdr (assoc "ELEVPREC" RFL:BCPROFLIST)))

  (action_tile "KPREC" "(FIXNUMBER \"KPREC\")")
  (action_tile "LPREC" "(FIXNUMBER \"LPREC\")")
  (action_tile "SLOPEPREC" "(FIXNUMBER \"SLOPEPREC\")")
  (action_tile "STAPREC" "(FIXNUMBER \"STAPREC\")")
  (action_tile "ELEVPREC" "(FIXNUMBER \"ELEVPREC\")")
  (action_tile "OK" "(ACCEPTBCPROF)")
  (action_tile "CANCEL" "(CANCELBCPROF)")

  (start_dialog)
 )

 (if (= nil C:RPROF)
  (progn
   (princ "\n*****  PROFILE UTILITIES NOT LOADED  *****")
  )
  (progn
   (C:RPROF)
   (if (= nil RFL:PVILIST)
    (progn
     (princ "\n*****  PROFILE NOT DEFINED  *****")
    )
    (progn
     (RFL:PROFDEF)
     (if (= nil RFL:PROFDEFLIST)
      (progn
       (princ "\n*****  PROFILE LOCATION NOT DEFINED  *****")
      )
      (progn
       (SETBCPROFLIST)
       (if (and (= (cdr (assoc "DPROF" RFL:BCPROFLIST)) "1")
                (= CANCEL 0)
           )
        (progn
         (if (= (tblsearch "LAYER" (cdr (assoc "PLAYER" RFL:PROFDEFLIST))) nil)
          (progn
           (command "._LAYER" "M" (cdr (assoc "PLAYER" RFL:PROFDEFLIST)) "")
          )
          (progn
           (setvar "CLAYER" (cdr (assoc "PLAYER" RFL:PROFDEFLIST)))
          )
         )
         (command "._PLINE")
         (foreach TMP RFL:PVILIST
          (progn
           (if (< (cadddr TMP) TOL)
            (command (RFL:PROFPOINT (car TMP) (cadr TMP)))
            (progn
             (setq C 0)
             (while (<= C 64)
              (command (RFL:PROFPOINT (+ (- (car TMP) (/ (cadddr TMP) 2.0)) (* (/ (cadddr TMP) 64) C))
                                  (RFL:ELEVATION (+ (- (car TMP) (/ (cadddr TMP) 2.0)) (* (/ (cadddr TMP) 64) C)))
                       )
              )
              (setq C (+ C 1))
             )
            )
           )
          )
         )
         (command "")
         (setq ENT (entlast))
         (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
        )
       )
       (if (and (or (= (cdr (assoc "LSLOPE" RFL:BCPROFLIST)) "1")
                    (= (cdr (assoc "LL" RFL:BCPROFLIST)) "1")
                    (= (cdr (assoc "LK" RFL:BCPROFLIST)) "1")
                    (= (cdr (assoc "CNODES" RFL:BCPROFLIST)) "1")
                    (= (cdr (assoc "DPVI" RFL:BCPROFLIST)) "1")
                    (= (cdr (assoc "LPVI" RFL:BCPROFLIST)) "1")
                    (= (cdr (assoc "LBVC" RFL:BCPROFLIST)) "1")
                    (= (cdr (assoc "LELEVATIONS" RFL:BCPROFLIST)) "1")
                )
                (= CANCEL 0)
           )
        (progn
         (if (or (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) 1)
                 (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) nil)
             )
          (cond ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRLEFT")
                 (setq DIRECTIONT 1 DIRECTIONS 1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRRIGHT")
                 (setq DIRECTIONT -1 DIRECTIONS 1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRUP")
                 (setq DIRECTIONT 1 DIRECTIONS 1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRDOWN")
                 (setq DIRECTIONT -1 DIRECTIONS 1)
                )
          )
          (cond ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRLEFT")
                 (setq DIRECTIONT 1 DIRECTIONS -1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRRIGHT")
                 (setq DIRECTIONT -1 DIRECTIONS -1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRUP")
                 (setq DIRECTIONT -1 DIRECTIONS -1)
                )
                ((= (cdr (assoc "DIRECTION" RFL:BCPROFLIST)) "DIRDOWN")
                 (setq DIRECTIONT 1 DIRECTIONS -1)
                )
          )
         )
         (if (= DIRECTIONT 1)
          (progn
           (if (= (cdr (assoc "RAB" RFL:BCPROFLIST)) "0")
            (progn
             (setq MLMR "MR")
             (setq MLMRT "R")
             (setq MLMRB "TR")
             (setq SIDE 1)
            )
            (progn
             (setq MLMR "ML")
             (setq MLMRT "L")
             (setq MLMRB "TL")
             (setq SIDE -1)
            )
           )
          )
          (progn
           (if (= (cdr (assoc "RAB" RFL:BCPROFLIST)) "0")
            (progn
             (setq MLMR "ML")
             (setq MLMRT "L")
             (setq MLMRB "TL")
             (setq SIDE 1)
            )
            (progn
             (setq MLMR "MR")
             (setq MLMRT "R")
             (setq MLMRB "TR")
             (setq SIDE -1)
            )
           )
          )
         )
         (setq ZMAX (nth 1 (nth 0 RFL:PVILIST)))
         (setq ZMIN (nth 1 (nth 0 RFL:PVILIST)))
         (setq C 1)
         (while (< C (length RFL:PVILIST))
          (if (> (nth 1 (nth C RFL:PVILIST)) ZMAX)
           (setq ZMAX (nth 1 (nth C RFL:PVILIST)))
          )
          (if (< (nth 1 (nth C RFL:PVILIST)) ZMIN)
           (setq ZMIN (nth 1 (nth C RFL:PVILIST)))
          )
          (setq C (+ C 1))
         )
         (setq C 1)
         (if (= (tblsearch "LAYER" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST))) nil)
          (progn
           (command "._LAYER" "M" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST)) "")
          )
          (progn
           (setvar "CLAYER" (cdr (assoc "PTLAYER" RFL:PROFDEFLIST)))
          )
         )
;         (if (or (= (cdr (assoc "CNODES" RFL:BCPROFLIST)) "1")
;                 (= (cdr (assoc "DPVI" RFL:BCPROFLIST)) "1")
;             )
;          (if (= (tblsearch "BLOCK" "CIRC") nil)
;           (progn
;            (entmake)
;            (setq ENTLIST (list (cons 0 "BLOCK")
;                                (cons 2 "CIRC")
;                                (list 10 0.0 0.0 0.0)
;                                (cons 70 0)
;                          )
;            )
;            (entmake ENTLIST)
;            (setq ENTLIST (list (cons 0 "CIRCLE")
;                                (cons 8 "0")
;                                (list 10 0.0 0.0 0.0)
;                                (cons 40 5.0)
;                          )
;            )
;            (entmake ENTLIST)
;            (setq ENTLIST (list (cons 0 "ENDBLK")
;                          )
;            )
;            (entmake ENTLIST)
;           )
;          )
;         )
         (if (= (tblsearch "STYLE" "3.5mm") nil)
          (progn
           (command "._STYLE" "3.5mm" FONTNAME "3.5" "1.0" "0.0" "N" "N" "N")
          )
          (progn
           (setvar "TEXTSTYLE" "3.5mm")
          )
         )
         (setq STA1 (nth 0 (nth 0 RFL:PVILIST)))
         (setq Z1 (nth 1 (nth 0 RFL:PVILIST)))
         (setq L1 (nth 3 (nth 0 RFL:PVILIST)))
         (setq P (RFL:PROFPOINT STA1 Z1))
         (if (= (cdr (assoc "CNODES" RFL:BCPROFLIST)) "1")
          (progn
;           (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
;           (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
;           (setq ENT (entlast))
;           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (command "._CIRCLE" P (* CIRCDIA (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (command "._LINE"
                    (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 1.0)))
                    (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 11.0)))
                    ""
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          )
         )
         (if (= (cdr (assoc "LBVC" RFL:BCPROFLIST)) "1")
          (progn
           (setq TMP (/ (fix (+ 0.5
                                (* Z1
                                   (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                                )
                             )
                        )
                        (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                     )
           )
           (command "._TEXT"
                    MLMRT
                    (list (+ (nth 0 P) (* DIRECTIONT 0.875 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                          (+ (nth 1 P) (* SIDE 12.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                    )
                    (if (= DIRECTIONT 1)
                     "-90.0"
                     "90.0"
                    )
                    (strcat "STA  " (RFL:STATXT STA1))
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 3.5)
           (command "._TEXT"
                    MLMRB
                    (list (+ (nth 0 P) (* DIRECTIONT -0.875 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                          (+ (nth 1 P) (* SIDE 12.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                    )
                    (if (= DIRECTIONT 1)
                     "-90.0"
                     "90.0"
                    )
                    (strcat "PIVC  " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0)) " m")
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 3.5)
          )
         )
         (while (< (+ C 1) (length RFL:PVILIST))
          (if (= (tblsearch "STYLE" "3.5mm") nil)
           (progn
            (command "._STYLE" "3.5mm" FONTNAME "3.5" "1.0" "0.0" "N" "N" "N")
           )
           (progn
            (setvar "TEXTSTYLE" "3.5mm")
           )
          )
          (setq STA1 (nth 0 (nth (- C 1) RFL:PVILIST)))
          (setq Z1 (nth 1 (nth (- C 1) RFL:PVILIST)))
          (setq L1 (nth 3 (nth (- C 1) RFL:PVILIST)))
          (setq STA2 (nth 0 (nth C RFL:PVILIST)))
          (setq Z2 (nth 1 (nth C RFL:PVILIST)))
          (setq L2 (nth 3 (nth C RFL:PVILIST)))
          (setq STA3 (nth 0 (nth (+ C 1) RFL:PVILIST)))
          (setq Z3 (nth 1 (nth (+ C 1) RFL:PVILIST)))
          (setq L3 (nth 3 (nth (+ C 1) RFL:PVILIST)))
          (setq G1 (* (/ (- Z2 Z1) (- STA2 STA1)) 100.0))
          (setq G2 (* (/ (- Z3 Z2) (- STA3 STA2)) 100.0))
          (setq STA (/ (+ (+ STA1
                             (/ L1 2.0)
                          )
                          (- STA2
                             (/ L2 2.0)
                          )
                       )
                       2.0
                    )
          )
          (if (= (cdr (assoc "LSLOPE" RFL:BCPROFLIST)) "1")
           (progn
;            (setq TMP (/ (fix (+ 0.5
;                                 (* G1
;                                    (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))))
;                                 )
;                              )
;                         )
;                         (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))))
;                      )
;            )
            (command "._TEXT"
                     (if (= SIDE 1) "C" "TC")
                     (list (+ (car (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                              (* 1.75
                                 SIDE
                                 (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                                 (sin (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)))
                                 (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                              )
                           )
                           (+ (cadr (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                              (* -1.75
                                 SIDE
                                 (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                                 (cos (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)))
                                 (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                              )
                           )
                    )
                     (if (= DIRECTIONS 1)
                      (* (angle (RFL:PROFPOINT STA1 Z1) (RFL:PROFPOINT STA2 Z2)) (/ 180.0 pi))
                      (* (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)) (/ 180.0 pi))
                     )
                     (strcat (if (> G1 0.0) "+" "") (rtos G1 2 (if (> (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))) 0)) "%")
            )
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (SCALETEXT 3.5)
           )
          )
          (setq P (RFL:PROFPOINT STA2 Z2))
          (if (= (cdr (assoc "LPVI" RFL:BCPROFLIST)) "1")
           (progn
            (setq TMP (/ (fix (+ 0.5
                                 (* Z2
                                    (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                                 )
                              )
                         )
                         (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                      )
            )
            (command "._TEXT"
                     MLMRT
                     (list (+ (nth 0 P) (* DIRECTIONT 0.875 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                           (+ (nth 1 P) (* SIDE 12.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                     )
                     (if (= DIRECTIONT 1)
                      "-90.0"
                      "90.0"
                     )
                     (strcat "STA  " (RFL:STATXT STA2))
            )
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (SCALETEXT 3.5)
            (command "._TEXT"
                     MLMRB
                     (list (+ (nth 0 P) (* DIRECTIONT -0.875 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                           (+ (nth 1 P) (* SIDE 12.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                     )
                     (if (= DIRECTIONT 1)
                      "-90.0"
                      "90.0"
                     )
                     (strcat "PIVC  " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0)) " m")
            )
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (SCALETEXT 3.5)
           )
          )
          (if (= (cdr (assoc "DPVI" RFL:BCPROFLIST)) "1")
           (progn
;            (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
;            (command "._INSERT" "CIRC" (RFL:PROFPOINT STA2 Z2) (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
;            (setq ENT (entlast))
;            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (command "._CIRCLE" (RFL:PROFPOINT STA2 Z2) (* CIRCDIA (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (command "._LINE"
                     (list (nth 0 (RFL:PROFPOINT STA2 Z2)) (+ (nth 1 (RFL:PROFPOINT STA2 Z2)) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 1.0)))
                     (list (nth 0 (RFL:PROFPOINT STA2 Z2)) (+ (nth 1 (RFL:PROFPOINT STA2 Z2)) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 11.0)))
                     ""
            )
            (setq ENT (entlast))
            (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (if (> L2 0.0)
           (progn
            (setq K (abs (/ L2
                            (- G2 G1)
                         )
                    )
            )
            (if (= (cdr (assoc "LL" RFL:BCPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* L2
                                      (expt 10.0 (atoi (cdr (assoc "LPREC" RFL:BCPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "LPREC" RFL:BCPROFLIST))))
                        )
              )
              (command "._TEXT"
                       "TC"
                       (list (nth 0 P) (- (nth 1 P) (* SIDE 50.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                       "0.0"
                       (strcat (rtos TMP 2 (if (> (atoi (cdr (assoc "LPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "LPREC" RFL:BCPROFLIST))) 0)) " VC")
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 3.5)
             )
            )
            (if (= (cdr (assoc "LK" RFL:BCPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* K
                                      (expt 10.0 (atoi (cdr (assoc "KPREC" RFL:BCPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "KPREC" RFL:BCPROFLIST))))
                        )
              )
              (command "._TEXT"
                       "TC"
                       (list (nth 0 P) (- (nth 1 P) (* SIDE 50.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST))) (* 5.25 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                       "0.0"
                       (strcat "K = "(rtos TMP 2 (if (> (atoi (cdr (assoc "KPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "KPREC" RFL:BCPROFLIST))) 0)))
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 3.5)
             )
            )
            (if (= (cdr (assoc "DPVI" RFL:BCPROFLIST)) "1")
             (progn
              (setq ANG (angle P (RFL:PROFPOINT STA1 Z1)))
              (command "._LINE"
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   1.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   1.0
                                   (sin ANG)
                                )
                             )
                       )
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   11.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   11.0
                                   (sin ANG)
                                )
                             )
                       )
                       ""
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (setq ANG (angle P (RFL:PROFPOINT STA3 Z3)))
              (command "._LINE"
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   1.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   1.0
                                   (sin ANG)
                                )
                             )
                       )
                       (list (+ (nth 0 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   11.0
                                   (cos ANG)
                                )
                             )
                             (+ (nth 1 P)
                                (* (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                                   11.0
                                   (sin ANG)
                                )
                             )
                       )
                       ""
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             )
            )
            (setq P (RFL:PROFPOINT (- STA2 (/ L2 2.0)) (RFL:ELEVATION (- STA2 (/ L2 2.0)))))
            (if (= (cdr (assoc "LBVC" RFL:BCPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* (RFL:ELEVATION (- STA2 (/ L2 2.0)))
                                      (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                        )
              )
              (command "._TEXT"
                       MLMR
                       (list (nth 0 P)
                             (+ (nth 1 P) (* SIDE 12.75 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                       )
                       (if (= DIRECTIONT 1)
                        "-90.0"
                        "90.0"
                       )
                       (strcat "BVC  " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0)) " m")
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 3.5)
             )
            )
            (if (= (cdr (assoc "CNODES" RFL:BCPROFLIST)) "1")
             (progn
;              (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
;              (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
;              (setq ENT (entlast))
;              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (command "._CIRCLE" P (* CIRCDIA (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (command "._LINE"
                       (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 1.0)))
                       (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 11.0)))
                       ""
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             )
            )
            (setq P (RFL:PROFPOINT (+ STA2 (/ L2 2.0)) (RFL:ELEVATION (+ STA2 (/ L2 2.0)))))
            (if (= (cdr (assoc "LBVC" RFL:BCPROFLIST)) "1")
             (progn
              (setq TMP (/ (fix (+ 0.5
                                   (* (RFL:ELEVATION (+ STA2 (/ L2 2.0)))
                                      (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                                   )
                                )
                           )
                           (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                        )
              )
              (command "._TEXT"
                       MLMR
                       (list (nth 0 P)
                             (+ (nth 1 P) (* SIDE 12.75 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                       )
                       (if (= DIRECTIONT 1)
                        "-90.0"
                        "90.0"
                       )
                       (strcat "EVC  " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0)) " m")
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (SCALETEXT 3.5)
             )
            )
            (if (= (cdr (assoc "CNODES" RFL:BCPROFLIST)) "1")
             (progn
;              (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
;              (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
;              (setq ENT (entlast))
;              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (command "._CIRCLE" P (* CIRCDIA (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
              (command "._LINE"
                       (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 1.0)))
                       (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 11.0)))
                       ""
              )
              (setq ENT (entlast))
              (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             )
            )
            (if (= (cdr (assoc "LELEVATIONS" RFL:BCPROFLIST)) "1")
             (progn
              (if (= (tblsearch "STYLE" "2.5mm") nil)
               (progn
                (command "._STYLE" "2.5mm" FONTNAME "2.5" "1.0" "0.0" "N" "N" "N")
               )
               (progn
                (setvar "TEXTSTYLE" "2.5mm")
               )
              )
              (setq STA (float (* (+ (fix (/ (- STA2 (/ L2 2.0)) 20.0)) 1) 20.0)))
              (while (< STA (+ STA2 (/ L2 2.0)))
               (if (= SIDE 1)
                (setq P (RFL:PROFPOINT STA ZMAX))
                (setq P (RFL:PROFPOINT STA ZMIN))
               )
               (setq TMP (/ (fix (+ 0.5
                                    (* (RFL:ELEVATION STA)
                                       (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                                    )
                                 )
                            )
                            (expt 10.0 (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))))
                         )
               )
               (command "._TEXT"
                        MLMR
                        (list (nth 0 P) (+ (nth 1 P) (* SIDE 400.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST)))))
                        (if (= DIRECTIONT 1)
                         "-90.0"
                         "90.0"
                        )
                        (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0))
               )
               (setq ENT (entlast))
               (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
               (SCALETEXT 10.16)
               (setq STA (+ STA 20.0))
              )
             )
            )
           )
          )
          (setq C (+ C 1))
         )
         (setq STA (/ (+ (+ STA2
                            (/ L2 2.0)
                         )
                         (- STA3
                            (/ L3 2.0)
                         )
                      )
                      2.0
                   )
         )
         (if (= (tblsearch "STYLE" "3.5mm") nil)
          (progn
           (command "._STYLE" "3.5mm" FONTNAME "3.5" "1.0" "0.0" "N" "N" "N")
          )
          (progn
           (setvar "TEXTSTYLE" "3.5mm")
          )
         )
         (if (= (cdr (assoc "LSLOPE" RFL:BCPROFLIST)) "1")
          (progn
;           (setq TMP (/ (fix (+ 0.5
;                                (* G2
;                                   (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))))
;                                )
;                             )
;                        )
;                        (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))))
;                     )
;           )
           (command "._TEXT"
                    (if (= SIDE 1) "C" "TC")
                    (list (+ (car (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                             (* 1.75
                                SIDE
                                (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                                (sin (angle (RFL:PROFPOINT STA3 Z3) (RFL:PROFPOINT STA2 Z2)))
                                (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                             )
                          )
                          (+ (cadr (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                             (* -1.75
                                SIDE
                                (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                                (cos (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)))
                                (cdr (assoc "SCALE" RFL:PROFDEFLIST))
                             )
                          )
                   )
                   (if (= DIRECTIONS 1)
                    (* (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA3 Z3)) (/ 180.0 pi))
                    (* (angle (RFL:PROFPOINT STA3 Z3) (RFL:PROFPOINT STA2 Z2)) (/ 180.0 pi))
                   )
                   (strcat (if (> G2 0.0) "+" "") (rtos G2 2 (if (> (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))) 0)) "%")
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 3.5)
          )
         )
         (setq P (RFL:PROFPOINT STA3 Z3))
         (if (= (cdr (assoc "CNODES" RFL:BCPROFLIST)) "1")
          (progn
;           (if (= nil (tblsearch "BLOCK" "CIRC")) (RFL:MAKEENT "CIRC"))
;           (command "._INSERT" "CIRC" P (cdr (assoc "SCALE" RFL:PROFDEFLIST)) "" "")
;           (setq ENT (entlast))
;           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (command "._CIRCLE" P (* CIRCDIA (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (command "._LINE"
                    (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 1.0)))
                    (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "SCALE" RFL:PROFDEFLIST)) 11.0)))
                    ""
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          )
         )
         (if (= (cdr (assoc "LBVC" RFL:BCPROFLIST)) "1")
          (progn
           (setq TMP (/ (fix (+ 0.5
                                (* Z3
                                   (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))))
                                )
                             )
                        )
                        (expt 10.0 (atoi (cdr (assoc "SLOPEPREC" RFL:BCPROFLIST))))
                     )
           )
           (command "._TEXT"
                    MLMRT
                    (list (+ (nth 0 P) (* DIRECTIONT 0.875 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                          (+ (nth 1 P) (* SIDE 12.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                    )
                    (if (= DIRECTIONT 1)
                     "-90.0"
                     "90.0"
                    )
                    (strcat "STA  " (RFL:STATXT STA3))
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 3.5)
           (command "._TEXT"
                    MLMRB
                    (list (+ (nth 0 P) (* DIRECTIONT -0.875 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                          (+ (nth 1 P) (* SIDE 12.0 (cdr (assoc "SCALE" RFL:PROFDEFLIST))))
                    )
                    (if (= DIRECTIONT 1)
                     "-90.0"
                     "90.0"
                    )
                    (strcat "PIVC  " (rtos TMP 2 (if (> (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0) (atoi (cdr (assoc "ELEVPREC" RFL:BCPROFLIST))) 0)) " m")
           )
           (setq ENT (entlast))
           (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           (SCALETEXT 3.5)
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "REGENMODE" REGENMODE)
 (setvar "CMDECHO" CMDECHO)
 (setvar "DIMZIN" DIMZIN)
 (setvar "CLAYER" CLAYER)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "SPLINETYPE" SPLINETYPE)
 (setvar "SPLINESEGS" SPLINESEGS)
 (setvar "PLINETYPE" PLINETYPE)
 (setvar "TEXTSTYLE" TEXTSTYLE)
);
;
;
;     Program written by Robert Livingston, 2016-09-07
;
;     C:BESTCORNER builds an alignment (Spi-Curve-Spi) based on two tangents to fit a selected polyline
;
;
(setq RFL:BESTCORNERLSMIN 0.0)
(setq RFL:BESTCORNERLSMAX 0.0)
(setq RFL:BESTCORNERR 100.0)
(setq RFL:BESTCORNERSTEP 10.0)
(setq RFL:BESTCORNERSTEPMIN 0.001)
(defun C:BESTCORNER (/ AL1 AL2 AL3 AL4 AL5 AL6 ANG
                       CALCE CALCSUME2 CMDECHO CONTINUEFLAG ENT ENTLIST MAKEALIGNLIST LS1 LS2
                       N1 N2 P P0 P1 P11 P12 P2 P21 P22 PLIST STEP STEPMIN
                       SUME2 SUME2PREV SUME2MIN SUME21 SUME22 SUME23 SUME24 SUME25 SUME26 R TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 
 (defun CALCSUME2 (RFL:ALIGNLIST PLIST / P S SUME2)
  (setq SUME2 nil)
  (if RFL:ALIGNLIST
   (foreach P PLIST
    (if (setq S (RFL:STAOFF P))
     (if SUME2
      (setq SUME2 (+ SUME2 (expt (cadr S) 2)))
      (setq SUME2 (expt (cadr S) 2))
     )
    )
   )
   (setq SUME2 1E99)
  )
  SUME2
 )
; Below is an attempt to weight spirals
; (defun CALCSUME2 (ALSAVE PLIST / ALNODE ISSPIRAL P RFL:ALIGNLIST S SUME2)
;  (setq SUME2 nil)
;  (if ALSAVE
;   (foreach ALNODE ALSAVE
;    (setq RFL:ALIGNLIST (list ALNODE))
;    (if (listp (last ALNODE))
;     (setq ISSPIRAL T)
;     (setq ISSPIRAL nil)
;    )
;    (foreach P PLIST
;     (if (setq S (RFL:STAOFF P))
;      (if SUME2
;       (setq SUME2 (+ SUME2 (* (expt (cadr S) 2) (if ISSPIRAL 100.0 1.0))))
;       (setq SUME2 (* (expt (cadr S) 2) (if ISSPIRAL 100.0 1.0)))
;      )
;     )
;    )
;   )
;   (setq SUME2 1E99)
;  )
;  SUME2
; )
 (defun CALCE (RFL:ALIGNLIST PLIST / P S E)
  (setq E 0.0)
  (if RFL:ALIGNLIST
   (foreach P PLIST
    (if (setq S (RFL:STAOFF P))
     (setq E (max E (abs (cadr S))))
    )
   )
  )
  E
 )
 (defun MAKEALIGNLIST (P1 P0 P2 LS1 R LS2 / RFL:ALIGNLIST A1 A2 ANG ANG0 ANG1 ANG2 D1 D2 DIR 
                                            PA PB PC PD PLT PLTST1 PLTST2 PST
                                            S X X0 X1 X2 X3 Y Y0 Y1 Y2 Y3)
  (setq RFL:ALIGNLIST nil)
  (setq P1 (list (car P1) (cadr P1)))
  (setq P0 (list (car P0) (cadr P0)))
  (setq P2 (list (car P2) (cadr P2)))
  (if (> (sin (- (angle P0 P2) (angle P1 P0))) 0.0)
   (setq DIR 1.0)
   (setq DIR -1.0)
  )
  (setq ANG (- pi (RFL:ANGLE3P P1 P0 P2)))
  (setq D1 (distance P1 P0))
  (setq A1 (angle P1 P0))
  (setq D2 (distance P0 P2))
  (setq A2 (angle P0 P2))
  (setq S 0.0)
  (setq ANG1 (/ LS1 (* 2.0 R)))
  (setq ANG2 (/ LS2 (* 2.0 R)))
  (setq ANG0 (- ANG ANG1 ANG2))
  (if (> ANG0 0.0)
   (progn
    (setq X (* R (RFL:TAN (/ ANG0 2.0))))
    (setq X1 (* R (RFL:SPIRALFXR ANG1)))
    (setq Y1 (* R (RFL:SPIRALFYR ANG1)))
    (setq X2 (* R (RFL:SPIRALFXR ANG2)))
    (setq Y2 (* R (RFL:SPIRALFYR ANG2)))
    (setq X0 (+ X1
                (* X (cos ANG1))
                (* X (cos (+ ANG1 ANG0)))
                (* X2 (cos ANG))
                (* Y2 (sin ANG))
             )
    )
    (setq Y0 (+ Y1
                (* X (sin ANG1))
                (* X (sin (+ ANG1 ANG0)))
                (* X2 (sin ANG))
                (* Y2 -1.0 (cos ANG))
             )
    )
    (setq X3 (/ Y0 (RFL:TAN ANG)))
    (setq PA (list (+ (car P1) (* (cos A1) (- D1 (- X0 X3))))
                   (+ (cadr P1) (* (sin A1) (- D1 (- X0 X3))))
             )
    )
    (setq PB (list (+ (car PA) (* (cos A1) X1) (* -1.0 DIR (sin A1) Y1))
                   (+ (cadr PA) (* (sin A1) X1) (* DIR (cos A1) Y1))
             )
    )
    (if (= 0.0 LS1)
     (setq PLTST1 PA)
     (setq PLTST1 (list (+ (car PA) (* (cos A1) (- X1 (/ Y1 (RFL:TAN ANG1)))))
                        (+ (cadr PA) (* (sin A1) (- X1 (/ Y1 (RFL:TAN ANG1)))))
                  )
     )
    )
    (setq PC (list (+ (car PB)
                      (* (cos A1) (+ (* (cos ANG1) X) (* (cos (+ ANG1 ANG0)) X)))
                      (* -1.0 DIR (sin A1) (+ (* (sin ANG1) X) (* (sin (+ ANG1 ANG0)) X)))
                   )
                   (+ (cadr PB)
                      (* (sin A1) (+ (* (cos ANG1) X) (* (cos (+ ANG1 ANG0)) X)))
                      (* DIR (cos A1) (+ (* (sin ANG1) X) (* (sin (+ ANG1 ANG0)) X)))
                   )
             )
    )
    (setq PD (list (+ (car PC) (* (cos A2) X2) (* DIR (sin A2) Y2))
                   (+ (cadr PC) (* (sin A2) X2) (* -1.0 DIR (cos A2) Y2))
             )
    )
    (if (= 0.0 LS2)
     (setq PLTST2 PD)
     (setq PLTST2 (list (- (car PD) (* (cos A2) (- X2 (/ Y2 (RFL:TAN ANG2)))))
                        (- (cadr PD) (* (sin A2) (- X2 (/ Y2 (RFL:TAN ANG2)))))
                  )
     )
    )
    (setq RFL:ALIGNLIST (list (list S P1 PA 0.0)))
    (setq S (+ S (distance P1 PA)))
    (if (/= LS1 0.0)
     (progn
      (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PA PB (list PA PLTST1 PB 0.0)
                                              )
                                        )
                      )
      )
      (setq S (+ S LS1))
     )
    )
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PB PC (* DIR (RFL:TAN (/ ANG0 4.0)))))))
    (setq S (+ S (* R ANG0)))
    (if (/= LS2 0.0)
     (progn
      (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PC PD (list PD PLTST2 PC 0.0)
                                              )
                                        )
                      )
      )
      (setq S (+ S LS2))
     )
    )
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PD P2 0.0))))
   )
  )
  RFL:ALIGNLIST
 )
 (command "._UNDO" "M")
 (setq RFL:ALIGNLIST nil)
 (if (setq ENT (car (entsel "\nFirst tangent : ")))
  (if (= (cdr (assoc 0 (setq ENTLIST (entget ENT)))) "LINE")
   (progn
    (setq P11 (cdr (assoc 10 ENTLIST)))
    (setq P12 (cdr (assoc 11 ENTLIST)))
    (if (setq ENT (car (entsel "\nSecond tangent : ")))
     (if (= (cdr (assoc 0 (setq ENTLIST (entget ENT)))) "LINE")
      (progn
       (setq P21 (cdr (assoc 10 ENTLIST)))
       (setq P22 (cdr (assoc 11 ENTLIST)))
       (if (setq P0 (inters P11 P12 P21 P22 nil))
        (progn
         (if (> (distance P11 P0) (distance P12 P0))
          (setq P1 P11)
          (setq P1 P12)
         )
         (if (> (distance P21 P0) (distance P22 P0))
          (setq P2 P21)
          (setq P2 P22)
         )
         (if (setq PLIST (RFL:GETPLIST (car (entsel "\nPolyline to fit : "))))
          (progn
           (if (< (distance (last PLIST) P1) (distance (car PLIST) P1))
            (setq PLIST (reverse PLIST))
           )
           (while (and (/= nil PLIST)
                       (> (RFL:ANGLE3P P0 P1 (car PLIST)) (/ pi 2.0))
                  )
            (setq PLIST (cdr PLIST))
           )
           (setq PLIST (reverse PLIST))
           (while (and (/= nil PLIST)
                       (> (RFL:ANGLE3P P0 P2 (car PLIST)) (/ pi 2.0))
                  )
            (setq PLIST (cdr PLIST))
           )
           (setq PLIST (reverse PLIST))
           (if PLIST
            (progn
             (setq ANG (- pi (RFL:ANGLE3P P1 P0 P2)))
             (setq TMP (vl-sort PLIST (function (lambda (N1 N2) (< (distance P0 N1) (distance P0 N2))))))
             (setq TMP (reverse TMP))
             (while (> (length TMP) 10)
              (setq TMP (cdr TMP))
             )
             (setq TMP (reverse TMP))
             (if (>= (length TMP) 3)
              (* 1.5 (setq RFL:BESTCORNERR (cadr (RFL:BESTCIRCLE TMP)))) ; Use 1.5 factor : solution seems better when starting high
              100.0
             )
             (if RFL:BESTCORNERR
              (setq RFL:BESTCORNERR (float (fix RFL:BESTCORNERR)))
              (setq RFL:BESTCORNERR 100.0)
             )
             (setq RFL:BESTCORNERLSMAX (float (fix (* 2.0 RFL:BESTCORNERR (/ ANG 2.0)))))
             
             
             (if (setq TMP (getdist (strcat "\nMaximum spiral length (enter 0 for no spirals) <" (rtos RFL:BESTCORNERLSMAX) "> : ")))
              (setq RFL:BESTCORNERLSMAX TMP)
             )
             (if (= RFL:BESTCORNERLSMAX 0.0)
              (setq RFL:BESTCORNERLSMIN 0.0)
              (if (setq TMP (getdist (strcat "\nMinimum spiral length <" (rtos RFL:BESTCORNERLSMIN) "> : ")))
               (setq RFL:BESTCORNERLSMIN TMP)
              )
             )
             (if (setq TMP (getdist (strcat "\nRadius (start value) <" (rtos RFL:BESTCORNERR) "> : ")))
              (setq RFL:BESTCORNERR TMP)
             )
             (if (setq TMP (getdist (strcat "\nStart step size <" (rtos RFL:BESTCORNERSTEP) "> : ")))
              (setq RFL:BESTCORNERSTEP TMP)
             )
             (if (setq TMP (getdist (strcat "\nStop step size <" (rtos RFL:BESTCORNERSTEPMIN) "> : ")))
              (setq RFL:BESTCORNERSTEPMIN TMP)
             )
             (setq CONTINUEFLAG T
;                   LS1 (if (= RFL:BESTCORNERLSMAX 0.0)
;                        0.0
;                        (/ RFL:BESTCORNERR 10.0)
;                       )
;                   LS2 (if (= RFL:BESTCORNERLSMAX 0.0)
;                        0.0
;                        (/ RFL:BESTCORNERR 10.0)
;                       )
                   LS1 RFL:BESTCORNERLSMAX
                   LS2 RFL:BESTCORNERLSMAX
                   R RFL:BESTCORNERR
                   STEP RFL:BESTCORNERSTEP
                   STEPMIN RFL:BESTCORNERSTEPMIN
                   RFL:ALIGNLIST (MAKEALIGNLIST P1 P0 P2 LS1 R LS2)
                   SUME2MIN 1E99
             )
             (if (= nil RFL:ALIGNLIST)
              (princ "\n! No valid solution for start values !")
              (while CONTINUEFLAG
               (command "_.delay" 0)
               (setq SUME2PREV SUME2MIN)
               (princ (strcat "\nStep = " (rtos STEP) ", LS1 = " (rtos LS1) ", R = " (rtos R) ", LS2 = " (rtos LS2) ", Sum E^2 = " (rtos SUME2MIN 2 16)))
               (setq SUME21 (if (< (- LS1 STEP) RFL:BESTCORNERLSMIN)
                             1E99
                             (CALCSUME2 (setq AL1 (MAKEALIGNLIST P1 P0 P2 (- LS1 STEP) R LS2)) PLIST)
                            )
               )
               (setq SUME22 (if (or (= 0.0 RFL:BESTCORNERLSMAX)
                                    (> (+ LS1 STEP) RFL:BESTCORNERLSMIN)
                                )
                             1E99
                             (CALCSUME2 (setq AL2 (MAKEALIGNLIST P1 P0 P2 (+ LS1 STEP) R LS2)) PLIST)
                            )
               )
               (setq SUME23 (if (< (- R STEP) 0.0)
                             1E99
                             (CALCSUME2 (setq AL3 (MAKEALIGNLIST P1 P0 P2 LS1 (- R STEP) LS2)) PLIST)
                            )
               )
               (setq SUME24 (CALCSUME2 (setq AL4 (MAKEALIGNLIST P1 P0 P2 LS1 (+ R STEP) LS2)) PLIST))
               (setq SUME25 (if (< (- LS2 STEP) RFL:BESTCORNERLSMIN)
                             1E99
                             (CALCSUME2 (setq AL5 (MAKEALIGNLIST P1 P0 P2 LS1 R (- LS2 STEP))) PLIST)
                            )
               )
               (setq SUME26 (if (or (= 0.0 RFL:BESTCORNERLSMAX)
                                    (> (+ LS2 STEP) RFL:BESTCORNERLSMIN)
                                )
                             1E99
                             (CALCSUME2 (setq AL6 (MAKEALIGNLIST P1 P0 P2 LS1 R (+ LS2 STEP))) PLIST)
                            )
               )
               (setq SUME2MIN (min SUME2PREV SUME21 SUME22 SUME23 SUME24 SUME25 SUME26))
               (if (< STEP STEPMIN)
                (setq CONTINUEFLAG nil)
                (cond ((= SUME2MIN SUMEPREV)
                       (setq STEP (/ STEP 2))
                      )
                      ((= SUME2MIN SUME21)
                       (setq LS1 (- LS1 STEP)
                             RFL:ALIGNLIST AL1
                       )
                      )
                      ((= SUME2MIN SUME22)
                       (setq LS1 (+ LS1 STEP)
                             RFL:ALIGNLIST AL2
                       )
                      )
                      ((= SUME2MIN SUME23)
                       (setq R (- R STEP)
                             RFL:ALIGNLIST AL3
                       )
                      )
                      ((= SUME2MIN SUME24)
                       (setq R (+ R STEP))
                             RFL:ALIGNLIST AL4
                      )
                      ((= SUME2MIN SUME25)
                       (setq LS2 (- LS2 STEP)
                             RFL:ALIGNLIST AL5
                       )
                      )
                      ((= SUME2MIN SUME26)
                       (setq LS2 (+ LS2 STEP)
                             RFL:ALIGNLIST AL6
                       )
                      )
                      (T
                       (setq STEP (/ STEP 2))
                      )
                )
               )
              )
             )
            )
            (princ "\n! No adjacent points found !")
           )
          )
         )
        )
        (princ "\n! No point of intersection found ! ")
       )
      )
      (princ "\n! Not a line entity ! ")
     )
    )
   ) 
   (princ "\n! Not a line entity ! ")
  )
 )
 (setvar "CMDECHO" CMDECHO)
 (princ (strcat "\nMaximum offset = " (rtos (CALCE (reverse (cdr (reverse (cdr RFL:ALIGNLIST)))) PLIST)) "\n"))
 nil
);
;
;   Program written by Robert Livingston, 99/10/21
;
;   CPI returns the PI point for a selected curve
;
;
(defun C:CPI (/ ANG ANG1 ANG2 GSPIRALPI D ENT ENTLIST P PC R THETA)
 (defun GSPIRALPI (ENT / ENTLIST ENTLIST2 SPI)
  (setq ENTLIST2 (cdr (assoc -3 (entget ENT '("*")))))
  (setq ENTLIST (cdr (assoc "DCA_FIGURE_XENT" ENTLIST2)))
  (if (or (= ENTLIST nil) (= (assoc 1011 ENTLIST) nil))
   (progn
    (setq SPIRALLIST nil)
   )
   (progn
    (while (/= (car (car ENTLIST)) 1011)
     (setq ENTLIST (cdr ENTLIST))
    )
    (setq ENTLIST (cdr ENTLIST))
    (while (/= (car (car ENTLIST)) 1011)
     (setq ENTLIST (cdr ENTLIST))
    )
    (setq SPI (cdr (car ENTLIST)))
   )
  )
  (setq SPI SPI)
 )
 (setq P nil)
 (if (/= nil (setq ENT (car (entsel "\nSelect arc or LDD spiral : "))))
  (progn
   (setq ENTLIST (entget ENT))
   (if (/= (cdr (assoc 0 ENTLIST)) "ARC")
    (progn
     (setq P (GSPIRALPI ENT))
     (if (/= nil P)
      (command "_NON" P)
     )
    )
    (progn
     (setq PC (cdr (assoc 10 ENTLIST)))
     (setq ANG1 (cdr (assoc 50 ENTLIST)))
     (setq ANG2 (cdr (assoc 51 ENTLIST)))
     (setq ANG (/ (+ ANG1 ANG2) 2.0))
     (setq THETA (- ANG2 ANG1))
     (if (or (= THETA pi) (= THETA (* 2.0 pi)))
      (princ "\n*** No PI exists ***")
      (progn
       (setq R (cdr (assoc 40 ENTLIST)))
       (setq D (/ R (cos (/ THETA 2.0))))
       (setq P (list (+ (nth 0 PC) (* D (cos ANG)))
                     (+ (nth 1 PC) (* D (sin ANG)))))
      )
     )
    )
   )
  )
 )
(command "_NON" P));
;
;   Program written by Robert Livingston, 98/06/11
;
;   C:DALIGN draws the current alignment
;
;
(defun C:DALIGN (/ AL ANGBASE ANGDIR CMDECHO OSMODE REP SFLAG STEP STEPSTA)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (command "._UNDO" "M")
 (command "._UCS" "W")

 (if (/= nil RFL:ALIGNLIST)
  (progn
   (setq AL RFL:ALIGNLIST)
   (setq SFLAG 0)
   (while (/= AL nil)
    (if (listp (last (car AL)))
     (progn
      (setq SFLAG 1)
     )
    )
    (setq AL (cdr AL))
   )
   (if (= SFLAG 0)
    (RFL:DRAWALIGN)
    (RFL:DRAWALIGN2)
   )
  )
  (princ "\n*** ALIGNMENT NOT SET ***\n")
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
);
;
;   Program written by Robert Livingston, 98/06/11
;
;   C:DALIGNOS draws the current alignment at a specified offset
;
;
(defun C:DALIGNOS (/ AL ANGBASE ANGDIR CMDECHO OS OSMODE REP SFLAG)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (command "._UNDO" "M")
 (command "._UCS" "W")

 (if (/= nil RFL:ALIGNLIST)
  (progn
   (setq OS (getreal "\nEnter offset (-ve = left, +ve = right) : "))
   (setq AL RFL:ALIGNLIST)
   (setq SFLAG 0)
   (while (/= AL nil)
    (if (listp (last (car AL)))
     (progn
      (setq SFLAG 1)
     )
    )
    (setq AL (cdr AL))
   )
   (if (= SFLAG 0)
    (RFL:DRAWALIGNOS OS)
    (RFL:DRAWALIGNOS2 OS)
   )
  )
  (princ "\n*** ALIGNMENT NOT SET ***\n")
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;   Program written by Robert Livingston, 99/11/15
;
;   DPROF draws the current profile
;
;
(defun C:DPROF (/ ANGBASE ANGDIR CMDECHO OSMODE REP STEP STEPSTA)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (if (/= nil RFL:PVILIST)
  (progn
   (RFL:PROFDEF)
   (initget "Yes No")
   (setq REP (getkword "\nDraw profile (<Yes>/No) :"))
   (if (= REP nil) (setq REP "Yes"))
   (if (= REP "Yes")
    (progn
     (initget "Yes No")
     (setq REP (getkword "\nErase current profile entities (Yes/<No>) :"))
     (if (= REP nil) (setq REP "No"))
     (if (= REP "Yes") (command "._ERASE" (ssget "X" (list (cons 8 (cdr (assoc "PLAYER" RFL:PROFDEFLIST))))) ""))
     (RFL:DRAWPROF RFL:PVILIST)
    )
   )
   (initget "Yes No")
   (setq REP (getkword "\nCircle high/low points (Yes/<No>) :"))
   (if (= REP nil) (setq REP "No"))
   (if (= REP "Yes") (RFL:PROFHIGHLOW 1.0))
  )
  (progn
   (princ "\n*** PROFILE NOT SET - RUN GPROF OR RPROF ***\n")
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;   Program written by Robert Livingston, 99/11/15
;
;   DPROFOG draws on the current layer the current OG profile defined in RFL:OGLIST
;
;
(defun C:DPROFOG (/ ANGBASE ANGDIR CMDECHO OSMODE C)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (if (/= nil RFL:OGLIST)
  (progn
   (RFL:PROFDEF)
   (setq C 0)
   (command "._PLINE")
   (while (< C (length RFL:OGLIST))
    (command (RFL:PROFPOINT (nth 0 (nth C RFL:OGLIST)) (nth 1 (nth C RFL:OGLIST))))
    (setq C (+ C 1))
   )
   (command "")
  )
  (progn
   (princ "\n*** OG PROFILE NOT SET ***\n")
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    C:DSPIRAL draws a reverse engineered DCA spiral at the end of a selected line
;
;
(defun C:DSPIRAL (/ ANG CMDECHO DIR ENT ENTLIST FX FY LR P P1 P2 PLT PLTST PST THETA)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq ENT (entsel "\nSelect line : "))
 (if (/= ENT nil) 
  (progn
   (setq P (car (cdr ENT)))
   (setq P (list (car P) (cadr P)))
   (setq ENT (car ENT))
   (if (= (cdr (assoc 0 (setq ENTLIST (entget ENT)))) "LINE")
    (progn
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq P1 (list (car P1) (cadr P1)))
     (setq P2 (cdr (assoc 11 ENTLIST)))
     (setq P2 (list (car P2) (cadr P2)))
     (if (< (distance P P1) (distance P P2))
      (progn
       (setq TMP P1)
       (setq P1 P2)
       (setq P2 TMP)
      )
     )
     (setq ANG (angle P1 P2))
     (if (/= (setq R (getreal "Radius : ")) nil)
      (if (/= (setq L (getreal "Length : ")) nil)
       (progn
        (initget 1 "Left Right")
        (setq LR (getkword "\n Left or Right : "))
        (if (= LR "Left")
         (setq DIR 1.0)
         (setq DIR -1.0)
        )
        (setq THETA (/ L (* 2.0 R)))
        (setq FX (* R (RFL:SPIRALFXR THETA)))
        (setq FY (* R (RFL:SPIRALFYR THETA)))
        (setq PLT P2)
        (setq PST (list (+ (car PLT) (* FX (cos ANG)) (* DIR -1.0 FY (sin ANG)))
                        (+ (cadr PLT) (* FX (sin ANG)) (* DIR FY (cos ANG)))))
        (setq PLTST (list (+ (car PLT) (* (- FX (/ FY (RFL:TAN THETA))) (cos ANG)))
                          (+ (cadr PLT) (* (- FX (/ FY (RFL:TAN THETA))) (sin ANG))))) 
        (RFL:DRAWSPIRAL PLT PLTST PST 0.0 0.0)
       )
      )
     )
    )
   )
  )
 )
 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   DSUPER inserts SUPER blocks along the current alignment
;
;
(defun C:DSUPER (/ AL DIMZIN CMDECHO REP SFLAG STEP STEPSTA)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (RFL:DSUPER)

 (setvar "CMDECHO" CMDECHO)
);
;
;     Program written by Robert Livingston, 03/05/12
;
;     DAYLIGHT is a utility for 'Daylighting' 3D Polylines
;
;
(setq RFL:DAYLIGHTLIST (list (cons "DITCHBACK" 6.0)
                             (cons "DITCHWIDTH" 4.0)
                             (cons "DITCHDEPTH" 1.0)
                             (cons "USEDITCH" "1")
                             (cons "FS7" 3.0)
                             (cons "FD6" 6.5)
                             (cons "FS5" 4.0)
                             (cons "FD4" 4.0)
                             (cons "FS3" 5.0)
                             (cons "FD2" 2.5)
                             (cons "FS1" 6.0)
                             (cons "CS1" 5.0)
                             (cons "CD2" 2.0)
                             (cons "CS3" 3.0)
                             (cons "SWATH" 100.0)))
(defun C:DAYLIGHT (/ AECCOBJ ACCEPTDAYLIGHT ANGBASE ANGDIR *error* C CANCEL CANCELDAYLIGHT CATCHLINE
                     CHECKENABLE CHECKNUMBER CMDECHO CURRENTSURFACE
                     DCL_ID ENT ENTLIST GETFROMLIST NODE OBSURFACE OGLINE OGLINELIST OGOFFSETLIST OS OS1 OS2 OSMODE
                     P P1 P2 PD1 PD2 SA1 SA2 STA V1 V2 Z Z1 Z2)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (command "._UNDO" "M")

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "DIMZIN" DIMZIN)
  (princ msg)
  ;(setq *error* nil)
 )

 (defun GETSLOPEINT (OFFSET ELEV SLOPE OGLIST / C ELEV1 ELEV2 ELEV3 OFFSET1 OFFSET2 OFFSET3 TOL)
  (setq TOL 0.000001)
  (setq C 0)
  (setq OFFSET3 nil)
  (setq ELEV3 nil)
  (while (< C (- (length OGLIST) 1))
   (setq OFFSET1 (car (nth C OGLIST)))
   (setq ELEV1 (cadr (nth C OGLIST)))
   (setq OFFSET2 (car (nth (+ C 1) OGLIST)))
   (setq ELEV2 (cadr (nth (+ C 1) OGLIST)))
   (if (< (abs (- OFFSET2 OFFSET1)) TOL)
    (setq C (+ C 1))
    (progn
     (setq OFFSET3 (/ (- (+ (* OFFSET1
                               (/ (- ELEV2 ELEV1)
                                  (- OFFSET2 OFFSET1)
                               )
                            )
                            ELEV
                         )
                         (+ (/ OFFSET SLOPE) ELEV1)
                      )
                      (- (/ (- ELEV2 ELEV1)
                            (- OFFSET2 OFFSET1)
                         )
                         (/ 1.0 SLOPE)
                      )
                   )
     )
     (setq ELEV3 (+ ELEV
                    (/ (- OFFSET3 OFFSET)
                       SLOPE
                    )
                 )
     )
     (if (>= (* (- OFFSET3 OFFSET1) (- OFFSET2 OFFSET3)) 0.0)
      (setq C (length OGLIST))
      (setq C (+ C 1))
     )
    )
   )
  )
  (list OFFSET3 ELEV3)
 )

 (defun GETFILLPOINT ()
  (setq P2 (GETSLOPEINT OS1 Z1 (* -1.0 (RFL:SIGN OS1) (cdr (assoc "FS1" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
  (if (/= nil P2)
   (if (>= (- Z1 (cadr P2)) (cdr (assoc "FD2" RFL:DAYLIGHTLIST)))
    (progn
     (setq P2 (GETSLOPEINT OS1 Z1 (* -1.0 (RFL:SIGN OS1) (cdr (assoc "FS3" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
     (if (>= (- Z1 (cadr P2)) (cdr (assoc "FD4" RFL:DAYLIGHTLIST)))
      (progn
       (setq P2 (GETSLOPEINT OS1 Z1 (* -1.0 (RFL:SIGN OS1) (cdr (assoc "FS5" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
       (if (>= (- Z1 (cadr P2)) (cdr (assoc "FD6" RFL:DAYLIGHTLIST)))
        (setq P2 (GETSLOPEINT OS1 Z1 (* -1.0 (RFL:SIGN OS1) (cdr (assoc "FS7" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
       )
      )
     )
    )
   )
  )
 )

 (defun GETCUTPOINT ()
  (setq P2 (GETSLOPEINT OS1 Z1 (* (RFL:SIGN OS1) (cdr (assoc "CS1" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
  (if (/= nil P2)
   (if (>= (- (cadr P2) Z1) (cdr (assoc "CD2" RFL:DAYLIGHTLIST)))
    (setq P2 (GETSLOPEINT OS1 Z1 (* (RFL:SIGN OS1) (cdr (assoc "CS3" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
   )
  )
 )

 (defun CHECKENABLE ()
  (if (= "1" (get_tile "USEDITCH"))
   (progn
    (mode_tile "DITCHBACK" 0)
    (mode_tile "DITCHWIDTH" 0)
    (mode_tile "DITCHDEPTH" 0)
   )
   (progn
    (mode_tile "DITCHBACK" 1)
    (mode_tile "DITCHWIDTH" 1)
    (mode_tile "DITCHDEPTH" 1)
   )
  )
 )

 (defun CHECKNUMBER (TILE)
  (set_tile TILE (rtos (atof (get_tile TILE))))
 )

 (defun ACCEPTDAYLIGHT ()
  (setq RFL:DAYLIGHTLIST (list (cons "DITCHBACK" (atof (get_tile "DITCHBACK")))
                               (cons "DITCHWIDTH" (atof (get_tile "DITCHWIDTH")))
                               (cons "DITCHDEPTH" (atof (get_tile "DITCHDEPTH")))
                               (cons "USEDITCH" (get_tile "USEDITCH"))
                               (cons "FS7" (atof (get_tile "FS7")))
                               (cons "FD6" (atof (get_tile "FD6")))
                               (cons "FS5" (atof (get_tile "FS5")))
                               (cons "FD4" (atof (get_tile "FD4")))
                               (cons "FS3" (atof (get_tile "FS3")))
                               (cons "FD2" (atof (get_tile "FD2")))
                               (cons "FS1" (atof (get_tile "FS1")))
                               (cons "CS1" (atof (get_tile "CS1")))
                               (cons "CD2" (atof (get_tile "CD2")))
                               (cons "CS3" (atof (get_tile "CS3")))
                               (cons "SWATH" (atof (get_tile "SWATH")))))

  (done_dialog)
  (unload_dialog DCL_ID)
  (setq CANCEL nil)
 )

 (defun CANCELDAYLIGHT ()
  (done_dialog)
  (unload_dialog DCL_ID)
  (setq CANCEL 1)
 )

 (setq OBSURFACE (RFL:GETC3DSURFACE))
 
 (if (or (= nil OBSURFACE) (= nil RFL:ALIGNLIST))
  (princ "\n***** ERROR WITH SURFACE OR ALIGNMENT *****")
  (progn
   (setq ENT (car (entsel "\nSelect 3D polyline :")))
   (if (/= ENT nil)
    (progn
     (setq ENTLIST (entget ENT))
     (if (= (cdr (assoc 0 ENTLIST)) "POLYLINE")
      (progn
       (if (= 0 (logand (cdr (assoc 70 ENTLIST)) 8))
        (princ "\n***** NOT A 3D POLYLINE *****")
        (progn

         (if (= DAYLIGHTDCLNAME nil)
          (progn
           (setq DAYLIGHTDCLNAME (vl-filename-mktemp "rfl.dcl"))
           (RFL:MAKEDCL DAYLIGHTDCLNAME "DAYLIGHT")
          )
          (if (= nil (findfile DAYLIGHTDCLNAME))
           (progn
            (setq DAYLIGHTDCLNAME (vl-filename-mktemp "rfl.dcl"))
            (RFL:MAKEDCL DAYLIGHTDCLNAME "DAYLIGHT")
           )
          )
         )

         (setq DCL_ID (load_dialog DAYLIGHTDCLNAME))
         (if (not (new_dialog "DAYLIGHT" DCL_ID)) (exit))

         (set_tile "DITCHBACK" (rtos (cdr (assoc "DITCHBACK" RFL:DAYLIGHTLIST))))
         (set_tile "DITCHWIDTH" (rtos (cdr (assoc "DITCHWIDTH" RFL:DAYLIGHTLIST))))
         (set_tile "DITCHDEPTH" (rtos (cdr (assoc "DITCHDEPTH" RFL:DAYLIGHTLIST))))
         (set_tile "USEDITCH" (cdr (assoc "USEDITCH" RFL:DAYLIGHTLIST)))
         (set_tile "FS7" (rtos (cdr (assoc "FS7" RFL:DAYLIGHTLIST))))
         (set_tile "FD6" (rtos (cdr (assoc "FD6" RFL:DAYLIGHTLIST))))
         (set_tile "FS5" (rtos (cdr (assoc "FS5" RFL:DAYLIGHTLIST))))
         (set_tile "FD4" (rtos (cdr (assoc "FD4" RFL:DAYLIGHTLIST))))
         (set_tile "FS3" (rtos (cdr (assoc "FS3" RFL:DAYLIGHTLIST))))
         (set_tile "FD2" (rtos (cdr (assoc "FD2" RFL:DAYLIGHTLIST))))
         (set_tile "FS1" (rtos (cdr (assoc "FS1" RFL:DAYLIGHTLIST))))
         (set_tile "CS1" (rtos (cdr (assoc "CS1" RFL:DAYLIGHTLIST))))
         (set_tile "CD2" (rtos (cdr (assoc "CD2" RFL:DAYLIGHTLIST))))
         (set_tile "CS3" (rtos (cdr (assoc "CS3" RFL:DAYLIGHTLIST))))
         (set_tile "SWATH" (rtos (cdr (assoc "SWATH" RFL:DAYLIGHTLIST))))

         (CHECKENABLE)

         (action_tile "DITCHBACK" "(CHECKNUMBER \"DITCHBACK\")")
         (action_tile "DITCHWIDTH" "(CHECKNUMBER \"DITCHWIDTH\")")
         (action_tile "DITCHDEPTH" "(CHECKNUMBER \"DITCHDEPTH\")")
         (action_tile "USEDITCH" "(CHECKENABLE)")
         (action_tile "FS7" "(CHECKNUMBER \"FS7\")")
         (action_tile "FD6" "(CHECKNUMBER \"FD6\")")
         (action_tile "FS5" "(CHECKNUMBER \"FS5\")")
         (action_tile "FD4" "(CHECKNUMBER \"FD4\")")
         (action_tile "FS3" "(CHECKNUMBER \"FS3\")")
         (action_tile "FD2" "(CHECKNUMBER \"FD2\")")
         (action_tile "FS1" "(CHECKNUMBER \"FS1\")")
         (action_tile "CS1" "(CHECKNUMBER \"CS1\")")
         (action_tile "CD2" "(CHECKNUMBER \"CD2\")")
         (action_tile "CS3" "(CHECKNUMBER \"CS3\")")
         (action_tile "SWATH" "(CHECKNUMBER \"SWATH\")")

         (action_tile "OK" "(ACCEPTDAYLIGHT)")
         (action_tile "CANCEL" "(CANCELDAYLIGHT)")

         (start_dialog)

         (if (= nil CANCEL)
          (progn
           (setq CATCHLINE nil)
           (setq ENT (entnext ENT))
           (setq ENTLIST (entget ENT))
           (setq SA1 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
           (setq SA2 (vlax-make-safearray vlax-vbDouble '(0 . 2)))
           (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
            (setq OGLINE nil)
            (setq P1 (cdr (assoc 10 ENTLIST)))
            (setq Z1 (nth 2 P1))
            (setq OS (RFL:STAOFF P1))
            (if (/= nil OS)
             (progn
              (setq STA (car OS))
              (princ (strcat "\n" (rtos STA)))
              (setq OS1 (cadr OS))
              (setq OS2 (+ OS1 (* (RFL:SIGN OS1) (cdr (assoc "SWATH" RFL:DAYLIGHTLIST)))))
              (setq P2 (RFL:XY (list STA OS2)))
              (if (/= nil P2)
               (progn
                (setq P2 (append P2 (list Z1)))
                (setq OGLINE nil)
                (setq OGLINE (vlax-invoke-method OBSURFACE "SampleElevations" (car P1) (cadr p1) (car P2) (cadr p2)))
                (if (/= nil OGLINE)
                 (if (/= 0 (vlax-variant-type OGLINE))
                  (progn
                   (setq OGLINELIST nil)
                   (setq OGLINE (vlax-variant-value OGLINE))
                   (setq C (vlax-safearray-get-l-bound OGLINE 1))
                   (while (<= C (vlax-safearray-get-u-bound OGLINE 1))
                    (setq OGLINELIST (append OGLINELIST (list (list (vlax-safearray-get-element OGLINE C)
                                                                    (vlax-safearray-get-element OGLINE (+ C 1))
                                                                    (vlax-safearray-get-element OGLINE (+ C 2))))))
                    (setq C (+ C 3))
                   )
                   (setq C 0)
                   (setq OGOFFSETLIST nil)
                   (while (< C (length OGLINELIST))
                    (setq OGOFFSETLIST (append OGOFFSETLIST
                                               (list (list (cadr (RFL:STAOFF (nth C OGLINELIST)))
                                                           (last (nth C OGLINELIST))))))
                    (setq C (+ C 1))
                   )
                   (setq NODE nil)
                   (setq PD1 nil)
                   (setq PD2 nil)
                   (if (= "1" (cdr (assoc "USEDITCH" RFL:DAYLIGHTLIST)))
                    (if (> Z1 (cadar OGOFFSETLIST))
                     (progn
                      (GETFILLPOINT)
                      (if (<= (- Z1 (cadr P2)) (cdr (assoc "DITCHDEPTH" RFL:DAYLIGHTLIST)))
                       (progn
                        (setq Z1 (- Z1 (cdr (assoc "DITCHDEPTH" RFL:DAYLIGHTLIST))))
                        (setq PD1 (list (+ OS1 (* (RFL:SIGN OS1)
                                                  (cdr (assoc "DITCHDEPTH" RFL:DAYLIGHTLIST))
                                                  (cdr (assoc "DITCHBACK" RFL:DAYLIGHTLIST))))
                                        Z1))
                        (setq PD2 (list (+ (car PD1) (* (RFL:SIGN OS1)
                                                        (cdr (assoc "DITCHWIDTH" RFL:DAYLIGHTLIST))))
                                        Z1))
                        (setq OS1 (car PD2))
                        (setq P2 (GETSLOPEINT OS1 Z1 (* (RFL:SIGN OS1) (cdr (assoc "CS1" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
                        (if (/= nil P2)
                         (progn
                          (if (>= (- (cadr P2) Z1) (cdr (assoc "CD2" RFL:DAYLIGHTLIST)))
                           (progn
                            (setq P2 (GETSLOPEINT OS1 Z1 (* (RFL:SIGN OS1) (cdr (assoc "CS3" RFL:DAYLIGHTLIST))) OGOFFSETLIST))
                           )
                          )

                          (if (< (* (RFL:SIGN OS1) (- (car P2) OS1)) 0.0)
                           (progn
                            (GETFILLPOINT)
                           )
                          )
                         )
                        )
                       )
                      )
                     )
                     (progn
                      (setq Z1 (- Z1 (cdr (assoc "DITCHDEPTH" RFL:DAYLIGHTLIST))))
                      (setq PD1 (list (+ OS1 (* (RFL:SIGN OS1)
                                                (cdr (assoc "DITCHDEPTH" RFL:DAYLIGHTLIST))
                                                (cdr (assoc "DITCHBACK" RFL:DAYLIGHTLIST))))
                                      Z1))
                      (setq PD2 (list (+ (car PD1) (* (RFL:SIGN OS1)
                                                      (cdr (assoc "DITCHWIDTH" RFL:DAYLIGHTLIST))))
                                      Z1))
                      (setq OS1 (car PD2))
                      (GETCUTPOINT)
                      (if (< (* (RFL:SIGN OS1) (- (car P2) OS1)) 0.0)
                       (progn
                         (GETFILLPOINT)
                       )
                      )
                     )
                    )
                    (if (> Z1 (cadar OGOFFSETLIST))
                     (progn
                      (GETFILLPOINT)
                     )
                     (progn
                      (GETCUTPOINT)
                     )
                    )
                   )
                   (setq CATCHLINE (append CATCHLINE (list (list STA P2 PD1 PD2))))
                  )
                 )
                )
                (setq ENT (entnext ENT))
                (setq ENTLIST (entget ENT))
               )
              )
             )
            )
           )
           (setq C 0)
           (command "._3DPOLY")
           (while (< C (length CATCHLINE))
            (setq NODE (nth C CATCHLINE))
            (setq C (+ C 1))
            (if (/= nil (setq P1 (cadr NODE)))
             (progn
              (setq P (RFL:XY (list (car NODE) (car P1))))
              (if (/= P nil)
               (progn
                (command (append P (cdr P1)))
               )
              )
             )
            )
           )
           (command)
           (setq C 0)
           (command "._3DPOLY")
           (while (< C (length CATCHLINE))
            (setq NODE (nth C CATCHLINE))
            (setq C (+ C 1))
            (if (= nil (setq P1 (caddr NODE)))
             (progn
              (command)
              (command "._3DPOLY")
             )
             (progn
              (setq P (RFL:XY (list (car NODE) (car P1))))
              (if (/= P nil)
               (progn
                (command (append P (cdr P1)))
               )
              )
             )
            )
           )
           (command)
           (setq C 0)
           (command "._3DPOLY")
           (while (< C (length CATCHLINE))
            (setq NODE (nth C CATCHLINE))
            (setq C (+ C 1))
            (if (= nil (setq P1 (cadddr NODE)))
             (progn
              (command)
              (command "._3DPOLY")
             )
             (progn
              (setq P (RFL:XY (list (car NODE) (car P1))))
              (if (/= P nil)
               (progn
                (command (append P (cdr P1)))
               )
              )
             )
            )
           )
           (command)
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "DIMZIN" DIMZIN)
);
;
;     Program written by Robert Livingston, 2017/09/07
;
;     DAYLIGHTP is a utility for 'Daylighting' from a specified point
;
;
(defun C:DAYLIGHTP (/ A AECCOBJ ANGBASE ANGDIR *error* C CANCEL CATCHLINE
                      CMDECHO CURRENTSURFACE ENT ENTLIST FLAG GETFROMLIST N N0 NODE NODE1 NODE2
                      OBSURFACE OGLINE OGOFFSETLIST OS OSCUT OSFILL OSMODE
                      P P1 P2 PD1 PD2 PLIST SA1 SA2 SLOPECUT SLOPEFILL STA SWATH V1 V2 Z ZCUT ZFILL)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (command "._UNDO" "M")

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "DIMZIN" DIMZIN)
  (princ msg)
  ;(setq *error* nil)
 )

 (defun GETSLOPEINT (OFFSET ELEV SLOPE OGLIST / C ELEV1 ELEV2 ELEV3 OFFSET1 OFFSET2 OFFSET3 TOL)
  (setq TOL 0.000001)
  (setq C 0)
  (setq OFFSET3 nil)
  (setq ELEV3 nil)
  (while (< C (- (length OGLIST) 1))
   (setq OFFSET1 (car (nth C OGLIST)))
   (setq ELEV1 (cadr (nth C OGLIST)))
   (setq OFFSET2 (car (nth (+ C 1) OGLIST)))
   (setq ELEV2 (cadr (nth (+ C 1) OGLIST)))
   (if (< (abs (- OFFSET2 OFFSET1)) TOL)
    (setq C (+ C 1))
    (progn
     (setq OFFSET3 (/ (- (+ (* OFFSET1
                               (/ (- ELEV2 ELEV1)
                                  (- OFFSET2 OFFSET1)
                               )
                            )
                            ELEV
                         )
                         (+ (/ OFFSET SLOPE) ELEV1)
                      )
                      (- (/ (- ELEV2 ELEV1)
                            (- OFFSET2 OFFSET1)
                         )
                         (/ 1.0 SLOPE)
                      )
                   )
     )
     (setq ELEV3 (+ ELEV
                    (/ (- OFFSET3 OFFSET)
                       SLOPE
                    )
                 )
     )
     (if (>= (* (- OFFSET3 OFFSET1) (- OFFSET2 OFFSET3)) 0.0)
      (setq C (length OGLIST))
      (setq C (+ C 1))
     )
    )
   )
  )
  (list OFFSET3 ELEV3)
 )

 (setq OBSURFACE (RFL:GETC3DSURFACE))
 
 (if (= nil OBSURFACE)
  (princ "\n***** ERROR WITH SURFACE *****")
  (progn
   (if (/= nil (setq P (RFL:GETSPOTPOINT (car (entsel "\nSelect spot elevation :")))))
    (progn
     (setq Z (caddr P))
     (setq P (list (car P) (cadr P)))
     (setq N 0)
     (while (< N 3)
      (if (= nil (setq N (getint "\nEnter number of radial points <60> : ")))
       (setq N 60)
       (if (< N 2) (princ "\nMust have at least 3 points!"))
      )
     )
     (setq SWATH 0.0)
     (while (<= SWATH 0.0)
      (if (= nil (setq SWATH (getdist "\nEnter swath distance <100.0> : ")))
       (setq SWATH 100.0)
       (if (<= SWATH 0.0) (princ "\nMust be greater then 0.0!"))
      )
     )
     (if (= nil (setq SLOPEFILL (getreal "\nEnter fill slope (X:1) <3.0> : ")))
      (setq SLOPEFILL 3.0)
     )
     (if (= nil (setq SLOPECUT (getreal "\nEnter cut slope (X:1) <2.0> : ")))
      (setq SLOPECUT 2.0)
     )
     (setq N0 0)
     (setq PLIST nil)
     (while (< N0 N)
      (setq A (/ (* N0 2 pi) N))
      (setq OGLINE nil)
      (setq P1 P)
      (setq Z1 Z)
      (setq P2 (list (+ (car P1) (* SWATH (cos A)))
                     (+ (cadr P1) (* SWATH (sin A)))
               )
      )
      (if (/= nil (setq OGLINE (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
       (progn
        (setq OGOFFSETLIST nil)
        (foreach NODE OGLINE
         (setq OGOFFSETLIST (append OGOFFSETLIST (list (list (distance P1 (list (car NODE) (cadr NODE))) (caddr NODE)))))
        )
        (setq NODE1 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
              NODE2 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
        )
        (setq FLAG T)
        (setq P2 nil)
        (while (and FLAG NODE1 NODE2)
         (setq P2 (inters NODE1 NODE2 (list 0.0 Z1) (list SWATH (- Z1 (/ SWATH SLOPEFILL)))))
         (if (= nil P2)
          (setq P2 (inters NODE1 NODE2 (list 0.0 Z1) (list SWATH (+ Z1 (/ SWATH SLOPECUT)))))
         )
         (if (/= nil P2)
          (progn
           (setq FLAG nil)
           (setq PLIST (append PLIST (list (list (+ (car P1) (* (car P2) (cos A)))
                                                 (+ (cadr P1) (* (car P2) (sin A)))
                                                 (cadr P2)
                                           )
                                     )
                       )
           )
          )
         )
         (setq NODE1 NODE2
               NODE2 (car OGOFFSETLIST)
               OGOFFSETLIST (cdr OGOFFSETLIST)
         )
        )
       )
      )
      (setq N0 (1+ N0))
     )
     (if (/= nil PLIST)
      (progn
       (command "._3DPOLY")
       (foreach NODE PLIST (command NODE))
       (command "C")
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "DIMZIN" DIMZIN)
 T
);
;
;     Program written by Robert Livingston, 2016-03-30
;
;     DRAWBARRIER is a utility for drawing a polyline from one sta/os to another os at a specified length
;
;
(setq RFL:DRAWBARRIERSEGS 20)
(setq RFL:DRAWBARRIERLENGTH 24.2)
(setq RFL:DRAWBARRIEROS 6.45)
(defun C:DRAWBARRIER (/ CALCLENGTH DRAWLENGTH D D1 D2 OS OS1 OS2 P STA STA1 STA2 STAM TMP TOL)
 (defun CALCLENGTH (STA1 OS1 STA2 OS2 NSEGS / DSTA DOS STA OS LENGTHB)
  (setq STA STA1 OS OS1 LENGTHB 0.0)
  (setq P (RFL:XY (list STA OS)))
  (setq DSTA (/ (- STA2 STA1) NSEGS))
  (setq DOS (/ (- OS2 OS1) NSEGS))
  (repeat NSEGS
   (setq LENGTHB (+ LENGTHB (distance P (setq P (RFL:XY (list (setq STA (+ STA DSTA)) (setq OS (+ OS DOS))))))))
  )
  LENGTHB
 )
 (defun DRAWLENGTH (STA1 OS1 STA2 OS2 NSEGS / DSTA DOS STA OS)
  (setq STA STA1 OS OS1)
  (command "._PLINE" "_NON" (setq P (RFL:XY (list STA OS))))
  (setq DSTA (/ (- STA2 STA1) NSEGS))
  (setq DOS (/ (- OS2 OS1) NSEGS))
  (repeat NSEGS
   (command "_NON" (setq P (RFL:XY (list (setq STA (+ STA DSTA)) (setq OS (+ OS DOS))))))
  )
  (command "")
 )
 (setq TOL 0.001)
 (if (= nil (setq P (getpoint "\nStart point (<return> to enter Sta/OS) : ")))
  (progn
   (setq STA (getreal "\nStart Sta : "))
   (setq OS1 (getreal "\nStart OS : "))
  )
  (progn
   (setq P (RFL:STAOFF P))
   (if (= nil (setq STA (getreal (strcat "\nStart Sta <" (rtos (car P)) "> : "))))
    (setq STA (car P))
   )
   (if (= nil (setq OS1 (getreal (strcat "\nStart OS <" (rtos (cadr P)) ">: "))))
    (setq OS1 (cadr P))
   )
  )
 )
 (setq TMP (getreal (strcat "\nLength (+ve = upchainage, -ve = downchainage) <" (rtos RFL:DRAWBARRIERLENGTH) "> : ")))
 (if (/= nil TMP) (setq RFL:DRAWBARRIERLENGTH TMP))
 (setq TMP (getreal (strcat "\nEnd OS (+ve = right, -ve = left) <" (rtos RFL:DRAWBARRIEROS) "> : ")))
 (if (/= nil TMP) (setq RFL:DRAWBARRIEROS TMP))
 (setq TMP (getint (strcat "\nNumber of pline segments <" (itoa RFL:DRAWBARRIERSEGS) "> : ")))
 (if (/= nil TMP) (setq RFL:DRAWBARRIERSEGS TMP))
 (setq OS2 RFL:DRAWBARRIEROS)
 (if (> RFL:DRAWBARRIERLENGTH 0.0)
  (setq STA1 STA STA2 (- (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)) TOL))
  (setq STA1 STA STA2 (+ (caar RFL:ALIGNLIST) TOL))
 )
 (setq D1 0.0)
 (setq D2 (CALCLENGTH STA OS1 STA2 OS2 RFL:DRAWBARRIERSEGS))
 (while (> (abs (- D2 D1)) TOL)
  (setq STAM (/ (+ STA1 STA2) 2.0))
  (setq D (CALCLENGTH STA OS1 STAM OS2 RFL:DRAWBARRIERSEGS))
  (if (> D (abs RFL:DRAWBARRIERLENGTH))
   (setq STA2 STAM D2 D)
   (setq STA1 STAM D1 D)
  )
;(print STAM)
 )
 (DRAWLENGTH STA OS1 STAM OS2 RFL:DRAWBARRIERSEGS)
)
;
;
;     Program written by Robert Livingston, 2017-04-10
;
;     C:DRAWMID draws a polyline midpoint between two selected polylines
;
;
(defun C:DRAWMID (/ 3D CMDECHO ENT1 ENT2 ENTLIST1 ENTLIST2 P PLIST1 PLIST2 PLISTM ORTHOMODE OSMODE)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (setq PLISTM nil)
 (if (setq ENT1 (car (entsel "\nSelect first polyline : ")))
  (if (setq PLIST1 (RFL:GETPLIST ENT1))
   (if (setq ENT2 (car (entsel "\nSelect second polyline : ")))
    (if (setq PLIST2 (RFL:GETPLIST ENT2))
     (setq PLISTM (RFL:MIDPLIST PLIST1 PLIST2))
    )
   )
  )
 )
 (if PLISTM
  (progn
   (setq ENTLIST1 (entget ENT1)
         ENTLIST2 (entget ENT2)
   )
   (if (or (= 0 (logand (cdr (assoc 70 ENTLIST1)) 8))
           (= 0 (logand (cdr (assoc 70 ENTLIST2)) 8))
       )
    (command "._PLINE")
    (command "._3DPOLY")
   )
   (foreach P PLISTM (command P))
   (command "")
  )
 )
 (setvar "CMDECHO" CMDECHO)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
 T
);
;
;     Program Written by Robert LIvingston, 03/03/17
;
;     DUALCAR is a utility for drawing dual carriageway 3D polylines
;
;
(setq RFL:DUALCARLIST
      (list (cons "NORMAL" 2.0)
            (cons "CHOR" "n/a")
            (cons "CVER" "n/a")
            (cons "CSUPER" "n/a")
            (cons "LDF" "1")
            (cons "LDFVAL" 1.0)
            (cons "LDV" "0")
            (cons "LDVVAL" "n/a")
            (cons "LDW" 4.0)
            (cons "MDF" "1")
            (cons "MDFVAL" 1.957)
            (cons "MDV" "0")
            (cons "MDVVAL" "n/a")
            (cons "RDF" "1")
            (cons "RDFVAL" 1.0)
            (cons "RDV" "0")
            (cons "RDVVAL" "n/a")
            (cons "RDW" 4.0)
            (cons "LSD1" 0.25)
            (cons "LSD2" 0.5)
            (cons "RSD1" 0.25)
            (cons "RSD2" 0.5)
            (cons "LCOSF" "1")
            (cons "LCOSFVAL" 19.0)
            (cons "LCOSV" "0")
            (cons "LCOSVVAL" "n/a")
            (cons "RCOSF" "1")
            (cons "RCOSFVAL" 19.0)
            (cons "RCOSV" "0")
            (cons "RCOSVVAL" "n/a")
            (cons "LSOSF" "1")
            (cons "LSOSFVAL" 6.7)
            (cons "LSOSV" "0")
            (cons "LSOSVVAL" "n/a")
            (cons "RSOSF" "1")
            (cons "RSOSFVAL" 6.7)
            (cons "RSOSV" "0")
            (cons "RSOSVVAL" "n/a")
            (cons "LMOSF" "1")
            (cons "LMOSFVAL" 6.2)
            (cons "LMOSV" "0")
            (cons "LMOSVVAL" "n/a")
            (cons "RMOSF" "1")
            (cons "RMOSFVAL" 6.2)
            (cons "RMOSV" "0")
            (cons "RMOSVVAL" "n/a")
            (cons "LVF" "1")
            (cons "LVV" "0")
            (cons "LVVVAL" "n/a")
            (cons "RVF" "1")
            (cons "RVV" "0")
            (cons "RVVVAL" "n/a")
            (cons "LSLOPE1" 6.0)
            (cons "LSLOPE2" 5.0)
            (cons "LSLOPE3" 5.0)
            (cons "LSLOPE4" 5.0)
            (cons "LSLOPE5" 5.0)
            (cons "LSLOPE6" 6.0)
            (cons "RSLOPE1" 6.0)
            (cons "RSLOPE2" 5.0)
            (cons "RSLOPE3" 5.0)
            (cons "RSLOPE4" 5.0)
            (cons "RSLOPE5" 5.0)
            (cons "RSLOPE6" 6.0)
            (cons "LPIVOT4" "0")
            (cons "LPIVOT5" "1")
            (cons "LPIVOT6" "0")
            (cons "RPIVOT4" "0")
            (cons "RPIVOT5" "1")
            (cons "RPIVOT6" "0")
            (cons "DL1" "1")
            (cons "DL2" "1")
            (cons "DL3" "1")
            (cons "DL4" "1")
            (cons "DL5" "1")
            (cons "DL6" "1")
            (cons "DL7" "1")
            (cons "DL8" "1")
            (cons "DL9" "1")
            (cons "DL10" "1")
            (cons "DL11" "0")
            (cons "DL12" "0")
            (cons "DR1" "1")
            (cons "DR2" "1")
            (cons "DR3" "1")
            (cons "DR4" "1")
            (cons "DR5" "1")
            (cons "DR6" "1")
            (cons "DR7" "1")
            (cons "DR8" "1")
            (cons "DR9" "1")
            (cons "DR10" "1")
            (cons "DR11" "0")
            (cons "DR12" "0")
            (cons "FROMTOBEGIN" "1")
            (cons "FROMTOSTARTVAL" 0.0)
            (cons "FROMTOEND" "1")
            (cons "FROMTOENDVAL" 0.0)
            (cons "FROMTOSTEP" 10.0)
            (cons "FROMTOFILE" "0")
      )
)

(defun C:DUALCAR (/ *error* ACCEPTDUALCAR CANCEL CANCELDUALCAR CMDECHO D DCLID INITIATE
                    DUALCARSECTIONLIST DITCHLEFT DITCHMEDIAN DITCHRIGHT LEFTPROF RIGHTPROF
                    GETLINEPERP GETOFFSET
                    ALLEFT ALLEFTSHLDR ALLEFTMDN ALRIGHT ALRIGHTSHLDR ALRIGHTMDN
                    LOS1 LSHLDR LMDN LDITCH MDITCH ROS1 RSHLDR RMDN RDITCH PINWHEEL
                    PL1 PL2 PL3 PL4 PL5 PL6 PL7 PL8 PL9 PL10 PL11 PL12
                    PR1 PR2 PR3 PR4 PR5 PR6 PR7 PR8 PR9 PR10 PR11 PR12
                    SLOPE STA STASTART STAEND STASTEP STOPFLAG SUPERLEFT SUPERRIGHT
                    ALSAVE OSMODE ORTHOMODE PVISAVE SUPERSAVE TOL TMP)
;(defun C:DUALCAR ()

 (setq DUALCARSECTIONLIST nil)

 (command ".UNDO" "M")

 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (setq TOL 0.00001)

 (defun PINWHEEL ()
  (if (= PINWHEELCH nil)
   (setq PINWHEELCH "|")
  )
  (setq PINWHEELCH (cond ((= PINWHEELCH "|") "/")
                         ((= PINWHEELCH "/") "-")
                         ((= PINWHEELCH "-") "\\")
                         ((= PINWHEELCH "\\") "|")))
  (princ "\r")
  (princ PINWHEELCH)
 )

 (defun *error* (msg)
  (setq RFL:ALIGNLIST ALSAVE RFL:PVILIST PVISAVE RFL:SUPERLIST SUPERSAVE)
  (if (/= nil STA) (alert (strcat "Error at Station : " (rtos STA 2 3))))
  (setvar "CMDECHO" CMDECHO)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "OSMODE" OSMODE)
  ;(setq *error* nil)
  (princ msg)
 )

; Version 2 of GETOFFSET routine
 (defun GETLINEPERP (P P1 P2 / ANG D D1 D2 D3)
  (setq D (distance P1 P2))
  (setq D1 (distance P1 P))
  (setq D2 (distance P2 P))
  (setq D3 (/ (- (* D1 D1)
                 (* D2 D2)
                 (* D D)
              )
              (* 2.0 D)
           )
  )
  (setq ANG (angle P1 P2))
  (setq P3 (list (+ (nth 0 P2) (* D3 (cos ANG)))
                 (+ (nth 1 P2) (* D3 (sin ANG)))))
 )
 (defun GETOFFSET (STA OFFSET AL / ALSAVE C P P1 P2 P3 P4)
  (setq C 0)
  (setq ALSAVE RFL:ALIGNLIST)
  (setq P1 (RFL:XY (list STA -10.0)))
  (setq P2 (RFL:XY (list STA 10.0)))
  (setq P3 (RFL:XY (list STA OFFSET)))
  (setq RFL:ALIGNLIST AL)
  (setq P (RFL:STAOFF P3))
  (while (and (> (abs (cadr P)) TOL) (< C 100))
   (setq P4 (RFL:XY (list (car P) 0.0)))
   (setq P4 (GETLINEPERP P4 P1 P2))
   (setq P (RFL:STAOFF P4))
   (setq C (+ C 1))
  )
  (setq RFL:ALIGNLIST ALSAVE)
  (if (>= C 100)
   (princ (strcat "\n*** Warning - Maximum number of iterations reached at station " (rtos STA) "\n"))
  )
  (- (cadr (RFL:STAOFF P4)) OFFSET)
 )

; Version 1 of GETOFFSET routine - superseded cuz version 2 works better...
; (defun GETOFFSET (STA OFFSET AL / ALSAVE)
;  (setq P1 (RFL:XY (list STA OFFSET)))
;  (if (= P1 nil)
;   (progn
;    (setq RFL:ALIGNLIST ALSAVE)
;    (eval nil)
;   )
;   (progn
;    (setq ALSAVE RFL:ALIGNLIST)
;    (setq RFL:ALIGNLIST AL)
;    (setq TMP (cadr (RFL:STAOFF P1)))
;    (if (= TMP nil)
;     (progn
;      (setq RFL:ALIGNLIST ALSAVE)
;      (eval nil)
;     )
;     (progn
;      (setq RFL:ALIGNLIST ALSAVE)
;      (setq P3 (RFL:XY (list STA (* -2.0 TMP))))
;      (if (= P3 nil)
;       (progn
;        (setq RFL:ALIGNLIST ALSAVE)
;        (eval nil)
;       )
;       (progn
;        (setq RFL:ALIGNLIST AL)
;        (while (> (distance P1 P3) TOL)
;         (setq P2 (list (/ (+ (car P1) (car P3)) 2.0) (/ (+ (cadr P1) (cadr P3)) 2.0)))
;         (if (> (* (cadr (RFL:STAOFF P2)) (cadr (RFL:STAOFF P3))) 0.0)
;          (setq P3 P2)
;          (setq P1 P2)
;         )
;        )
;        (setq RFL:ALIGNLIST ALSAVE)
;        (- (cadr (RFL:STAOFF P3)) OFFSET)
;       )
;      )
;     )
;    )
;   )
;  )
; )

 (defun INITIATE ()
  (start_image "IMAGE")
  (slide_image 0 0 (- (dimx_tile "IMAGE") 1) (- (dimy_tile "IMAGE") 1) (strcat RFLALIGNSLBNAME "(DUALCAR)"))
  (end_image)
  (set_tile "NORMAL" (rtos (cdr (assoc "NORMAL" RFL:DUALCARLIST))))
  (set_tile "CHOR" (cdr (assoc "CHOR" RFL:DUALCARLIST)))
  (set_tile "CVER" (cdr (assoc "CVER" RFL:DUALCARLIST)))
  (set_tile "CSUPER" (cdr (assoc "CSUPER" RFL:DUALCARLIST)))
  (set_tile "LDF" (cdr (assoc "LDF" RFL:DUALCARLIST)))
  (set_tile "LDFVAL" (rtos (cdr (assoc "LDFVAL" RFL:DUALCARLIST))))
  (set_tile "LDV" (cdr (assoc "LDV" RFL:DUALCARLIST)))
  (set_tile "LDVVAL" (cdr (assoc "LDVVAL" RFL:DUALCARLIST)))
  (set_tile "LDW" (rtos (cdr (assoc "LDW" RFL:DUALCARLIST))))
  (set_tile "MDF" (cdr (assoc "MDF" RFL:DUALCARLIST)))
  (set_tile "MDFVAL" (rtos (cdr (assoc "MDFVAL" RFL:DUALCARLIST))))
  (set_tile "MDV" (cdr (assoc "MDV" RFL:DUALCARLIST)))
  (set_tile "MDVVAL" (cdr (assoc "MDVVAL" RFL:DUALCARLIST)))
  (set_tile "RDF" (cdr (assoc "RDF" RFL:DUALCARLIST)))
  (set_tile "RDFVAL" (rtos (cdr (assoc "RDFVAL" RFL:DUALCARLIST))))
  (set_tile "RDV" (cdr (assoc "RDV" RFL:DUALCARLIST)))
  (set_tile "RDVVAL" (cdr (assoc "RDVVAL" RFL:DUALCARLIST)))
  (set_tile "RDW" (rtos (cdr (assoc "RDW" RFL:DUALCARLIST))))
  (set_tile "LSD1" (rtos (cdr (assoc "LSD1" RFL:DUALCARLIST))))
  (set_tile "LSD2" (rtos (cdr (assoc "LSD2" RFL:DUALCARLIST))))
  (set_tile "RSD1" (rtos (cdr (assoc "RSD1" RFL:DUALCARLIST))))
  (set_tile "RSD2" (rtos (cdr (assoc "RSD2" RFL:DUALCARLIST))))
  (set_tile "LCOSF" (cdr (assoc "LCOSF" RFL:DUALCARLIST)))
  (set_tile "LCOSFVAL" (rtos (cdr (assoc "LCOSFVAL" RFL:DUALCARLIST))))
  (set_tile "LCOSV" (cdr (assoc "LCOSV" RFL:DUALCARLIST)))
  (set_tile "LCOSVVAL" (cdr (assoc "LCOSVVAL" RFL:DUALCARLIST)))
  (set_tile "RCOSF" (cdr (assoc "RCOSF" RFL:DUALCARLIST)))
  (set_tile "RCOSFVAL" (rtos (cdr (assoc "RCOSFVAL" RFL:DUALCARLIST))))
  (set_tile "RCOSV" (cdr (assoc "RCOSV" RFL:DUALCARLIST)))
  (set_tile "RCOSVVAL" (cdr (assoc "RCOSVVAL" RFL:DUALCARLIST)))
  (set_tile "LSOSF" (cdr (assoc "LSOSF" RFL:DUALCARLIST)))
  (set_tile "LSOSFVAL" (rtos (cdr (assoc "LSOSFVAL" RFL:DUALCARLIST))))
  (set_tile "LSOSV" (cdr (assoc "LSOSV" RFL:DUALCARLIST)))
  (set_tile "LSOSVVAL" (cdr (assoc "LSOSVVAL" RFL:DUALCARLIST)))
  (set_tile "RSOSF" (cdr (assoc "RSOSF" RFL:DUALCARLIST)))
  (set_tile "RSOSFVAL" (rtos (cdr (assoc "RSOSFVAL" RFL:DUALCARLIST))))
  (set_tile "RSOSV" (cdr (assoc "RSOSV" RFL:DUALCARLIST)))
  (set_tile "RSOSVVAL" (cdr (assoc "RSOSVVAL" RFL:DUALCARLIST)))
  (set_tile "LMOSF" (cdr (assoc "LMOSF" RFL:DUALCARLIST)))
  (set_tile "LMOSFVAL" (rtos (cdr (assoc "LMOSFVAL" RFL:DUALCARLIST))))
  (set_tile "LMOSV" (cdr (assoc "LMOSV" RFL:DUALCARLIST)))
  (set_tile "LMOSVVAL" (cdr (assoc "LMOSVVAL" RFL:DUALCARLIST)))
  (set_tile "RMOSF" (cdr (assoc "RMOSF" RFL:DUALCARLIST)))
  (set_tile "RMOSFVAL" (rtos (cdr (assoc "RMOSFVAL" RFL:DUALCARLIST))))
  (set_tile "RMOSV" (cdr (assoc "RMOSV" RFL:DUALCARLIST)))
  (set_tile "RMOSVVAL" (cdr (assoc "RMOSVVAL" RFL:DUALCARLIST)))
  (set_tile "LVF" (cdr (assoc "LVF" RFL:DUALCARLIST)))
  (set_tile "LVV" (cdr (assoc "LVV" RFL:DUALCARLIST)))
  (set_tile "LVVVAL" (cdr (assoc "LVVVAL" RFL:DUALCARLIST)))
  (set_tile "RVF" (cdr (assoc "RVF" RFL:DUALCARLIST)))
  (set_tile "RVV" (cdr (assoc "RVV" RFL:DUALCARLIST)))
  (set_tile "RVVVAL" (cdr (assoc "RVVVAL" RFL:DUALCARLIST)))
  (set_tile "LSLOPE1" (rtos (cdr (assoc "LSLOPE1" RFL:DUALCARLIST))))
  (set_tile "LSLOPE2" (rtos (cdr (assoc "LSLOPE2" RFL:DUALCARLIST))))
  (set_tile "LSLOPE3" (rtos (cdr (assoc "LSLOPE3" RFL:DUALCARLIST))))
  (set_tile "LSLOPE4" (rtos (cdr (assoc "LSLOPE4" RFL:DUALCARLIST))))
  (set_tile "LSLOPE5" (rtos (cdr (assoc "LSLOPE5" RFL:DUALCARLIST))))
  (set_tile "LSLOPE6" (rtos (cdr (assoc "LSLOPE6" RFL:DUALCARLIST))))
  (set_tile "RSLOPE1" (rtos (cdr (assoc "RSLOPE1" RFL:DUALCARLIST))))
  (set_tile "RSLOPE2" (rtos (cdr (assoc "RSLOPE2" RFL:DUALCARLIST))))
  (set_tile "RSLOPE3" (rtos (cdr (assoc "RSLOPE3" RFL:DUALCARLIST))))
  (set_tile "RSLOPE4" (rtos (cdr (assoc "RSLOPE4" RFL:DUALCARLIST))))
  (set_tile "RSLOPE5" (rtos (cdr (assoc "RSLOPE5" RFL:DUALCARLIST))))
  (set_tile "RSLOPE6" (rtos (cdr (assoc "RSLOPE6" RFL:DUALCARLIST))))
  (set_tile "LPIVOT4" (cdr (assoc "LPIVOT4" RFL:DUALCARLIST)))
  (set_tile "LPIVOT5" (cdr (assoc "LPIVOT5" RFL:DUALCARLIST)))
  (set_tile "LPIVOT6" (cdr (assoc "LPIVOT6" RFL:DUALCARLIST)))
  (set_tile "RPIVOT4" (cdr (assoc "RPIVOT4" RFL:DUALCARLIST)))
  (set_tile "RPIVOT5" (cdr (assoc "RPIVOT5" RFL:DUALCARLIST)))
  (set_tile "RPIVOT6" (cdr (assoc "RPIVOT6" RFL:DUALCARLIST)))
  (set_tile "DL1" (cdr (assoc "DL1" RFL:DUALCARLIST)))
  (set_tile "DL2" (cdr (assoc "DL2" RFL:DUALCARLIST)))
  (set_tile "DL3" (cdr (assoc "DL3" RFL:DUALCARLIST)))
  (set_tile "DL4" (cdr (assoc "DL4" RFL:DUALCARLIST)))
  (set_tile "DL5" (cdr (assoc "DL5" RFL:DUALCARLIST)))
  (set_tile "DL6" (cdr (assoc "DL6" RFL:DUALCARLIST)))
  (set_tile "DL7" (cdr (assoc "DL7" RFL:DUALCARLIST)))
  (set_tile "DL8" (cdr (assoc "DL8" RFL:DUALCARLIST)))
  (set_tile "DL9" (cdr (assoc "DL9" RFL:DUALCARLIST)))
  (set_tile "DL10" (cdr (assoc "DL10" RFL:DUALCARLIST)))
  (set_tile "DL11" (cdr (assoc "DL11" RFL:DUALCARLIST)))
  (set_tile "DL12" (cdr (assoc "DL12" RFL:DUALCARLIST)))
  (set_tile "DR1" (cdr (assoc "DR1" RFL:DUALCARLIST)))
  (set_tile "DR2" (cdr (assoc "DR2" RFL:DUALCARLIST)))
  (set_tile "DR3" (cdr (assoc "DR3" RFL:DUALCARLIST)))
  (set_tile "DR4" (cdr (assoc "DR4" RFL:DUALCARLIST)))
  (set_tile "DR5" (cdr (assoc "DR5" RFL:DUALCARLIST)))
  (set_tile "DR6" (cdr (assoc "DR6" RFL:DUALCARLIST)))
  (set_tile "DR7" (cdr (assoc "DR7" RFL:DUALCARLIST)))
  (set_tile "DR8" (cdr (assoc "DR8" RFL:DUALCARLIST)))
  (set_tile "DR9" (cdr (assoc "DR9" RFL:DUALCARLIST)))
  (set_tile "DR10" (cdr (assoc "DR10" RFL:DUALCARLIST)))
  (set_tile "DR11" (cdr (assoc "DR11" RFL:DUALCARLIST)))
  (set_tile "DR12" (cdr (assoc "DR12" RFL:DUALCARLIST)))
  (set_tile "FROMTOBEGIN" (cdr (assoc "FROMTOBEGIN" RFL:DUALCARLIST)))
  (set_tile "FROMTOSTARTVAL" (rtos (cdr (assoc "FROMTOSTARTVAL" RFL:DUALCARLIST))))
  (set_tile "FROMTOEND" (cdr (assoc "FROMTOEND" RFL:DUALCARLIST)))
  (set_tile "FROMTOENDVAL" (rtos (cdr (assoc "FROMTOENDVAL" RFL:DUALCARLIST))))
  (set_tile "FROMTOSTEP" (rtos (cdr (assoc "FROMTOSTEP" RFL:DUALCARLIST))))
  (set_tile "FROMTOFILE" (cdr (assoc "FROMTOFILE" RFL:DUALCARLIST)))
 )

 (defun SETENABLED ()
  (if (= (get_tile "LDF") "1")
   (progn
    (mode_tile "LDFVAL" 0)
    (mode_tile "LDVVAL" 1)
    (mode_tile "LDVPICK" 1)
   )
   (progn
    (mode_tile "LDFVAL" 1)
    (mode_tile "LDVVAL" 0)
    (mode_tile "LDVPICK" 0)
   )
  )
  (if (= (get_tile "MDF") "1")
   (progn
    (mode_tile "MDFVAL" 0)
    (mode_tile "MDVVAL" 1)
    (mode_tile "MDVPICK" 1)
   )
   (progn
    (mode_tile "MDFVAL" 1)
    (mode_tile "MDVVAL" 0)
    (mode_tile "MDVPICK" 0)
   )
  )
  (if (= (get_tile "RDF") "1")
   (progn
    (mode_tile "RDFVAL" 0)
    (mode_tile "RDVVAL" 1)
    (mode_tile "RDVPICK" 1)
   )
   (progn
    (mode_tile "RDFVAL" 1)
    (mode_tile "RDVVAL" 0)
    (mode_tile "RDVPICK" 0)
   )
  )
  (if (= (get_tile "LCOSF") "1")
   (progn
    (mode_tile "LCOSFVAL" 0)
    (mode_tile "LCOSVVAL" 1)
    (mode_tile "LCOSVPICK" 1)
   )
   (progn
    (mode_tile "LCOSFVAL" 1)
    (mode_tile "LCOSVVAL" 0)
    (mode_tile "LCOSVPICK" 0)
   )
  )
  (if (= (get_tile "RCOSF") "1")
   (progn
    (mode_tile "RCOSFVAL" 0)
    (mode_tile "RCOSVVAL" 1)
    (mode_tile "RCOSVPICK" 1)
   )
   (progn
    (mode_tile "RCOSFVAL" 1)
    (mode_tile "RCOSVVAL" 0)
    (mode_tile "RCOSVPICK" 0)
   )
  )
  (if (= (get_tile "LSOSF") "1")
   (progn
    (mode_tile "LSOSFVAL" 0)
    (mode_tile "LSOSVVAL" 1)
    (mode_tile "LSOSVPICK" 1)
   )
   (progn
    (mode_tile "LSOSFVAL" 1)
    (mode_tile "LSOSVVAL" 0)
    (mode_tile "LSOSVPICK" 0)
   )
  )
  (if (= (get_tile "RSOSF") "1")
   (progn
    (mode_tile "RSOSFVAL" 0)
    (mode_tile "RSOSVVAL" 1)
    (mode_tile "RSOSVPICK" 1)
   )
   (progn
    (mode_tile "RSOSFVAL" 1)
    (mode_tile "RSOSVVAL" 0)
    (mode_tile "RSOSVPICK" 0)
   )
  )
  (if (= (get_tile "LMOSF") "1")
   (progn
    (mode_tile "LMOSFVAL" 0)
    (mode_tile "LMOSVVAL" 1)
    (mode_tile "LMOSVPICK" 1)
   )
   (progn
    (mode_tile "LMOSFVAL" 1)
    (mode_tile "LMOSVVAL" 0)
    (mode_tile "LMOSVPICK" 0)
   )
  )
  (if (= (get_tile "RMOSF") "1")
   (progn
    (mode_tile "RMOSFVAL" 0)
    (mode_tile "RMOSVVAL" 1)
    (mode_tile "RMOSVPICK" 1)
   )
   (progn
    (mode_tile "RMOSFVAL" 1)
    (mode_tile "RMOSVVAL" 0)
    (mode_tile "RMOSVPICK" 0)
   )
  )
  (if (= (get_tile "LVF") "1")
   (progn
    (mode_tile "LVVVAL" 1)
    (mode_tile "LVVPICK" 1)
   )
   (progn
    (mode_tile "LVVVAL" 0)
    (mode_tile "LVVPICK" 0)
   )
  )
  (if (= (get_tile "RVF") "1")
   (progn
    (mode_tile "RVVVAL" 1)
    (mode_tile "RVVPICK" 1)
   )
   (progn
    (mode_tile "RVVVAL" 0)
    (mode_tile "RVVPICK" 0)
   )
  )
  (if (= (get_tile "FROMTOBEGIN") "1")
   (progn
    (mode_tile "FROMTOSTARTVAL" 1)
   )
   (progn
    (mode_tile "FROMTOSTARTVAL" 0)
   )
  )
  (if (= (get_tile "FROMTOEND") "1")
   (progn
    (mode_tile "FROMTOENDVAL" 1)
   )
   (progn
    (mode_tile "FROMTOENDVAL" 0)
   )
  )
 )

 (defun PICKFILE (TILE EXT / FILENAME)
  (cond ((= EXT ".HOR")
         (progn
          (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
           (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
          )
          (setq FILENAME (getfiled "Select a Horizontal Alignment File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "hor" 2))
          (if (= nil FILENAME)
           (set_tile TILE "n/a")
           (progn
            (set_tile TILE (strcase FILENAME))
            (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory FILENAME) "\\"))
           )
          )
         )
        )
        ((= EXT ".VRT")
         (progn
          (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
           (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
          )
          (setq FILENAME (getfiled "Select a Vertical Alignment File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "vrt" 2))
          (if (= nil FILENAME)
           (set_tile TILE "n/a")
           (progn
            (set_tile TILE (strcase FILENAME))
            (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory FILENAME) "\\"))
           )
          )
         )
        )
        ((= EXT ".E")
         (progn
          (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
           (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
          )
          (setq FILENAME (getfiled "Select a Superelevation File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "e" 2))
          (if (= nil FILENAME)
           (set_tile TILE "n/a")
           (progn
            (set_tile TILE (strcase FILENAME))
            (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory FILENAME) "\\"))
           )
          )
         )
        )
  )
 )

 (defun CHECKFILE (TILE EXT / FILENAME)
  (setq FILENAME (strcase (get_tile TILE)))
  (if (< (strlen FILENAME) (strlen EXT))
   (set_tile TILE "n/a")
   (if (/= EXT (substr FILENAME (1+ (- (strlen FILENAME) (strlen EXT)))))
    (set_tile TILE "n/a")
    (if (= nil (setq FILENAME (findfile FILENAME)))
     (set_tile TILE "n/a")
     (set_tile TILE FILENAME)
    )
   )
  )
 )

 (defun FIXNUMBER (TILE)
  (set_tile TILE (rtos (atof (get_tile TILE))))
 )

 (defun WRITESETTINGS (/ OUTFILE)
  (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
  )
  (setq OUTFILE (getfiled "Select a file for saving" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "ini" 1))
  (if (/= OUTFILE nil)
   (progn
    (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory OUTFILE) "\\"))
    (setq OUTFILE (open OUTFILE "w"))
    (princ ";\n" OUTFILE)
    (princ "; RFL DualCar settings file\n" OUTFILE)
    (princ ";\n" OUTFILE)
    (princ (strcat "NORMAL:" (get_tile "NORMAL") "\n") OUTFILE)
    (princ (strcat "CHOR:" (get_tile "CHOR") "\n") OUTFILE)
    (princ (strcat "CVER:" (get_tile "CVER") "\n") OUTFILE)
    (princ (strcat "CSUPER:" (get_tile "CSUPER") "\n") OUTFILE)
    (princ (strcat "LDF:" (get_tile "LDF") "\n") OUTFILE)
    (princ (strcat "LDFVAL:" (get_tile "LDFVAL") "\n") OUTFILE)
    (princ (strcat "LDV:" (get_tile "LDV") "\n") OUTFILE)
    (princ (strcat "LDVVAL:" (get_tile "LDVVAL") "\n") OUTFILE)
    (princ (strcat "LDW:" (get_tile "LDW") "\n") OUTFILE)
    (princ (strcat "MDF:" (get_tile "MDF") "\n") OUTFILE)
    (princ (strcat "MDFVAL:" (get_tile "MDFVAL") "\n") OUTFILE)
    (princ (strcat "MDV:" (get_tile "MDV") "\n") OUTFILE)
    (princ (strcat "MDVVAL:" (get_tile "MDVVAL") "\n") OUTFILE)
    (princ (strcat "RDF:" (get_tile "RDF") "\n") OUTFILE)
    (princ (strcat "RDFVAL:" (get_tile "RDFVAL") "\n") OUTFILE)
    (princ (strcat "RDV:" (get_tile "RDV") "\n") OUTFILE)
    (princ (strcat "RDVVAL:" (get_tile "RDVVAL") "\n") OUTFILE)
    (princ (strcat "RDW:" (get_tile "RDW") "\n") OUTFILE)
    (princ (strcat "LSD1:" (get_tile "LSD1") "\n") OUTFILE)
    (princ (strcat "LSD2:" (get_tile "LSD2") "\n") OUTFILE)
    (princ (strcat "RSD1:" (get_tile "RSD1") "\n") OUTFILE)
    (princ (strcat "RSD2:" (get_tile "RSD2") "\n") OUTFILE)
    (princ (strcat "LCOSF:" (get_tile "LCOSF") "\n") OUTFILE)
    (princ (strcat "LCOSFVAL:" (get_tile "LCOSFVAL") "\n") OUTFILE)
    (princ (strcat "LCOSV:" (get_tile "LCOSV") "\n") OUTFILE)
    (princ (strcat "LCOSVVAL:" (get_tile "LCOSVVAL") "\n") OUTFILE)
    (princ (strcat "RCOSF:" (get_tile "RCOSF") "\n") OUTFILE)
    (princ (strcat "RCOSFVAL:" (get_tile "RCOSFVAL") "\n") OUTFILE)
    (princ (strcat "RCOSV:" (get_tile "RCOSV") "\n") OUTFILE)
    (princ (strcat "RCOSVVAL:" (get_tile "RCOSVVAL") "\n") OUTFILE)
    (princ (strcat "LSOSF:" (get_tile "LSOSF") "\n") OUTFILE)
    (princ (strcat "LSOSFVAL:" (get_tile "LSOSFVAL") "\n") OUTFILE)
    (princ (strcat "LSOSV:" (get_tile "LSOSV") "\n") OUTFILE)
    (princ (strcat "LSOSVVAL:" (get_tile "LSOSVVAL") "\n") OUTFILE)
    (princ (strcat "RSOSF:" (get_tile "RSOSF") "\n") OUTFILE)
    (princ (strcat "RSOSFVAL:" (get_tile "RSOSFVAL") "\n") OUTFILE)
    (princ (strcat "RSOSV:" (get_tile "RSOSV") "\n") OUTFILE)
    (princ (strcat "RSOSVVAL:" (get_tile "RSOSVVAL") "\n") OUTFILE)
    (princ (strcat "LMOSF:" (get_tile "LMOSF") "\n") OUTFILE)
    (princ (strcat "LMOSFVAL:" (get_tile "LMOSFVAL") "\n") OUTFILE)
    (princ (strcat "LMOSV:" (get_tile "LMOSV") "\n") OUTFILE)
    (princ (strcat "LMOSVVAL:" (get_tile "LMOSVVAL") "\n") OUTFILE)
    (princ (strcat "RMOSF:" (get_tile "RMOSF") "\n") OUTFILE)
    (princ (strcat "RMOSFVAL:" (get_tile "RMOSFVAL") "\n") OUTFILE)
    (princ (strcat "RMOSV:" (get_tile "RMOSV") "\n") OUTFILE)
    (princ (strcat "RMOSVVAL:" (get_tile "RMOSVVAL") "\n") OUTFILE)
    (princ (strcat "LVF:" (get_tile "LVF") "\n") OUTFILE)
    (princ (strcat "LVV:" (get_tile "LVV") "\n") OUTFILE)
    (princ (strcat "LVVVAL:" (get_tile "LVVVAL") "\n") OUTFILE)
    (princ (strcat "RVF:" (get_tile "RVF") "\n") OUTFILE)
    (princ (strcat "RVV:" (get_tile "RVV") "\n") OUTFILE)
    (princ (strcat "RVVVAL:" (get_tile "RVVVAL") "\n") OUTFILE)
    (princ (strcat "LSLOPE1:" (get_tile "LSLOPE1") "\n") OUTFILE)
    (princ (strcat "LSLOPE2:" (get_tile "LSLOPE2") "\n") OUTFILE)
    (princ (strcat "LSLOPE3:" (get_tile "LSLOPE3") "\n") OUTFILE)
    (princ (strcat "LSLOPE4:" (get_tile "LSLOPE4") "\n") OUTFILE)
    (princ (strcat "LSLOPE5:" (get_tile "LSLOPE5") "\n") OUTFILE)
    (princ (strcat "LSLOPE6:" (get_tile "LSLOPE6") "\n") OUTFILE)
    (princ (strcat "RSLOPE1:" (get_tile "RSLOPE1") "\n") OUTFILE)
    (princ (strcat "RSLOPE2:" (get_tile "RSLOPE2") "\n") OUTFILE)
    (princ (strcat "RSLOPE3:" (get_tile "RSLOPE3") "\n") OUTFILE)
    (princ (strcat "RSLOPE4:" (get_tile "RSLOPE4") "\n") OUTFILE)
    (princ (strcat "RSLOPE5:" (get_tile "RSLOPE5") "\n") OUTFILE)
    (princ (strcat "RSLOPE6:" (get_tile "RSLOPE6") "\n") OUTFILE)
    (princ (strcat "LPIVOT4:" (get_tile "LPIVOT4") "\n") OUTFILE)
    (princ (strcat "LPIVOT5:" (get_tile "LPIVOT5") "\n") OUTFILE)
    (princ (strcat "LPIVOT6:" (get_tile "LPIVOT6") "\n") OUTFILE)
    (princ (strcat "RPIVOT4:" (get_tile "RPIVOT4") "\n") OUTFILE)
    (princ (strcat "RPIVOT5:" (get_tile "RPIVOT5") "\n") OUTFILE)
    (princ (strcat "RPIVOT6:" (get_tile "RPIVOT6") "\n") OUTFILE)
    (princ (strcat "DL1:" (get_tile "DL1") "\n") OUTFILE)
    (princ (strcat "DL2:" (get_tile "DL2") "\n") OUTFILE)
    (princ (strcat "DL3:" (get_tile "DL3") "\n") OUTFILE)
    (princ (strcat "DL4:" (get_tile "DL4") "\n") OUTFILE)
    (princ (strcat "DL5:" (get_tile "DL5") "\n") OUTFILE)
    (princ (strcat "DL6:" (get_tile "DL6") "\n") OUTFILE)
    (princ (strcat "DL7:" (get_tile "DL7") "\n") OUTFILE)
    (princ (strcat "DL8:" (get_tile "DL8") "\n") OUTFILE)
    (princ (strcat "DL9:" (get_tile "DL9") "\n") OUTFILE)
    (princ (strcat "DL10:" (get_tile "DL10") "\n") OUTFILE)
    (princ (strcat "DL11:" (get_tile "DL11") "\n") OUTFILE)
    (princ (strcat "DL12:" (get_tile "DL12") "\n") OUTFILE)
    (princ (strcat "DR1:" (get_tile "DR1") "\n") OUTFILE)
    (princ (strcat "DR2:" (get_tile "DR2") "\n") OUTFILE)
    (princ (strcat "DR3:" (get_tile "DR3") "\n") OUTFILE)
    (princ (strcat "DR4:" (get_tile "DR4") "\n") OUTFILE)
    (princ (strcat "DR5:" (get_tile "DR5") "\n") OUTFILE)
    (princ (strcat "DR6:" (get_tile "DR6") "\n") OUTFILE)
    (princ (strcat "DR7:" (get_tile "DR7") "\n") OUTFILE)
    (princ (strcat "DR8:" (get_tile "DR8") "\n") OUTFILE)
    (princ (strcat "DR9:" (get_tile "DR9") "\n") OUTFILE)
    (princ (strcat "DR10:" (get_tile "DR10") "\n") OUTFILE)
    (princ (strcat "DR11:" (get_tile "DR11") "\n") OUTFILE)
    (princ (strcat "DR12:" (get_tile "DR12") "\n") OUTFILE)
    (princ (strcat "FROMTOBEGIN:" (get_tile "FROMTOBEGIN") "\n") OUTFILE)
    (princ (strcat "FROMTOSTARTVAL:" (get_tile "FROMTOSTARTVAL") "\n") OUTFILE)
    (princ (strcat "FROMTOEND:" (get_tile "FROMTOEND") "\n") OUTFILE)
    (princ (strcat "FROMTOENDVAL:" (get_tile "FROMTOENDVAL") "\n") OUTFILE)
    (princ (strcat "FROMTOSTEP:" (get_tile "FROMTOSTEP") "\n") OUTFILE)
    (princ (strcat "FROMTOFILE:" (get_tile "FROMTOFILE") "\n") OUTFILE)
    (close OUTFILE)
   )
  )
 )

 (defun READSETTINGS (/ INFILE INLINE P TILE TXT)
  (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
   (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
  )
  (setq INFILE (getfiled "Select a file for reading" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "ini" 2))
  (if (/= INFILE nil)
   (progn
    (setq INFILE (open INFILE "r"))
    (while (/= nil (setq INLINE (read-line INFILE)))
     (setq P (vl-string-search ":" INLINE))
     (if (/= P nil)
      (progn
       (setq TILE (substr INLINE 1 P))
       (setq TXT (substr INLINE (+ 2 P)))
       (set_tile TILE TXT)
      )
     )
    )
    (close INFILE)
   )
  )
  (SETENABLED)
 )

 (defun ACCEPTDUALCAR ()
  (setq CANCEL 0)
  (setq RFL:DUALCARLIST
        (list (cons "NORMAL" (atof (get_tile "NORMAL")))
              (cons "CHOR" (get_tile "CHOR"))
              (cons "CVER" (get_tile "CVER"))
              (cons "CSUPER" (get_tile "CSUPER"))
              (cons "LDF" (get_tile "LDF"))
              (cons "LDFVAL" (atof (get_tile "LDFVAL")))
              (cons "LDV" (get_tile "LDV"))
              (cons "LDVVAL" (get_tile "LDVVAL"))
              (cons "LDW" (atof (get_tile "LDW")))
              (cons "MDF" (get_tile "MDF"))
              (cons "MDFVAL" (atof (get_tile "MDFVAL")))
              (cons "MDV" (get_tile "MDV"))
              (cons "MDVVAL" (get_tile "MDVVAL"))
              (cons "RDF" (get_tile "RDF"))
              (cons "RDFVAL" (atof (get_tile "RDFVAL")))
              (cons "RDV" (get_tile "RDV"))
              (cons "RDVVAL" (get_tile "RDVVAL"))
              (cons "RDW" (atof (get_tile "RDW")))
              (cons "LSD1" (atof (get_tile "LSD1")))
              (cons "LSD2" (atof (get_tile "LSD2")))
              (cons "RSD1" (atof (get_tile "RSD1")))
              (cons "RSD2" (atof (get_tile "RSD2")))
              (cons "LCOSF" (get_tile "LCOSF"))
              (cons "LCOSFVAL" (atof (get_tile "LCOSFVAL")))
              (cons "LCOSV" (get_tile "LCOSV"))
              (cons "LCOSVVAL" (get_tile "LCOSVVAL"))
              (cons "RCOSF" (get_tile "RCOSF"))
              (cons "RCOSFVAL" (atof (get_tile "RCOSFVAL")))
              (cons "RCOSV" (get_tile "RCOSV"))
              (cons "RCOSVVAL" (get_tile "RCOSVVAL"))
              (cons "LSOSF" (get_tile "LSOSF"))
              (cons "LSOSFVAL" (atof (get_tile "LSOSFVAL")))
              (cons "LSOSV" (get_tile "LSOSV"))
              (cons "LSOSVVAL" (get_tile "LSOSVVAL"))
              (cons "RSOSF" (get_tile "RSOSF"))
              (cons "RSOSFVAL" (atof (get_tile "RSOSFVAL")))
              (cons "RSOSV" (get_tile "RSOSV"))
              (cons "RSOSVVAL" (get_tile "RSOSVVAL"))
              (cons "LMOSF" (get_tile "LMOSF"))
              (cons "LMOSFVAL" (atof (get_tile "LMOSFVAL")))
              (cons "LMOSV" (get_tile "LMOSV"))
              (cons "LMOSVVAL" (get_tile "LMOSVVAL"))
              (cons "RMOSF" (get_tile "RMOSF"))
              (cons "RMOSFVAL" (atof (get_tile "RMOSFVAL")))
              (cons "RMOSV" (get_tile "RMOSV"))
              (cons "RMOSVVAL" (get_tile "RMOSVVAL"))
              (cons "LVF" (get_tile "LVF"))
              (cons "LVV" (get_tile "LVV"))
              (cons "LVVVAL" (get_tile "LVVVAL"))
              (cons "RVF" (get_tile "RVF"))
              (cons "RVV" (get_tile "RVV"))
              (cons "RVVVAL" (get_tile "RVVVAL"))
              (cons "LSLOPE1" (atof (get_tile "LSLOPE1")))
              (cons "LSLOPE2" (atof (get_tile "LSLOPE2")))
              (cons "LSLOPE3" (atof (get_tile "LSLOPE3")))
              (cons "LSLOPE4" (atof (get_tile "LSLOPE4")))
              (cons "LSLOPE5" (atof (get_tile "LSLOPE5")))
              (cons "LSLOPE6" (atof (get_tile "LSLOPE6")))
              (cons "RSLOPE1" (atof (get_tile "RSLOPE1")))
              (cons "RSLOPE2" (atof (get_tile "RSLOPE2")))
              (cons "RSLOPE3" (atof (get_tile "RSLOPE3")))
              (cons "RSLOPE4" (atof (get_tile "RSLOPE4")))
              (cons "RSLOPE5" (atof (get_tile "RSLOPE5")))
              (cons "RSLOPE6" (atof (get_tile "RSLOPE6")))
              (cons "LPIVOT4" (get_tile "LPIVOT4"))
              (cons "LPIVOT5" (get_tile "LPIVOT5"))
              (cons "LPIVOT6" (get_tile "LPIVOT6"))
              (cons "RPIVOT4" (get_tile "RPIVOT4"))
              (cons "RPIVOT5" (get_tile "RPIVOT5"))
              (cons "RPIVOT6" (get_tile "RPIVOT6"))
              (cons "DL1" (get_tile "DL1"))
              (cons "DL2" (get_tile "DL2"))
              (cons "DL3" (get_tile "DL3"))
              (cons "DL4" (get_tile "DL4"))
              (cons "DL5" (get_tile "DL5"))
              (cons "DL6" (get_tile "DL6"))
              (cons "DL7" (get_tile "DL7"))
              (cons "DL8" (get_tile "DL8"))
              (cons "DL9" (get_tile "DL9"))
              (cons "DL10" (get_tile "DL10"))
              (cons "DL11" (get_tile "DL11"))
              (cons "DL12" (get_tile "DL12"))
              (cons "DR1" (get_tile "DR1"))
              (cons "DR2" (get_tile "DR2"))
              (cons "DR3" (get_tile "DR3"))
              (cons "DR4" (get_tile "DR4"))
              (cons "DR5" (get_tile "DR5"))
              (cons "DR6" (get_tile "DR6"))
              (cons "DR7" (get_tile "DR7"))
              (cons "DR8" (get_tile "DR8"))
              (cons "DR9" (get_tile "DR9"))
              (cons "DR10" (get_tile "DR10"))
              (cons "DR11" (get_tile "DR11"))
              (cons "DR12" (get_tile "DR12"))
              (cons "FROMTOBEGIN" (get_tile "FROMTOBEGIN"))
              (cons "FROMTOSTARTVAL" (atof (get_tile "FROMTOSTARTVAL")))
              (cons "FROMTOEND" (get_tile "FROMTOEND"))
              (cons "FROMTOENDVAL" (atof (get_tile "FROMTOENDVAL")))
              (cons "FROMTOSTEP" (atof (get_tile "FROMTOSTEP")))
              (cons "FROMTOFILE" (get_tile "FROMTOFILE"))
      )
  )
  (done_dialog)
  (unload_dialog DCL_ID)
 )

 (defun CANCELDUALCAR ()
  (setq CANCEL 1)
  (done_dialog)
  (unload_dialog DCL_ID)
 )

 (setq RFLALIGNSLBNAME "rflAlign.slb")
 (if (= nil (findfile RFLALIGNSLBNAME))
  (progn
   (setq RFLALIGNSLBNAME (vl-filename-mktemp "rfl.slb"))
   (RFL:MAKERFLSLB RFLALIGNSLBNAME)
  )
 )
 (if (= DUALCARDCLNAME nil)
  (progn
   (setq DUALCARDCLNAME (vl-filename-mktemp "rfl.dcl"))
   (RFL:MAKEDCL DUALCARDCLNAME "DUALCAR")
  )
  (if (= nil (findfile DUALCARDCLNAME))
   (progn
    (setq DUALCARDCLNAME (vl-filename-mktemp "rfl.dcl"))
    (RFL:MAKEDCL DUALCARDCLNAME "DUALCAR")
   )
  )
 )
 (setq DCL_ID (load_dialog DUALCARDCLNAME))
 (if (not (new_dialog "DUALCAR" DCL_ID)) (exit))

 (INITIATE)
 (SETENABLED)

 (action_tile "LDF" "(set_tile \"LDV\" \"0\")(SETENABLED)")
 (action_tile "LDV" "(set_tile \"LDF\" \"0\")(SETENABLED)")
 (action_tile "MDF" "(set_tile \"MDV\" \"0\")(SETENABLED)")
 (action_tile "MDV" "(set_tile \"MDF\" \"0\")(SETENABLED)")
 (action_tile "RDF" "(set_tile \"RDV\" \"0\")(SETENABLED)")
 (action_tile "RDV" "(set_tile \"RDF\" \"0\")(SETENABLED)")
 (action_tile "LCOSF" "(set_tile \"LCOSV\" \"0\")(SETENABLED)")
 (action_tile "LCOSV" "(set_tile \"LCOSF\" \"0\")(SETENABLED)")
 (action_tile "RCOSF" "(set_tile \"RCOSV\" \"0\")(SETENABLED)")
 (action_tile "RCOSV" "(set_tile \"RCOSF\" \"0\")(SETENABLED)")
 (action_tile "LSOSF" "(set_tile \"LSOSV\" \"0\")(SETENABLED)")
 (action_tile "LSOSV" "(set_tile \"LSOSF\" \"0\")(SETENABLED)")
 (action_tile "RSOSF" "(set_tile \"RSOSV\" \"0\")(SETENABLED)")
 (action_tile "RSOSV" "(set_tile \"RSOSF\" \"0\")(SETENABLED)")
 (action_tile "LMOSF" "(set_tile \"LMOSV\" \"0\")(SETENABLED)")
 (action_tile "LMOSV" "(set_tile \"LMOSF\" \"0\")(SETENABLED)")
 (action_tile "RMOSF" "(set_tile \"RMOSV\" \"0\")(SETENABLED)")
 (action_tile "RMOSV" "(set_tile \"RMOSF\" \"0\")(SETENABLED)")
 (action_tile "LVF" "(SETENABLED)")
 (action_tile "LVV" "(SETENABLED)")
 (action_tile "RVF" "(SETENABLED)")
 (action_tile "RVV" "(SETENABLED)")
 (action_tile "FROMTOBEGIN" "(SETENABLED)")
 (action_tile "FROMTOEND" "(SETENABLED)")

 (action_tile "CHOR" "(CHECKFILE \"CHOR\" \".HOR\")")
 (action_tile "CVER" "(CHECKFILE \"CVER\" \".VRT\")")
 (action_tile "CSUPER" "(CHECKFILE \"CSUPER\" \".E\")")
 (action_tile "LDVVAL" "(CHECKFILE \"LDVVAL\" \".VRT\")")
 (action_tile "MDVVAL" "(CHECKFILE \"MDVVAL\" \".VRT\")")
 (action_tile "RDVVAL" "(CHECKFILE \"RDVVAL\" \".VRT\")")
 (action_tile "LCOSVVAL" "(CHECKFILE \"LCOSVVAL\" \".HOR\")")
 (action_tile "RCOSVVAL" "(CHECKFILE \"RCOSVVAL\" \".HOR\")")
 (action_tile "LSOSVVAL" "(CHECKFILE \"LSOSVVAL\" \".HOR\")")
 (action_tile "RSOSVVAL" "(CHECKFILE \"RSOSVVAL\" \".HOR\")")
 (action_tile "LMOSVVAL" "(CHECKFILE \"LMOSVVAL\" \".HOR\")")
 (action_tile "RMOSVVAL" "(CHECKFILE \"RMOSVVAL\" \".HOR\")")
 (action_tile "LVVVAL" "(CHECKFILE \"LVVVAL\" \".VRT\")")
 (action_tile "RVVVAL" "(CHECKFILE \"RVVVAL\" \".VRT\")")

 (action_tile "NORMAL" "(FIXNUMBER \"NORMAL\")")
 (action_tile "LDFVAL" "(FIXNUMBER \"LDFVAL\")")
 (action_tile "MDFVAL" "(FIXNUMBER \"MDFVAL\")")
 (action_tile "RDFVAL" "(FIXNUMBER \"RDFVAL\")")
 (action_tile "LSD1" "(FIXNUMBER \"LSD1\")")
 (action_tile "RSD1" "(FIXNUMBER \"RSD1\")")
 (action_tile "LSD2" "(FIXNUMBER \"LSD2\")")
 (action_tile "RSD2" "(FIXNUMBER \"RSD2\")")
 (action_tile "LCOSFVAL" "(FIXNUMBER \"LCOSFVAL\")")
 (action_tile "RCOSFVAL" "(FIXNUMBER \"RCOSFVAL\")")
 (action_tile "LSOSFVAL" "(FIXNUMBER \"LSOSFVAL\")")
 (action_tile "RSOSFVAL" "(FIXNUMBER \"RSOSFVAL\")")
 (action_tile "LMOSFVAL" "(FIXNUMBER \"LMOSFVAL\")")
 (action_tile "RMOSFVAL" "(FIXNUMBER \"RMOSFVAL\")")
 (action_tile "LSLOPE1" "(FIXNUMBER \"LSLOPE1\")")
 (action_tile "RSLOPE1" "(FIXNUMBER \"RSLOPE1\")")
 (action_tile "LSLOPE2" "(FIXNUMBER \"LSLOPE2\")")
 (action_tile "RSLOPE2" "(FIXNUMBER \"RSLOPE2\")")
 (action_tile "LSLOPE3" "(FIXNUMBER \"LSLOPE3\")")
 (action_tile "RSLOPE3" "(FIXNUMBER \"RSLOPE3\")")
 (action_tile "LSLOPE4" "(FIXNUMBER \"LSLOPE4\")")
 (action_tile "RSLOPE4" "(FIXNUMBER \"RSLOPE4\")")
 (action_tile "LSLOPE5" "(FIXNUMBER \"LSLOPE5\")")
 (action_tile "RSLOPE5" "(FIXNUMBER \"RSLOPE5\")")
 (action_tile "LSLOPE6" "(FIXNUMBER \"LSLOPE6\")")
 (action_tile "RSLOPE6" "(FIXNUMBER \"RSLOPE6\")")
 (action_tile "FROMTOSTARTVAL" "(FIXNUMBER \"FROMTOSTARTVAL\")")
 (action_tile "FROMTOENDVAL" "(FIXNUMBER \"FROMTOENDVAL\")")
 (action_tile "FROMTOSTEP" "(FIXNUMBER \"FROMTOSTEP\")")

 (action_tile "CHORPICK" "(PICKFILE \"CHOR\" \".HOR\")")
 (action_tile "CVERPICK" "(PICKFILE \"CVER\" \".VRT\")")
 (action_tile "LDVPICK" "(PICKFILE \"LDVVAL\" \".VRT\")")
 (action_tile "MDVPICK" "(PICKFILE \"MDVVAL\" \".VRT\")")
 (action_tile "RDVPICK" "(PICKFILE \"RDVVAL\" \".VRT\")")
 (action_tile "CSUPERPICK" "(PICKFILE \"CSUPER\" \".E\")")
 (action_tile "LCOSVPICK" "(PICKFILE \"LCOSVVAL\" \".HOR\")")
 (action_tile "RCOSVPICK" "(PICKFILE \"RCOSVVAL\" \".HOR\")")
 (action_tile "LSOSVPICK" "(PICKFILE \"LSOSVVAL\" \".HOR\")")
 (action_tile "RSOSVPICK" "(PICKFILE \"RSOSVVAL\" \".HOR\")")
 (action_tile "LMOSVPICK" "(PICKFILE \"LMOSVVAL\" \".HOR\")")
 (action_tile "RMOSVPICK" "(PICKFILE \"RMOSVVAL\" \".HOR\")")
 (action_tile "LVVPICK" "(PICKFILE \"LVVVAL\" \".VRT\")")
 (action_tile "RVVPICK" "(PICKFILE \"RVVVAL\" \".VRT\")")

 (action_tile "SSW" "(WRITESETTINGS)")
 (action_tile "SSR" "(READSETTINGS)")

 (action_tile "OK" "(ACCEPTDUALCAR)")
 (action_tile "CANCEL" "(CANCELDUALCAR)")

 (start_dialog)

 (if (= CANCEL 0)
  (progn
   (princ "\nChecking for input errors :\n")
   (if (= "n/a" (cdr (assoc "CHOR" RFL:DUALCARLIST)))
    (progn
     (princ "     *****     Centerline horizontal control not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (= "n/a" (cdr (assoc "CVER" RFL:DUALCARLIST)))
    (progn
     (princ "     *****     Centerline vertical control not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (= "n/a" (cdr (assoc "CSUPER" RFL:DUALCARLIST)))
    (progn
     (princ "     *****     Centerline superelevation control not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "LDV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "LDVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable left ditch selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "MDV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "MDVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable median ditch selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "RDV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "RDVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable right ditch selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "LCOSV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "LCOSVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable left carriage centerline selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "LSOSV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "LSOSVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable left carriage shoulder selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "LMOSV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "LMOSVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable left carriage median selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "RCOSV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "RCOSVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable right carriage centerline selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "RSOSV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "RSOSVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable right carriage shoulder selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "RMOSV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "RMOSVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Variable right carriage median selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "LVV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "LVVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Independant left carriage profile selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (and (= "1" (cdr (assoc "RVV" RFL:DUALCARLIST))) (= "n/a" (cdr (assoc "RVVVAL" RFL:DUALCARLIST))))
    (progn
     (princ "     *****     Independant right carriage profile selected but not set!\n")
     (setq CANCEL 1)
    )
   )
   (if (= CANCEL 0)
    (progn
     (setq ALSAVE RFL:ALIGNLIST PVISAVE RFL:PVILIST SUPERSAVE RFL:SUPERLIST)

     (if (= "1" (cdr (assoc "LDV" RFL:DUALCARLIST)))
      (progn
       (RFL:RPROF (cdr (assoc "LDVVAL" RFL:DUALCARLIST)))
       (setq DITCHLEFT RFL:PVILIST)
      )
      (setq DITCHLEFT nil)
     )

     (if (= "1" (cdr (assoc "MDV" RFL:DUALCARLIST)))
      (progn
       (RFL:RPROF (cdr (assoc "MDVVAL" RFL:DUALCARLIST)))
       (setq DITCHMEDIAN RFL:PVILIST)
      )
      (setq DITCHMEDIAN nil)
     )

     (if (= "1" (cdr (assoc "RDV" RFL:DUALCARLIST)))
      (progn
       (RFL:RPROF (cdr (assoc "RDVVAL" RFL:DUALCARLIST)))
       (setq DITCHRIGHT RFL:PVILIST)
      )
      (setq DITCHRIGHT nil)
     )

     (if (= "1" (cdr (assoc "LCOSV" RFL:DUALCARLIST)))
      (progn
       (RFL:RALIGN (cdr (assoc "LCOSVVAL" RFL:DUALCARLIST)))
       (setq ALLEFT RFL:ALIGNLIST)
      )
      (setq ALLEFT nil)
     )

     (if (= "1" (cdr (assoc "LSOSV" RFL:DUALCARLIST)))
      (progn
       (RFL:RALIGN (cdr (assoc "LSOSVVAL" RFL:DUALCARLIST)))
       (setq ALLEFTSHLDR RFL:ALIGNLIST)
      )
      (setq ALLEFTSHLDR nil)
     )

     (if (= "1" (cdr (assoc "LMOSV" RFL:DUALCARLIST)))
      (progn
       (RFL:RALIGN (cdr (assoc "LMOSVVAL" RFL:DUALCARLIST)))
       (setq ALLEFTMDN RFL:ALIGNLIST)
      )
      (setq ALLEFTMDN nil)
     )

     (if (= "1" (cdr (assoc "RCOSV" RFL:DUALCARLIST)))
      (progn
       (RFL:RALIGN (cdr (assoc "RCOSVVAL" RFL:DUALCARLIST)))
       (setq ALRIGHT RFL:ALIGNLIST)
      )
      (setq ALRIGHT nil)
     )

     (if (= "1" (cdr (assoc "RSOSV" RFL:DUALCARLIST)))
      (progn
       (RFL:RALIGN (cdr (assoc "RSOSVVAL" RFL:DUALCARLIST)))
       (setq ALRIGHTSHLDR RFL:ALIGNLIST)
      )
      (setq ALRIGHTSHLDR nil)
     )

     (if (= "1" (cdr (assoc "RMOSV" RFL:DUALCARLIST)))
      (progn
       (RFL:RALIGN (cdr (assoc "RMOSVVAL" RFL:DUALCARLIST)))
       (setq ALRIGHTMDN RFL:ALIGNLIST)
      )
      (setq ALRIGHTMDN nil)
     )

     (if (= "1" (cdr (assoc "LVV" RFL:DUALCARLIST)))
      (progn
       (RFL:RPROF (cdr (assoc "LVVVAL" RFL:DUALCARLIST)))
       (setq LEFTPROF RFL:PVILIST)
      )
      (setq LEFTPROF nil)
     )

     (if (= "1" (cdr (assoc "RVV" RFL:DUALCARLIST)))
      (progn
       (RFL:RPROF (cdr (assoc "RVVVAL" RFL:DUALCARLIST)))
       (setq RIGHTPROF RFL:PVILIST)
      )
      (setq RIGHTPROF nil)
     )

     (RFL:RALIGN (cdr (assoc "CHOR" RFL:DUALCARLIST)))
     (setq CHOR RFL:ALIGNLIST)
     (RFL:RPROF (cdr (assoc "CVER" RFL:DUALCARLIST)))
     (setq CVER RFL:PVILIST)
     (RFL:RSUPER (cdr (assoc "CSUPER" RFL:DUALCARLIST)))
     (if (or (= nil RFL:ALIGNLIST) (= nil RFL:PVILIST) (= nil RFL:SUPERLIST))
      (princ "\n***** Problem reading centerline control!\n")
      (progn
       (if (= "1" (cdr (assoc "FROMTOBEGIN" RFL:DUALCARLIST)))
        (setq STASTART (max (caar RFL:ALIGNLIST)
			    (caar RFL:PVILIST)
			    (caar RFL:SUPERLIST)
		       )
	)
        (setq STASTART (cdr (assoc "FROMTOSTARTVAL" RFL:DUALCARLIST)))
       )
       (setq STA STASTART)
       (if (= "1" (cdr (assoc "FROMTOEND" RFL:DUALCARLIST)))
        (setq STAEND (min (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH))
			  (car (last RFL:PVILIST))
			  (car (last RFL:SUPERLIST))
		     )
	)
        (setq STAEND (cdr (assoc "FROMTOENDVAL" RFL:DUALCARLIST)))
       )
       (setq STASTEP (cdr (assoc "FROMTOSTEP" RFL:DUALCARLIST)))

       (princ "\n")

       (princ "\nCalculating points :\n")

       (setq STOPFLAG 0)

       (while (= STOPFLAG 0)
        (if (>= STA STAEND) (setq STOPFLAG 1))

        (princ (strcat "   " (rtos STA 2 0)))
        (PINWHEEL)

        (if (and (/= nil (RFL:SUPER STA))
                 (/= nil (RFL:ELEVATION STA))
                 (/= nil (RFL:XY (list STA 0.0))))
         (progn

          (setq SUPERLEFT (car (RFL:SUPER STA)))
          (setq SUPERRIGHT (cadr (RFL:SUPER STA)))

          (setq PL1 nil PL2 nil PL3 nil PL4 nil PL5 nil PL6 nil PL7 nil PL8 nil PL9 nil PL10 nil PL11 nil PL12 nil)

          (if (= nil LEFTPROF)
           (setq LELEV (RFL:ELEVATION STA))
           (progn
            (setq RFL:PVILIST LEFTPROF)
            (setq LELEV (RFL:ELEVATION STA))
            (setq RFL:PVILIST CVER)
           )
          )

          (if (= "1" (cdr (assoc "LCOSF" RFL:DUALCARLIST)))
           (setq LOS1 (cdr (assoc "LCOSFVAL" RFL:DUALCARLIST)))
           (setq LOS1 (* -1.0 (GETOFFSET STA 0.0 ALLEFT)))
          )
          (if (= "1" (cdr (assoc "LSOSF" RFL:DUALCARLIST)))
           (setq LSHLDR (cdr (assoc "LSOSFVAL" RFL:DUALCARLIST)))
           (setq LSHLDR (* -1.0 (GETOFFSET STA (* -1.0 LOS1) ALLEFTSHLDR)))
          )
          (if (= "1" (cdr (assoc "LMOSF" RFL:DUALCARLIST)))
           (setq LMDN (cdr (assoc "LMOSFVAL" RFL:DUALCARLIST)))
           (setq LMDN (GETOFFSET STA (* -1.0 LOS1) ALLEFTMDN))
          )
          (cond ((= "1" (cdr (assoc "LPIVOT4" RFL:DUALCARLIST)))
                 (progn
                  (setq PL4 (list (- LMDN LOS1) LELEV))
                  (setq PL5 (list (* -1.0 LOS1) (- LELEV (* SUPERRIGHT 0.01 LMDN))))
                  (setq PL6 (list (* -1.0 (+ LSHLDR LOS1)) (+ (cadr PL5) (* SUPERLEFT 0.01 LSHLDR))))
                 )
                )
                ((= "1" (cdr (assoc "LPIVOT5" RFL:DUALCARLIST)))
                 (progn
                  (setq PL5 (list (* -1.0 LOS1) LELEV))
                  (setq PL4 (list (- LMDN LOS1) (+ LELEV (* SUPERRIGHT 0.01 LMDN))))
                  (setq PL6 (list (* -1.0 (+ LSHLDR LOS1)) (+ LELEV (* SUPERLEFT 0.01 LSHLDR))))
                 )
                )
                ((= "1" (cdr (assoc "LPIVOT6" RFL:DUALCARLIST)))
                 (progn
                  (setq PL6 (list (* -1.0 (+ LSHLDR LOS1)) LELEV))
                  (setq PL5 (list (* -1.0 LOS1) (- LELEV (* SUPERLEFT 0.01 LSHLDR))))
                  (setq PL4 (list (- LMDN LOS1) (+ (cadr PL5) (* SUPERRIGHT 0.01 LMDN))))
                 )
                )
          )
          (setq D (cdr (assoc "LSD1" RFL:DUALCARLIST)))
          (setq PL11 (list (car PL5) (- (cadr PL5) D)))
          (setq SLOPE (cdr (assoc "LSLOPE3" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERRIGHT)))
                    )
          )
          (setq PL3 (list (+ (car PL4) TMP)
                          (- (cadr PL4) D (* -1.0 TMP (* 0.01 SUPERRIGHT)))
                    )
          )
          (setq SLOPE (cdr (assoc "LSLOPE4" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERLEFT)))
                    )
          )
          (setq PL7 (list (- (car PL6) TMP)
                          (- (cadr PL6) D (* -1.0 TMP (* 0.01 SUPERLEFT)))
                    )
          )

          (setq D (cdr (assoc "LSD2" RFL:DUALCARLIST)))
          (setq PL12 (list (car PL11) (- (cadr PL11) D)))
          (setq SLOPE (cdr (assoc "LSLOPE2" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERRIGHT)))
                    )
          )
          (setq PL2 (list (+ (car PL3) TMP)
                          (- (cadr PL3) D (* -1.0 TMP (* 0.01 SUPERRIGHT)))
                    )
          )
          (setq SLOPE (cdr (assoc "LSLOPE5" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERLEFT)))
                    )
          )
          (setq PL8 (list (- (car PL7) TMP)
                          (- (cadr PL7) D (* -1.0 TMP (* 0.01 SUPERLEFT)))
                    )
          )

          (if (= nil DITCHLEFT)
           (setq TMP (- (cadr PL8) (cdr (assoc "LDFVAL" RFL:DUALCARLIST))))
           (progn
            (setq RFL:PVILIST DITCHLEFT)
            (setq TMP (RFL:ELEVATION STA))
            (setq RFL:PVILIST CVER)
           )
          )
          (setq PL9 (list (- (car PL8)
                             (* (cdr (assoc "LSLOPE6" RFL:DUALCARLIST))
                                (- (cadr PL8) TMP)
                             )
                          )
                          TMP
                    )
          )
          (setq PL10 (list (- (car PL9) (cdr (assoc "LDW" RFL:DUALCARLIST)))
                           TMP
                     )
          )

          (if (= nil DITCHMEDIAN)
           (setq TMP (- (RFL:ELEVATION STA) (cdr (assoc "MDFVAL" RFL:DUALCARLIST))))
           (progn
            (setq RFL:PVILIST DITCHMEDIAN)
            (setq TMP (RFL:ELEVATION STA))
            (setq RFL:PVILIST CVER)
           )
          )
          (setq PL1 (list (+ (car PL2)
                             (* (cdr (assoc "LSLOPE1" RFL:DUALCARLIST))
                                (- (cadr PL2) TMP)
                             )
                          )
                          TMP
                    )
          )

          (setq PR1 nil PR2 nil PR3 nil PR4 nil PR5 nil PR6 nil PR7 nil PR8 nil PR9 nil PR10 nil PR11 nil PR12 nil)

          (if (= nil RIGHTPROF)
           (setq RELEV (RFL:ELEVATION STA))
           (progn
            (setq RFL:PVILIST RIGHTPROF)
            (setq RELEV (RFL:ELEVATION STA))
            (setq RFL:PVILIST CVER)
           )
          )

          (if (= "1" (cdr (assoc "RCOSF" RFL:DUALCARLIST)))
           (setq ROS1 (cdr (assoc "RCOSFVAL" RFL:DUALCARLIST)))
           (setq ROS1 (GETOFFSET STA 0.0 ALRIGHT))
          )
          (if (= "1" (cdr (assoc "RSOSF" RFL:DUALCARLIST)))
           (setq RSHLDR (cdr (assoc "RSOSFVAL" RFL:DUALCARLIST)))
           (setq RSHLDR (GETOFFSET STA ROS1 ALRIGHTSHLDR))
          )
          (if (= "1" (cdr (assoc "RMOSF" RFL:DUALCARLIST)))
           (setq RMDN (cdr (assoc "RMOSFVAL" RFL:DUALCARLIST)))
           (setq RMDN (* -1.0 (GETOFFSET STA ROS1 ALRIGHTMDN)))
          )
          (cond ((= "1" (cdr (assoc "RPIVOT4" RFL:DUALCARLIST)))
                 (progn
                  (setq PR4 (list (- ROS1 RMDN) RELEV))
                  (setq PR5 (list ROS1 (- RELEV (* SUPERLEFT 0.01 RMDN))))
                  (setq PR6 (list (+ RSHLDR ROS1) (+ (cadr PR5) (* SUPERRIGHT 0.01 RSHLDR))))
                 )
                )
                ((= "1" (cdr (assoc "RPIVOT5" RFL:DUALCARLIST)))
                 (progn
                  (setq PR5 (list ROS1 RELEV))
                  (setq PR4 (list (- ROS1 RMDN) (+ RELEV (* SUPERLEFT 0.01 RMDN))))
                  (setq PR6 (list (+ RSHLDR ROS1) (+ RELEV (* SUPERRIGHT 0.01 RSHLDR))))
                 )
                )
                ((= "1" (cdr (assoc "RPIVOT6" RFL:DUALCARLIST)))
                 (progn
                  (setq PR6 (list (+ RSHLDR ROS1) RELEV))
                  (setq PR5 (list ROS1 (- RELEV (* SUPERRIGHT 0.01 RSHLDR))))
                  (setq PR4 (list (- ROS1 RMDN) (+ (cadr PR5) (* SUPERLEFT 0.01 RMDN))))
                 )
                )
          )
          (setq D (cdr (assoc "RSD1" RFL:DUALCARLIST)))
          (setq PR11 (list (car PR5) (- (cadr PR5) D)))
          (setq SLOPE (cdr (assoc "RSLOPE3" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERLEFT)))
                    )
          )
          (setq PR3 (list (- (car PR4) TMP)
                          (- (cadr PR4) D (* -1.0 TMP (* 0.01 SUPERLEFT)))
                    )
          )
          (setq SLOPE (cdr (assoc "RSLOPE4" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERRIGHT)))
                    )
          )
          (setq PR7 (list (+ (car PR6) TMP)
                          (- (cadr PR6) D (* -1.0 TMP (* 0.01 SUPERRIGHT)))
                    )
          )

          (setq D (cdr (assoc "RSD2" RFL:DUALCARLIST)))
          (setq PR12 (list (car PR11) (- (cadr PR11) D)))
          (setq SLOPE (cdr (assoc "RSLOPE2" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERLEFT)))
                    )
          )
          (setq PR2 (list (- (car PR3) TMP)
                          (- (cadr PR3) D (* -1.0 TMP (* 0.01 SUPERLEFT)))
                    )
          )
          (setq SLOPE (cdr (assoc "RSLOPE5" RFL:DUALCARLIST)))
          (setq TMP (/ (* D SLOPE)
                       (+ 1.0 (* SLOPE (* 0.01 SUPERRIGHT)))
                    )
          )
          (setq PR8 (list (+ (car PR7) TMP)
                          (- (cadr PR7) D (* -1.0 TMP (* 0.01 SUPERRIGHT)))
                    )
          )

          (if (= nil DITCHRIGHTT)
           (setq TMP (- (cadr PR8) (cdr (assoc "RDFVAL" RFL:DUALCARLIST))))
           (progn
            (setq RFL:PVILIST DITCHRIGHTT)
            (setq TMP (RFL:ELEVATION STA))
            (setq RFL:PVILIST CVER)
           )
          )
          (setq PR9 (list (+ (car PR8)
                             (* (cdr (assoc "RSLOPE6" RFL:DUALCARLIST))
                                (- (cadr PR8) TMP)
                             )
                          )
                          TMP
                    )
          )
          (setq PR10 (list (+ (car PR9) (cdr (assoc "RDW" RFL:DUALCARLIST)))
                           TMP
                     )
          )

          (if (= nil DITCHMEDIAN)
           (setq TMP (- (RFL:ELEVATION STA) (cdr (assoc "MDFVAL" RFL:DUALCARLIST))))
           (progn
            (setq RFL:PVILIST DITCHMEDIAN)
            (setq TMP (RFL:ELEVATION STA))
            (setq RFL:PVILIST CVER)
           )
          )
          (setq PR1 (list (- (car PR2)
                             (* (cdr (assoc "RSLOPE1" RFL:DUALCARLIST))
                                (- (cadr PR2) TMP)
                             )
                          )
                          TMP
                    )
          )

          (setq DUALCARSECTIONLIST
                (append DUALCARSECTIONLIST
                        (list (list STA
                                    (cons "PL1" PL1)
                                    (cons "PL2" PL2)
                                    (cons "PL3" PL3)
                                    (cons "PL4" PL4)
                                    (cons "PL5" PL5)
                                    (cons "PL6" PL6)
                                    (cons "PL7" PL7)
                                    (cons "PL8" PL8)
                                    (cons "PL9" PL9)
                                    (cons "PL10" PL10)
                                    (cons "PL11" PL11)
                                    (cons "PL12" PL12)
                                    (cons "PR1" PR1)
                                    (cons "PR2" PR2)
                                    (cons "PR3" PR3)
                                    (cons "PR4" PR4)
                                    (cons "PR5" PR5)
                                    (cons "PR6" PR6)
                                    (cons "PR7" PR7)
                                    (cons "PR8" PR8)
                                    (cons "PR9" PR9)
                                    (cons "PR10" PR10)
                                    (cons "PR11" PR11)
                                    (cons "PR12" PR12)
                              )
                        )
                )
          )

         )
        )

        (setq STA (- (+ STA STASTEP) (rem STA STASTEP)))
        (if (>= STA STAEND) (setq STA STAEND))

       )
       (princ "\nDrawing 3D-Polylines :\n")
       (setq LR 0)
       (while (< LR 2)
        (setq CP 1)
        (while (< CP 13)
         (if (= LR 0)
          (setq CODE (strcat "L" (itoa CP)))
          (setq CODE (strcat "R" (itoa CP)))
         )
         (if (= "1" (cdr (assoc (strcat "D" CODE) RFL:DUALCARLIST)))
          (progn
           (princ (strcat "Drawing : " CODE "\n"))
           (setq STARTFLAG 1)
           (command "._3DPOLY")
           (setq C 0)
           (while (< C (length DUALCARSECTIONLIST))
            (setq NODE (nth C DUALCARSECTIONLIST))
            (setq STA (car NODE))
            (setq TMP (cdr (assoc (strcat "P" CODE) (cdr NODE))))
            (if (/= nil TMP)
             (progn
              (setq OFFSET (car TMP))
              (setq ELEV (cadr TMP))
              (setq P (RFL:XY (list STA OFFSET)))
              (command (list (nth 0 P) (nth 1 P) ELEV))
             )
            )
            (setq C (+ C 1))
           )
           (command "")
          )
         )
         (setq CP (+ CP 1))
        )
        (setq LR (+ LR 1))
       )

       (if (= "1" (cdr (assoc "FROMTOFILE" RFL:DUALCARLIST)))
        (progn
         (setq OUTFILE (getfiled "Select a file for saving" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "" 1))
         (if (/= nil OUTFILE)
          (progn
           (setq OUTFILE (open OUTFILE "w"))
           (setq C 0)
           (while (< C (length DUALCARSECTIONLIST))
            (setq NODE (nth C DUALCARSECTIONLIST))
            (princ (rtos (car NODE) 2 8) OUTFILE)
            (princ "," OUTFILE)
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL1" RFL:DUALCARLIST)))
             (progn
              (princ "L1," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL2" RFL:DUALCARLIST)))
             (progn
              (princ "L2," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL3" RFL:DUALCARLIST)))
             (progn
              (princ "L3," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL4" RFL:DUALCARLIST)))
             (progn
              (princ "L4," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL5" RFL:DUALCARLIST)))
             (progn
              (princ "L5," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL6" RFL:DUALCARLIST)))
             (progn
              (princ "L6," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL7" RFL:DUALCARLIST)))
             (progn
              (princ "L7," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL8" RFL:DUALCARLIST)))
             (progn
              (princ "L8," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL9" RFL:DUALCARLIST)))
             (progn
              (princ "L9," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL10" RFL:DUALCARLIST)))
             (progn
              (princ "L10," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL11" RFL:DUALCARLIST)))
             (progn
              (princ "L11," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DL12" RFL:DUALCARLIST)))
             (progn
              (princ "L12," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR1" RFL:DUALCARLIST)))
             (progn
              (princ "R1," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR2" RFL:DUALCARLIST)))
             (progn
              (princ "R2," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR3" RFL:DUALCARLIST)))
             (progn
              (princ "R3," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR4" RFL:DUALCARLIST)))
             (progn
              (princ "R4," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR5" RFL:DUALCARLIST)))
             (progn
              (princ "R5," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR6" RFL:DUALCARLIST)))
             (progn
              (princ "R6," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR7" RFL:DUALCARLIST)))
             (progn
              (princ "R7," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR8" RFL:DUALCARLIST)))
             (progn
              (princ "R8," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR9" RFL:DUALCARLIST)))
             (progn
              (princ "R9," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR10" RFL:DUALCARLIST)))
             (progn
              (princ "R10," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR11" RFL:DUALCARLIST)))
             (progn
              (princ "R11," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (setq NODE (cdr NODE))
            (if (= "1" (cdr (assoc "DR12" RFL:DUALCARLIST)))
             (progn
              (princ "R12," OUTFILE)
              (princ (rtos (nth 1 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
              (princ (rtos (nth 2 (car NODE)) 2 8) OUTFILE)
              (princ "," OUTFILE)
             )
            )
            (princ "\n" OUTFILE)
            (setq C (+ C 1))
           )
           (close OUTFILE)
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 2017-04-11
;
;     C:ESTRADIUS estimates the segmented alignments radius at a given point
;
;
(defun C:ESTRADIUS (/ CMDECHO R RFL:ESTRADIUSDIST RFL:ESTRADIUSNUMPOINTS STA TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 
 (setq R nil)
 
 (if (setq TMP (getdist "\nMaximum distance from point for estimation <30.0> : "))
  (setq RFL:ESTRADIUSDIST TMP)
  (setq RFL:ESTRADIUSDIST 30.0)
 )
 (if (or (= nil (setq TMP (getint "\nMaximum number of points for estimation <10> : ")))
         (> TMP 2)
     )
  (setq RFL:ESTRADIUSNUMPOINTS TMP)
  (setq RFL:ESTRADIUSNUMPOINTS 10)
 )
 (while (setq STA (car (RFL:STAOFF (getpoint "\nSelect point : "))))
  (if (setq R (RFL:ESTRADIUS STA))
   (if (< R 0.0)
    (princ (strcat "\nRadius = " (rtos (abs R)) " Right\n"))
    (princ (strcat "\nRadius = " (rtos (abs R)) " Left\n"))
   )
  )
 )
 (setvar "CMDECHO" CMDECHO)
 R
)
;
;
;    Program Written by Robert Livingston, 99/07/14
;    C:FITSPIRAL draws a reverse engineered DCA spiral between two selected objects (lines and arcs)
;
;
(defun C:FITSPIRAL (/ CMDECHO ENT1 ENT2 ENTLIST1 ENTLIST2 GETLS LS1 LS2 R)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (defun GETLS (R MSG / LS AL)
  (setq LS nil)
  (setq AL "L")
  (if (= R 0.0)
   (progn
    (princ "\n*** Zero length arc selected - only spiral length valid!")
    (setq LS (getreal (strcat MSG " length :")))
   )
   (progn
    (while (= LS nil)
     (if (= AL "L")
      (progn
       (setq LS (getreal (strcat MSG " length <return for A>:")))
       (if (= LS nil)
        (progn
         (setq AL "A")
        )
       )
      )
      (progn
       (setq LS (getreal (strcat MSG " A <return for length>:")))
       (if (= LS nil)
        (progn
         (setq AL "L")
        )
        (progn
         (setq LS (/ (* LS LS) R))
        )
       )
      )
     )
    )
   )
  )
  (eval LS)
 )
 
 (if (/= (setq ENT1 (car (entsel "\nSelect first entity : "))) nil)
  (if (/= (setq ENT2 (car (entsel "\nSelect second entity : "))) nil)
   (progn
    (setq ENTLIST1 (entget ENT1))
    (setq ENTLIST2 (entget ENT2))
    (if (and (= (cdr (assoc 0 ENTLIST1)) "LINE") (= (cdr (assoc 0 ENTLIST2)) "LINE"))
     (progn
      (if (/= (setq R (getreal "\nEnter radius (0 for Spiral/Spiral) : ")) nil)
       (if (/= (setq LS1 (GETLS R "\nSpiral IN")) nil)
        (if (/= (setq LS2 (GETLS R "\nSpiral OUT")) nil)
         (RFL:FITSPIRALLL ENT1 ENT2 LS1 R LS2)
        )
       )
      )
     )
     (if (and (= (cdr (assoc 0 ENTLIST1)) "LINE") (= (cdr (assoc 0 ENTLIST2)) "ARC"))
      (progn
       (RFL:FITSPIRALLA ENT1 ENT2)
      )
      (if (and (= (cdr (assoc 0 ENTLIST1)) "ARC") (= (cdr (assoc 0 ENTLIST2)) "LINE"))
       (progn
        (RFL:FITSPIRALLA ENT2 ENT1)
       )
       (if (and (= (cdr (assoc 0 ENTLIST1)) "ARC") (= (cdr (assoc 0 ENTLIST2)) "ARC"))
        (progn
;         (RFL:FITSPIRALAA ENT1 ENT2)
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;     Program written by Robert Livingston, 2015-03-13
;
;     FIX+ modifies a text entity to adjust it's '+' to align with its insertion point.
;
;
(defun C:FIX+ (/ *error* ANGBASE ANGDIR ATTREQ CMDECHO ENT ORTHOMODE OSMODE)
 (setq ATTREQ (getvar "ATTREQ"))
 (setvar "ATTREQ" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)

 (defun *error* (msg)
  (setvar "ATTREQ" ATTREQ)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (print msg)
 )

 (while (/= nil (setq ENT (car (entsel))))
  (RFL:FIX+ ENT)
 )
 
 (setvar "ATTREQ" ATTREQ)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
)
;
;
;   Program written by Robert Livingston, 98/06/11
;
;   GALIGN extracts a horizontal alignment from the current drawing
;
;
(defun C:GALIGN (/ ALIGNENT ALIGNENTLIST ANGBASE ANGDIR CMDECHO PSTART STASTART)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (command "._UNDO" "M")
 (command "._UCS" "W")

 (if (/= RFL:ALIGNDEF nil)
  (progn
   (setq RFL:ALIGNLIST nil)
   (setq PSTART (getpoint "\nStart point:"))
   (if (/= PSTART nil)
    (progn
     (setq STASTART (getreal "\nStart chainage:"))
     (if (/= STASTART nil)
      (progn
       (princ "\nSelect R14 polyline (<return> to select SoftDesk entities):")
       (setq ALIGNENT (car (entsel)))
       (if (= ALIGNENT nil)
        (progn
         (setq ALIGNENT (ssget))
         (setq RFL:ALIGNLIST (RFL:ALIGNDEF (list ALIGNENT) PSTART STASTART))
        )
        (progn
         (setq ALIGNENTLIST (entget ALIGNENT))
         (if (= (cdr (assoc 0 ALIGNENTLIST)) "POLYLINE")
          (progn
           (command "._CONVERT" "P" "S" ALIGNENT "")
           (setq ALIGNENTLIST (entget ALIGNENT))
          )
         )
         (if (= (cdr (assoc 0 ALIGNENTLIST)) "LWPOLYLINE")
          (progn
           (setq RFL:ALIGNLIST (RFL:ALIGNDEF ALIGNENT PSTART STASTART))
          )
          (princ "\n**** NOT A POLYLINE ****")
         )
        )
       )
      )
     )
    )
   )
  )
  (progn
   (princ "\n!!!!! ALIGNMENT UTILITIES NOT LOADED !!!!!\n")
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
);
;
;   Program written by Robert Livingston, 2018/06/06
;
;   C:GEXSUPER Estimates existing superelevation based on an alignment and surface
;
;
(defun C:GEXSUPER (/ C CMDECHO INC GETSUPERNODE GETBESTPARABOLA NODE NSAMPLES OBSURFACE OS OSL OSR P PBLIST PL PR SL SLIST SR STA STAEND TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (defun GETSUPERNODE (OBSURFACE STA OSL OS OSR / NODE SL SR Z ZL ZR)
  (setq NODE nil
        SL nil
        SR nil
        Z nil
        ZL nil
        ZR nil
  )
  (if (setq PL (RFL:XY (list STA OSL)))
   (if (= (setq ZL (RFL:GETSURFACEPOINT PL OBSURFACE)) nil)
    (setq ZL nil)
   )
  )
  (if (setq PR (RFL:XY (list STA OSR)))
   (if (= (setq ZR (RFL:GETSURFACEPOINT PR OBSURFACE)) nil)
    (setq ZR nil)
   )
  )
  (if OS
   (progn
    (if (setq P (RFL:XY (list STA OS)))
     (if (= (setq Z (RFL:GETSURFACEPOINT P OBSURFACE)) nil)
      (setq Z nil)
     )
    )
    (if (and ZL Z ZR)
     (progn
      (setq SL (* (/ (- Z ZL) (- OS OSL)) -100.0))
      (setq SR (* (/ (- ZR Z) (- OSR OS)) 100.0))
      (setq NODE (list STA SL SR))
     )
    )
   )
   (progn
    (if (and ZL ZR)
     (progn
      (setq SL (* (/ (- ZR ZL) (- OSR OSL)) -100.0))
      (setq SR (* SL -1.0))
      (setq NODE (list STA SL SR))
     )
    )
   )
  )
  NODE
 )
 ; LR : "L" or "R"
 (defun GETBESTPARABOLA (SLIST LR / A B C G1 G2 NODE P1 P2 P3 PLIST TMP)
  (setq PLIST nil)
  (foreach NODE SLIST
   (if NODE
    (if (= LR "L")
     (setq PLIST (append PLIST (list (list (car NODE) (cadr NODE)))))
     (setq PLIST (append PLIST (list (list (car NODE) (caddr NODE)))))
    )
   )
  )
  (cond ((= (length PLIST) 0)
         nil
        )
        ((= (length PLIST) 1)
         (list (setq A 0.0) (setq B 0.0) (setq C (cadar PLIST)))
        )
        ((= (length PLIST) 2)
         (list (setq A 0.0)
               (setq B (/ (- (cadadr PLIST) (cadar PLIST)) (- (caadr PLIST) (caar PLIST))))
               (setq C (- (cadar PLIST) (* B (caar PLIST))))
         )
        )
        (T
         (progn
          (if (setq TMP (RFL:BESTVCURVE PLIST))
           (progn
            (setq P1 (car TMP))
            (setq P2 (cadr TMP))
            (setq P3 (caddr TMP))
            (setq G1 (/ (- (cadr P2) (cadr P1)) (- (car P2) (car P1))))
            (setq G2 (/ (- (cadr P3) (cadr P2)) (- (car P3) (car P2))))
            (list (setq A (/ (- G2 G1) (* 2.0 (- (car P3) (car P1)))))
                  (setq B (- G1 (* 2.0 A (car P1))))
                  (setq C (- (cadr P1) (* A (car P1) (car P1)) (* B (car P1))))
            )
           )
           nil
          )
         )
        )
  )
 )
 (if (/= RFL:ALIGNLIST nil)
  (if (setq OBSURFACE (RFL:GETC3DSURFACE))
   (progn
    (setq RFL:SUPERLIST nil)
    (setq INC 0.0)
    (while (= INC 0.0)
     (setq INC (getdist "\nStation increment <10.0> : "))
     (if (= INC nil) (setq INC 10.0))
    )
    (setq TMP (+ INC (* INC (fix (/ (caar RFL:ALIGNLIST) INC)))))
    (setq STA (getreal (strcat "\nStart Station <" (rtos TMP 2 3) "> : ")))
    (if (= nil STA) (setq STA TMP))
    (setq TMP (* INC (fix (/ (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)) INC))))
    (setq STAEND (getreal (strcat "\nEnd Station <" (rtos TMP 2 3) "> : ")))
    (if (= nil STAEND) (setq STAEND TMP))
    (setq NSAMPLES 0)
    (while (< NSAMPLES 1)
     (setq NSAMPLES (getint (strcat "\nNumber of samples (use odd number) <9> : ")))
     (if (= NSAMPLES nil)
      (setq NSAMPLES 9)
      (if (/= (rem NSAMPLES 2) 1)
       (setq NSAMPLES 0)
      )
     )
    )
    (setq TMP -3.0)
    (setq OSL (getreal (strcat "\nLeft offset <" (rtos TMP 2 3) "> : ")))
    (if (= OSL nil) (setq OSL TMP))
    (setq TMP 3.0)
    (setq OSR (getreal (strcat "\nRight offset <" (rtos TMP 2 3) "> : ")))
    (if (= OSR nil) (setq OSR TMP))
    (setq TMP 0.0)
    (setq OS (getreal (strcat "\nCenter offset (<return> for single carriageway) <nil> : ")))
    (setq SLIST nil)
    (setq C (/ NSAMPLES -2))
    (while (<= C (/ NSAMPLES 2))
     (setq NODE (GETSUPERNODE OBSURFACE (+ STA (* C INC)) OSL OS OSR))
     (setq SLIST (append SLIST (list NODE)))
     (setq C (1+ C))
    )
    (while (<= STA STAEND)
     (print (RFL:STATXT STA))
     (if (setq PBLIST (GETBESTPARABOLA SLIST "L"))
      (progn
       (setq SL (+ (* (car PBLIST) STA STA) (* (cadr PBLIST) STA) (caddr PBLIST)))
       (if (setq PBLIST (GETBESTPARABOLA SLIST "R"))
        (progn
         (setq SR (+ (* (car PBLIST) STA STA) (* (cadr PBLIST) STA) (caddr PBLIST)))
         (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list STA SL SR))))
        )
       )
      )
     )
     (setq STA (+ STA INC))
     (setq SLIST (cdr SLIST))
     (setq NODE (GETSUPERNODE OBSURFACE (+ STA (* (/ NSAMPLES 2) INC)) OSL OS OSR))
     (setq SLIST (append SLIST (list NODE)))
    )
   )
   (princ "\n!!!!! Surface Not Set !!!!!\n")
  )
  (princ "\n!!!!! Horizontal Alignment Not Set !!!!!\n")
 )
 (setvar "CMDECHO" CMDECHO)
 nil
)
;
;
;   Program written by Robert Livingston, 98/05/13
;
;   C:GPROF extracts a vertical alignment from the current drawing
;
;
(defun C:GPROF (/ ANGBASE ANGDIR C CMDECHO ENT ENTSET PVIENT PVISET STA ELEV LR VAL)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (RFL:PROFDEF)

 (setq RFL:PVILIST nil)
 (if (/= nil RFL:PROFDEFLIST)
  (progn
   (princ "Select PVI blocks (or <return> to find all based on profile definition block) : ")
   (setq ENTSET (ssget))
   (if (= nil ENTSET)
    (progn
     (setq PVISET (ssget "X" (list (cons 0 "INSERT")
                                   (cons -4 "<OR")
                                   (cons 2 "RFLPVI")
                                   (cons 2 "PVI2")
                                   (cons -4 "OR>")
                                   (cons 8 (cdr (assoc "PLAYER" RFL:PROFDEFLIST))))))
    )
    (progn
     (setq C 0)
     (setq PVISET nil)
     (while (< C (sslength ENTSET))
      (setq ENT (ssname ENTSET C))
      (if (and (/= nil (cdr (assoc 2 (entget ENT))))
               (or (= "RFLPVI" (strcase (cdr (assoc 2 (entget ENT)))))
                   (= "PVI2" (strcase (cdr (assoc 2 (entget ENT)))))
               )
          )
       (if (= nil PVISET)
        (setq PVISET (ssadd ENT))
        (ssadd ENT PVISET)
       )
      )
      (setq C (+ C 1))
     )
    )
   )

   (if (= PVISET nil)
    (princ "\n*** NO PVI's EXIST ***\n")
    (if (= (sslength PVISET) 1)
     (princ "\n*** ONLY ONE PVI EXISTS ***\n")
     (progn
      (while (> (sslength PVISET) 0)
       (setq C 1)
       (setq PVIENT (ssname PVISET 0))
       (while (< C (sslength PVISET))
        (if (or (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) 1) (= (assoc "DIRECTION" RFL:PROFDEFLIST) nil))
         (if (< (nth 0 (cdr (assoc 10 (entget PVIENT))))
                (nth 0 (cdr (assoc 10 (entget (ssname PVISET C))))))
          (setq PVIENT (ssname PVISET C))
         )
         (if (> (nth 0 (cdr (assoc 10 (entget PVIENT))))
                (nth 0 (cdr (assoc 10 (entget (ssname PVISET C))))))
          (setq PVIENT (ssname PVISET C))
         )
        )
        (setq C (+ C 1))
       )
       (setq PVISET (ssdel PVIENT PVISET))
       (setq STA (+ (* (- (nth 0 (cdr (assoc 10 (entget PVIENT))))
                          (nth 0 (cdr (assoc "BPOINT" RFL:PROFDEFLIST))))
                       (if (or (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) 1) (= (assoc "DIRECTION" RFL:PROFDEFLIST) nil)) 1.0 -1.0)
                    )
                    (cdr (assoc "STA" RFL:PROFDEFLIST))
                 )
       )
       (setq ELEV (+ (/ (- (nth 1 (cdr (assoc 10 (entget PVIENT))))
                           (nth 1 (cdr (assoc "BPOINT" RFL:PROFDEFLIST))))
                        (cdr (assoc "VEXAG" RFL:PROFDEFLIST)))
                     (cdr (assoc "ELEV" RFL:PROFDEFLIST))))
       (setq PVIENT (entnext PVIENT))
       (while (/= "SEQEND" (cdr (assoc 0 (entget PVIENT))))
        (if (= "R" (cdr (assoc 2 (entget PVIENT))))
         (if (/= "" (cdr (assoc 1 (entget PVIENT))))
          (progn
           (setq LR "R")
           (setq VAL (atof (cdr (assoc 1 (entget PVIENT)))))
          )
         )
        )
        (if (= "L" (cdr (assoc 2 (entget PVIENT))))
         (if (/= "" (cdr (assoc 1 (entget PVIENT))))
          (progn
           (setq LR "L")
           (setq VAL (atof (cdr (assoc 1 (entget PVIENT)))))
          )
         )
        )
        (if (= "LENGTH" (cdr (assoc 2 (entget PVIENT))))
         (progn
          (setq LR "L")
          (setq VAL (atof (cdr (assoc 1 (entget PVIENT)))))
         )
        )
        (setq PVIENT (entnext PVIENT))
       )
       (setq RFL:PVILIST (append (list (list STA ELEV LR VAL)) RFL:PVILIST))
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;     Program written by Robert Livingston - 2015-11-06
;
;     C:GPROF3DP extracts the vertex elevations and sets the RFL profile based on the current alignment
;
;
(defun C:GPROF3DP (/ ENT ENTLIST NODE P PLIST)
 (if (and (/= nil RFL:ALIGNLIST)
          (/= nil (setq PLIST (RFL:GETPLIST (car (entsel)))))
          (/= nil (caddar PLIST))
     )
  (progn
   (while (and (/= nil PLIST) (= nil (RFL:STAOFF (car PLIST))))
    (setq PLIST (cdr PLIST))
   )
   (setq PLIST (reverse PLIST))
   (while (and (/= nil PLIST) (= nil (RFL:STAOFF (car PLIST))))
    (setq PLIST (cdr PLIST))
   )
   (if (and (/= nil PLIST) (> (length PLIST) 1))
    (progn
     (if (< (car (RFL:STAOFF (last PLIST))) (car (RFL:STAOFF (car PLIST))))
      (setq PLIST (reverse PLIST))
     )
     (setq RFL:PVILIST nil)
     (foreach P PLIST
      (setq RFL:PVILIST (append RFL:PVILIST (list (list (car (RFL:STAOFF P)) (caddr P) "L" 0.0))))
     )
    )
   )
  )
 )
 nil
);
;
;   Program written by Robert Livingston, 98/05/13
;
;   C:GPROFOG extracts an OG vertical alignment from the current drawing
;
;
(defun C:GPROFOG (/ ANGBASE ANGDIR CMDECHO ENT ENTLIST ELEV LR NODE NODEPREV P TOL)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (setq TOL 0.0001)
 (setq NODEPREV nil)
 
 (RFL:PROFDEF)

 (setq RFL:OGLIST nil)
 (if (/= nil RFL:PROFDEFLIST)
  (progn
   (princ "\nSelect OG polyline:")
   (setq ENT (car (entsel)))
   (if (= ENT nil)
    (setq ENTLIST nil)
    (setq ENTLIST (entget ENT))
   )
   (if (= nil ENT)
    (princ "\n*** NO ENTITY SELECTED ***\n")
    (if (/= (cdr (assoc 0 ENTLIST)) "LWPOLYLINE")
     (princ "\n*** NOT A R14 POLYLINE ***\n")
     (progn
      (while (/= ENTLIST nil)
       (setq NODE (car ENTLIST))
       (setq ENTLIST (cdr ENTLIST))
       (if (= (car NODE) 10)
        (if (or (= NODEPREV nil) (> (distance (cdr NODEPREV) (cdr NODE)) TOL))
         (progn
          (setq STA (+ (* (- (nth 0 (cdr NODE))
                             (nth 0 (cdr (assoc "BPOINT" RFL:PROFDEFLIST))))
                          (if (or (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) 1) (= (assoc "DIRECTION" RFL:PROFDEFLIST) nil)) 1.0 -1.0)
                       )
                       (cdr (assoc "STA" RFL:PROFDEFLIST))
                    )
          )
          (setq ELEV (+ (/ (- (nth 1 (cdr NODE))
                              (nth 1 (cdr (assoc "BPOINT" RFL:PROFDEFLIST))))
                           (cdr (assoc "VEXAG" RFL:PROFDEFLIST)))
                        (cdr (assoc "ELEV" RFL:PROFDEFLIST))))
          (setq RFL:OGLIST (append (list (list STA ELEV)) RFL:OGLIST))
          (setq NODEPREV NODE)
         )
        )
       )
      )
      (if (> (nth 0 (car RFL:OGLIST)) (nth 0 (last RFL:OGLIST)))
       (setq RFL:OGLIST (reverse RFL:OGLIST))
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;     Program written by Robert Livingston, 2014-11-24
;
;     C:GPROFOGC3D extracts the existing ground profile of the currently defined alignment from a C3D surface
;
;
(defun C:GPROFOGC3D (/ *error* ALSAVE ANG ANGBASE ANGDIR ATOTAL C CMAX CMDECHO L LSTEP NODE NODE2 OBSURFACE OS OSTOL P1 P2 R TMP TMPLIST TOL XYOGLIST)
;(defun C:GPROFOGC3D ()
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq ALSAVE RFL:ALIGNLIST)
 
 (setq TOL 0.00000001)
 (setq OSTOL 0.1)
 
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setq RFL:ALIGNLIST ALSAVE)
  ;(setq *error* nil)
  (print msg)
 )

 (defun DIST (P1 P2 BULGE / ATOTAL CHORD R)
  (setq ATOTAL (* 4 (atan (abs BULGE))))
  (setq CHORD (distance P1 P2))
  (if (= 0.0 BULGE)
   (eval CHORD)
   (progn 
    (setq R (/ CHORD (* 2 (sin (/ ATOTAL 2)))))
    (* R ATOTAL)
   )
  )
 )
 
 (command ".UNDO" "M")

 (if (= nil RFL:ALIGNLIST)
  (princ "\n*** Alignment not defined ***")
  (progn
   (setq OBSURFACE (RFL:GETC3DSURFACE))
   (if (= nil OBSURFACE)
    (princ "\n*** Error getting C3D Surface ***")
    (progn
     (if (= (setq OS (getreal "\nOffset (<return> = 0.0) : ")) nil) (setq OS 0.0))
     (setq XYOGLIST nil)
     (setq RFL:OGLIST nil)
     (foreach NODE ALSAVE
      (progn
       (if (listp (last NODE))
        (progn ; SPIRAL
         (setq XYOGLIST nil)
         (setq R (RFL:GETSPIRALR2 (nth 0 (last NODE)) (nth 1 (last NODE)) (nth 2 (last NODE))))
         (setq L (RFL:GETSPIRALLS2 (nth 0 (last NODE)) (nth 1 (last NODE)) (nth 2 (last NODE))))
         (if (not (listp (last (last NODE))))
          (setq L (- L (last (last NODE))))
         )
         (setq ANG (atan (/ (sqrt (- (* 2.0 R OSTOL) (* OSTOL OSTOL))) (- R OSTOL))))
         (setq LSTEP (* 2.0 R ANG))
         (setq CMAX (+ 1 (fix (/ L LSTEP))))
         (setq LSTEP (/ L CMAX))
         (setq RFL:ALIGNLIST (list (list 0.0 (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))))
         ;(setq P1 (nth 1 NODE))
         (setq P1 (RFL:XY (list 0.0 OS)))
         (setq C 1)
         (while (< C CMAX)
          ;(setq P2 (RFL:XY (list (* C LSTEP) 0.0)))
          (setq P2 (RFL:XY (list (* C LSTEP) OS)))
          (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
           (if (= nil XYOGLIST)
            (setq XYOGLIST (append XYOGLIST TMPLIST))
            (setq XYOGLIST (append XYOGLIST (cdr TMPLIST)))
           )
          )
          (setq C (+ C 1))
          (setq P1 P2)
         )
         ;(setq P2 (nth 2 NODE))
         (setq P2 (RFL:XY (list L OS)))
         (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
          (if (= nil XYOGLIST)
           (setq XYOGLIST (append XYOGLIST TMPLIST))
           (setq XYOGLIST (append XYOGLIST (cdr TMPLIST)))
          )
         )
         (setq RFL:ALIGNLIST (list NODE))
         (foreach NODE2 XYOGLIST
          (progn
           (setq TMP (RFL:STAOFF (list (car NODE2) (cadr NODE2))))
           (if (/= nil TMP)
            (setq RFL:OGLIST (append RFL:OGLIST (list (list (car TMP) (last NODE2)))))
           )
          )
         )
        )
        (if (< (abs (last NODE)) TOL)
         (progn ; LINE
          (setq XYOGLIST nil)
          ;(setq P1 (nth 1 NODE))
          ;(setq P2 (nth 2 NODE))
          (setq RFL:ALIGNLIST (list (list 0.0 (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))))
          (setq L (distance (nth 1 NODE) (nth 2 NODE)))
          (setq P1 (RFL:XY (list 0.0 OS)))
          (setq P2 (RFL:XY (list L OS)))
          (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
           (if (= nil XYOGLIST)
            (setq XYOGLIST (append XYOGLIST TMPLIST))
            (setq XYOGLIST (append XYOGLIST (cdr TMPLIST)))
           )
          )
          (setq RFL:ALIGNLIST (list NODE))
          (foreach NODE2 XYOGLIST
           (progn
            (setq TMP (RFL:STAOFF (list (car NODE2) (cadr NODE2))))
            (if (/= nil TMP)
             (setq RFL:OGLIST (append RFL:OGLIST (list (list (car TMP) (last NODE2)))))
            )
           )
          )
         )
         (progn ; ARC
          (setq XYOGLIST nil)
          (setq R (RFL:RADIUS (nth 1 NODE) (nth 2 NODE) (nth 3 NODE)))
          (setq ATOTAL (* 4 (atan (abs (nth 3 NODE)))))
          (setq L (* R ATOTAL))
          (setq ANG (atan (/ (sqrt (- (* 2.0 R OSTOL) (* OSTOL OSTOL))) (- R OSTOL))))
          (setq LSTEP (* 2.0 R ANG))
          (setq CMAX (+ 1 (fix (/ L LSTEP))))
          (setq LSTEP (/ L CMAX))
          (setq RFL:ALIGNLIST (list (list 0.0 (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))))
          ;(setq P1 (nth 1 NODE))
          (setq P1 (RFL:XY (list 0.0 OS)))
          (setq C 1)
          (while (< C CMAX)
           ;(setq P2 (RFL:XY (list (* C LSTEP) 0.0)))
           (setq P2 (RFL:XY (list (* C LSTEP) OS)))
           (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
            (if (= nil XYOGLIST)
             (setq XYOGLIST (append XYOGLIST TMPLIST))
             (setq XYOGLIST (append XYOGLIST (cdr TMPLIST)))
            )
           )
           (setq C (+ C 1))
           (setq P1 P2)
          )
          ;(setq P2 (nth 2 NODE))
          (setq P2 (RFL:XY (list L OS)))
          (if (/= nil (setq TMPLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
           (if (= nil XYOGLIST)
            (setq XYOGLIST (append XYOGLIST TMPLIST))
            (setq XYOGLIST (append XYOGLIST (cdr TMPLIST)))
           )
          )
          (setq RFL:ALIGNLIST (list NODE))
          (foreach NODE2 XYOGLIST
           (progn
            (setq TMP (RFL:STAOFF (list (car NODE2) (cadr NODE2))))
            (if (/= nil TMP)
             (setq RFL:OGLIST (append RFL:OGLIST (list (list (car TMP) (last NODE2)))))
            )
           )
          )
         )
        )
       )
      )
     )
;     (if (/= nil XYOGLIST)
;      (progn
;       (setq RFL:ALIGNLIST ALSAVE)
;       (setq TMPLIST XYOGLIST)
;       (setq XYOGLIST nil)
;       (foreach NODE TMPLIST
;        (progn
;         (setq TMP (RFL:STAOFF (list (car NODE) (cadr NODE))))
;         (if (/= nil TMP)
;          (setq XYOGLIST (append XYOGLIST (list (list (car TMP) (last NODE)))))
;         )
;        )
;       )
;      )
;     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setq RFL:ALIGNLIST ALSAVE)
 (eval nil)
);
;
;   Program written by Robert Livingston, 98/05/13
;
;   C:GPROFP extracts an vertical alignment from a selected polyline
;
;
(defun C:GPROFP (/ ANGBASE ANGDIR CMDECHO ENT ENTLIST ELEV LR NODE NODEPREV P PLIST TOL)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (setq TOL 0.0001)
 (setq NODEPREV nil)
 
 (RFL:PROFDEF)

 (setq PLIST nil)
 (if (/= nil RFL:PROFDEFLIST)
  (progn
   (princ "\nSelect polyline:")
   (setq ENT (car (entsel)))
   (if (= ENT nil)
    (setq ENTLIST nil)
    (setq ENTLIST (entget ENT))
   )
   (if (= nil ENT)
    (princ "\n*** NO ENTITY SELECTED ***\n")
    (if (/= (cdr (assoc 0 ENTLIST)) "LWPOLYLINE")
     (princ "\n*** NOT A R14 POLYLINE ***\n")
     (progn
      (while (/= ENTLIST nil)
       (setq NODE (car ENTLIST))
       (setq ENTLIST (cdr ENTLIST))
       (if (= (car NODE) 10)
        (if (or (= NODEPREV nil) (> (distance (cdr NODEPREV) (cdr NODE)) TOL))
         (progn
          (setq STA (+ (* (- (nth 0 (cdr NODE))
                             (nth 0 (cdr (assoc "BPOINT" RFL:PROFDEFLIST))))
                          (if (or (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) 1) (= (assoc "DIRECTION" RFL:PROFDEFLIST) nil)) 1.0 -1.0)
                       )
                       (cdr (assoc "STA" RFL:PROFDEFLIST))
                    )
          )
          (setq ELEV (+ (/ (- (nth 1 (cdr NODE))
                              (nth 1 (cdr (assoc "BPOINT" RFL:PROFDEFLIST))))
                           (cdr (assoc "VEXAG" RFL:PROFDEFLIST)))
                        (cdr (assoc "ELEV" RFL:PROFDEFLIST))))
          (setq PLIST (append (list (list STA ELEV)) PLIST))
          (setq NODEPREV NODE)
         )
        )
       )
      )
      (if (> (nth 0 (car PLIST)) (nth 0 (last PLIST)))
       (setq PLIST (reverse PLIST))
      )
     )
    )
   )
  )
 )
 (if (/= nil PLIST)
  (progn
   (setq RFL:PVILIST nil)
   (foreach NODE PLIST
    (progn
     (setq RFL:PVILIST (append RFL:PVILIST (list (list (car NODE) (cadr NODE) "L" 0.0))))
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
);
;
;   Program written by Robert Livingston, 99/10/08
;
;   C:GSUPER extracts superelevation from the current drawing for the current alignment
;
;
(defun C:GSUPER (/ ENTSET)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (if (/= RFL:ALIGNLIST nil)
  (progn
   (if (/= RFL:SUPERDEF nil)
    (progn
     (princ "\nSelect SUPER blocks :")
     (setq ENTSET (ssget))
     (if (/= ENTSET nil)
      (progn
       (RFL:SUPERDEF ENTSET)
      )
     )
    )
    (progn
     (princ "\n!!!!! Superelevation tools not loaded !!!!!\n")
    )
   )
  )
  (progn
   (princ "\n!!!!! Horizontal Alignment Not Set !!!!!\n")
  )
 )
 (setvar "CMDECHO" CMDECHO)
 nil
)
;
;
;     Program written by Robert Livingston 2017-05-22
;
;     C:HOR2TABLE is a wrapper for alignment table creation
;
;          RFL:HOR2TABLE  - Alberta Infrastructure
;          RFL:HOR2TABLE2 - BC Ministry
;
;
(defun C:HOR2TABLE (/ *error* CMDECHO REP)
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (print msg)
  ;(setq *error* nil)
 )
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 
 (initget "Ai Bc")
 (setq REP (getkword "\nAlberta Infrastructure / BC Ministry (AI/<BC>) : "))
 (if (= nil REP) (setq REP "BC"))
 (setq REP (strcase REP))
 (cond ((= REP "AI")
        (RFL:HOR2TABLE)
       )
       ((= REP "BC")
        (RFL:HOR2TABLE2)
       )
 )
 
 (setvar "CMDECHO" CMDECHO)
 T
);
;
;     Program written by Robert Livingston, 03-02-18
;
;     C:INCALIGN incruments the RFL alignment and profile by an entered amount
;
;
(defun C:INCALIGN (/ *error* ALSAVE CMDECHO INC NODE PVISAVE SUPERSAVE)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (princ msg)
  ;(setq *error* nil)
 )

 (setq INC (getreal "\nEnter incrament to add to horizontal and vertical alignments : "))

 (setq ALSAVE RFL:ALIGNLIST)
 (setq RFL:ALIGNLIST nil)

 (setq NODE (car ALSAVE))
 (setq ALSAVE (cdr ALSAVE))

 (while (/= NODE nil)
  (setq NODE (append (list (+ INC (car NODE))) (cdr NODE)))
  (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list NODE)))
  (setq NODE (car ALSAVE))
  (setq ALSAVE (cdr ALSAVE))
 )

 (setq PVISAVE RFL:PVILIST)
 (setq RFL:PVILIST nil)

 (setq NODE (car PVISAVE))
 (setq PVISAVE (cdr PVISAVE))

 (while (/= NODE nil)
  (setq NODE (append (list (+ INC (car NODE))) (cdr NODE)))
  (setq RFL:PVILIST (append RFL:PVILIST (list NODE)))
  (setq NODE (car PVISAVE))
  (setq PVISAVE (cdr PVISAVE))
 )

 (setq SUPERSAVE RFL:SUPERLIST)
 (setq RFL:SUPERLIST nil)

 (setq NODE (car SUPERSAVE))
 (setq SUPERSAVE (cdr SUPERSAVE))

 (while (/= NODE nil)
  (setq NODE (append (list (+ INC (car NODE))) (cdr NODE)))
  (setq RFL:SUPERLIST (append RFL:SUPERLIST (list NODE)))
  (setq NODE (car SUPERSAVE))
  (setq SUPERSAVE (cdr SUPERSAVE))
 )

 (setvar "CMDECHO" CMDECHO)
 T
);
;
;     Program written by Robert Livingston, 2016/07/07
;
;     C:LALIGN is a utility for labelling alignments
;
;
;     NODEMODE = 0  :  LEFT
;     NODEMODE = 1  :  RIGHT
;     NODEMODE = 2  :  INSIDE
;     NODEMODE = 3  :  OUTSIDE
;
;     xxxLAYER  :  '*' concatinates current layer
;
(setq RFL:LALIGNLIST (list (cons "LABELBLOCK" "STALBL")
                           (cons "LABEL" 1)
                           (cons "LABELLAYER" "*-LBL")
                           (cons "LABELINC" 100.0)
                           (cons "LABELSCALE" 1.0)
                           (cons "LABELOFFSET" 4.0)
                           (cons "LABELROTATE" 0.0)
                           (cons "TICKBLOCK" "STATICK")
                           (cons "TICK" 1)
                           (cons "TICKLAYER" "*-LBL")
                           (cons "TICKINC" 20.0)
                           (cons "TICKSCALE" 1.0)
                           (cons "TICKOFFSET" 0.0)
                           (cons "TICKROTATE" 0.0)
                           (cons "NODELEFTBLOCK" "STANODELEFT")
                           (cons "NODERIGHTBLOCK" "STANODERIGHT")
                           (cons "NODE" 1)
                           (cons "NODELAYER" "*-LBL")
                           (cons "NODEMODE" 3)
                           (cons "NODESCALE" 1.0)
                           (cons "NODEOFFSET" 0.0)
                           (cons "NODEROTATE" 0.0)
                     )
)
(defun C:LALIGN (/ ACTIVEDOC ACTIVESPC ENT ENTLIST LLABEL LTICK LNODE P P1 PREVENT)
 (command "._UNDO" "M")
 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )
 (defun LLABEL (/ ANGBASE ANGDIR CLAYER INC NLAYER P STA STAH STAL STAMAX)
  (setq ANGBASE (getvar "ANGBASE"))
  (setvar "ANGBASE" 0.0)
  (setq ANGDIR (getvar "ANGDIR"))
  (setvar "ANGDIR" 0)
  (setq CLAYER (getvar "CLAYER"))
  (setq NLAYER (cdr (assoc "LABELLAYER" RFL:LALIGNLIST)))
  (if (= "*" (substr NLAYER 1 1)) (setq NLAYER (strcat CLAYER (substr NLAYER 2))))
  (if (not (tblsearch "LAYER" NLAYER))
   (entmake (list (cons 0 "LAYER")
                  (cons 100 "AcDbSymbolTableRecord")
                  (cons 100 "AcDbLayerTableRecord")
                  (cons 2 NLAYER)
                  (cons 70 0)
            )
   )
  )
  (setvar "CLAYER" NLAYER)
  (if (not (tblsearch "BLOCK" (cdr (assoc "LABELBLOCK" RFL:LALIGNLIST))))
   (RFL:MAKEENT (cdr (assoc "LABELBLOCK" RFL:LALIGNLIST)))
  )
  (if (tblsearch "BLOCK" (cdr (assoc "LABELBLOCK" RFL:LALIGNLIST)))
   (progn
    (setq STA (float (* (fix (/ (caar RFL:ALIGNLIST)
                                (cdr (assoc "LABELINC" RFL:LALIGNLIST))
                             )
                        )
                        (cdr (assoc "LABELINC" RFL:LALIGNLIST))
                     )
              )
    )
    (setq STAEND (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
    (setq INC (cdr (assoc "LABELINC" RFL:LALIGNLIST)))
    (while (<= STA STAEND)
     (if (setq P (RFL:XY (list STA (cdr (assoc "LABELOFFSET" RFL:LALIGNLIST)))))
      (progn
       (setq P1 (RFL:XY (list STA (- (cdr (assoc "LABELOFFSET" RFL:LALIGNLIST)) 1))))
       (vla-insertblock ACTIVESPC
                        (vlax-3D-point P)
                        (cdr (assoc "LABELBLOCK" RFL:LALIGNLIST))
                        (cdr (assoc "LABELSCALE" RFL:LALIGNLIST))
                        (cdr (assoc "LABELSCALE" RFL:LALIGNLIST))
                        (cdr (assoc "LABELSCALE" RFL:LALIGNLIST))
                        (+ (/ pi 2.0) (angle P1 P) (* (/ pi 180.0) (cdr (assoc "LABELROTATE" RFL:LALIGNLIST))))
       )
       (setq ENT (entlast))
       (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
       (if (= 1 (cdr (assoc 66 (setq ENTLIST (entget ENT)))))
        (progn
         (setq STAH (RFL:STATXT STA))
         (setq STAL (substr STAH (+ 2 (vl-string-search "+" STAH))))
         (setq STAH (substr STAH 1 (vl-string-search "+" STAH)))
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
         (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
          (cond ((= "STAH" (cdr (assoc 2 ENTLIST)))
                 (entmod (subst (cons 1 STAH) (assoc 1 ENTLIST) ENTLIST))
                )
                ((= "STAL" (cdr (assoc 2 ENTLIST)))
                 (entmod (subst (cons 1 STAL) (assoc 1 ENTLIST) ENTLIST))
                )
           )
          (setq ENT (entnext ENT))
          (setq ENTLIST (entget ENT))
         )
        )
       )
      )
     )
     (setq STA (+ STA INC))
    )
   )
   (princ "\n!!! Unable to locate or create Lable Block !!!")
  )
  (setvar "CLAYER" CLAYER)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  1
 )
 (defun LTICK (/ ANGBASE ANGDIR CLAYER INC NLAYER P STA STAMAX)
  (setq ANGBASE (getvar "ANGBASE"))
  (setvar "ANGBASE" 0.0)
  (setq ANGDIR (getvar "ANGDIR"))
  (setvar "ANGDIR" 0)
  (setq CLAYER (getvar "CLAYER"))
  (setq NLAYER (cdr (assoc "TICKLAYER" RFL:LALIGNLIST)))
  (if (= "*" (substr NLAYER 1 1)) (setq NLAYER (strcat CLAYER (substr NLAYER 2))))
  (if (not (tblsearch "LAYER" NLAYER))
   (entmake (list (cons 0 "LAYER")
                  (cons 100 "AcDbSymbolTableRecord")
                  (cons 100 "AcDbLayerTableRecord")
                  (cons 2 NLAYER)
                  (cons 70 0)
            )
   )
  )
  (setvar "CLAYER" NLAYER)
  (if (not (tblsearch "BLOCK" (cdr (assoc "TICKBLOCK" RFL:LALIGNLIST))))
   (RFL:MAKEENT (cdr (assoc "TICKBLOCK" RFL:LALIGNLIST)))
  )
  (if (tblsearch "BLOCK" (cdr (assoc "LABELBLOCK" RFL:LALIGNLIST)))
   (progn
    (setq STA (float (* (fix (/ (caar RFL:ALIGNLIST)
                                (cdr (assoc "TICKINC" RFL:LALIGNLIST))
                             )
                        )
                        (cdr (assoc "TICKINC" RFL:LALIGNLIST))
                     )
              )
    )
    (setq STAEND (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
    (setq INC (cdr (assoc "TICKINC" RFL:LALIGNLIST)))
    (while (<= STA STAEND)
     (if (setq P (RFL:XY (list STA (cdr (assoc "TICKOFFSET" RFL:LALIGNLIST)))))
      (progn
       (setq P1 (RFL:XY (list STA (- (cdr (assoc "TICKOFFSET" RFL:LALIGNLIST)) 1))))
       (vla-insertblock ACTIVESPC
                        (vlax-3D-point P)
                        (cdr (assoc "TICKBLOCK" RFL:LALIGNLIST))
                        (cdr (assoc "TICKSCALE" RFL:LALIGNLIST))
                        (cdr (assoc "TICKSCALE" RFL:LALIGNLIST))
                        (cdr (assoc "TICKSCALE" RFL:LALIGNLIST))
                        (+ (/ pi 2.0) (angle P1 P) (* (/ pi 180.0) (cdr (assoc "TICKROTATE" RFL:LALIGNLIST))))
       )
       (setq ENT (entlast))
       (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      )
     )
     (setq STA (+ STA INC))
    )
   )
   (princ "\n!!! Unable to locate or create Tick Block !!!")
  )
  (setvar "CLAYER" CLAYER)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  1
 )
 (defun LNODE (/ ANGBASE ANGDIR CLAYER NODEDIR NODELABEL NODETYPE NLAYER NODE NODEBLOCK NODEPREV P STA STAH STAMAX)
  (defun NODETYPE (NODE / TOL)
   ; 0 = Tangent
   ; 1 = Arc
   ; 2 = Spiral
   (setq TOL 0.00000001)
   (if NODE
    (if (listp (last NODE))
     2
     (if (< (abs (last NODE)) TOL)
      0
      1
     )
    )
    nil
   )
  )
  (defun NODEDIR (NODE / DIR TOL)
   ; 0 = Tangent
   ; -1 = Right
   ; 1 = Left
   (setq TOL 0.00000001)
   (if NODE
    (if (listp (last NODE))
     (progn
      (setq DIR (RFL:SIGN (sin (- (angle (nth 1 (last NODE))  (nth 2 (last NODE)))
                                  (angle (nth 0 (last NODE))  (nth 1 (last NODE)))
                               )
                          )
                )
      )
      (if (> (distance (nth 2 NODE) (nth 2 (last NODE))) TOL)
       (setq DIR (* -1 DIR))
      )
      (fix DIR)
     )
     (if (< (abs (last NODE)) TOL)
      0
      (if (< (last NODE) 0.0)
       -1
       1
      )
     )
    )
    nil
   )
  )
  (defun NODELABEL (NODE NODEPREV)
   (cond ((and (= (NODETYPE NODE) 0)
               (= (NODETYPE NODEPREV) nil)
          )
          "POT "
         )
         ((and (= (NODETYPE NODE) 0)
               (= (NODETYPE NODEPREV) 0)
          )
          "PI "
         )
         ((and (= (NODETYPE NODE) 0)
               (= (NODETYPE NODEPREV) 1)
          )
          "EC "
         )
         ((and (= (NODETYPE NODE) 0)
               (= (NODETYPE NODEPREV) 2)
          )
          "ST "
         )
         ((and (= (NODETYPE NODE) 1)
               (= (NODETYPE NODEPREV) nil)
          )
          "POC "
         )
         ((and (= (NODETYPE NODE) 1)
               (= (NODETYPE NODEPREV) 0)
          )
          "BC "
         )
         ((and (= (NODETYPE NODE) 1)
               (= (NODETYPE NODEPREV) 1)
          )
          (if (= (NODEDIR NODE) (NODEDIR NODEPREV))
           "PCC "
           "EC/BC "
          )
         )
         ((and (= (NODETYPE NODE) 1)
               (= (NODETYPE NODEPREV) 2)
          )
          "SC "
         )
         ((and (= (NODETYPE NODE) 2)
               (= (NODETYPE NODEPREV) nil)
          )
          "POS "
         )
         ((and (= (NODETYPE NODE) 2)
               (= (NODETYPE NODEPREV) 0)
          )
          "TS "
         )
         ((and (= (NODETYPE NODE) 2)
               (= (NODETYPE NODEPREV) 1)
          )
          "CS "
         )
         ((and (= (NODETYPE NODE) 2)
               (= (NODETYPE NODEPREV) 2)
          )
          "S/S "
         )
         (T
          ""
         )
   )
  )
  (defun NODEINSERT (STA NODESTR)
   (cond ((= (cdr (assoc "NODEMODE" RFL:LALIGNLIST)) 0)
          (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
         )
         ((= (cdr (assoc "NODEMODE" RFL:LALIGNLIST)) 1)
          (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
         )
         ((= (cdr (assoc "NODEMODE" RFL:LALIGNLIST)) 2)
          (cond ((= (NODEDIR NODE) nil)
                 (cond ((= (NODEDIR NODEPREV) nil)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) -1)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 0)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 1)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       (T
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                 )
                )
                ((= (NODEDIR NODE) -1)
                 (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                )
                ((= (NODEDIR NODE) 0)
                 (cond ((= (NODEDIR NODEPREV) nil)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) -1)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 0)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 1)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       (T
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                 )
                )
                ((= (NODEDIR NODE) 1)
                 (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                )
                (T
                 (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                )
          )
         )
         ((= (cdr (assoc "NODEMODE" RFL:LALIGNLIST)) 3)
          (cond ((= (NODEDIR NODE) nil)
                 (cond ((= (NODEDIR NODEPREV) nil)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) -1)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 0)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 1)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       (T
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                 )
                )
                ((= (NODEDIR NODE) -1)
                 (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                )
                ((= (NODEDIR NODE) 0)
                 (cond ((= (NODEDIR NODEPREV) nil)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) -1)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 0)
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                       ((= (NODEDIR NODEPREV) 1)
                        (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                       )
                       (T
                        (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                       )
                 )
                )
                ((= (NODEDIR NODE) 1)
                 (setq NODEBLOCK (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
                )
                (T
                 (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
                )
          )
         )
         (T
          (setq NODEBLOCK (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
         )
   )
   (if (setq P (RFL:XY (list STA (cdr (assoc "NODEOFFSET" RFL:LALIGNLIST)))))
    (progn
     (setq P1 (RFL:XY (list STA (- (cdr (assoc "NODEOFFSET" RFL:LALIGNLIST)) 1))))
     (vla-insertblock ACTIVESPC
                      (vlax-3D-point P)
                      NODEBLOCK
                      (cdr (assoc "NODESCALE" RFL:LALIGNLIST))
                      (cdr (assoc "NODESCALE" RFL:LALIGNLIST))
                      (cdr (assoc "NODESCALE" RFL:LALIGNLIST))
                      (+ (/ pi 2.0) (angle P1 P) (* (/ pi 180.0) (cdr (assoc "NODEROTATE" RFL:LALIGNLIST))))
     )
     (setq ENT (entlast))
     (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
     (if (= 1 (cdr (assoc 66 (setq ENTLIST (entget ENT)))))
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
        (cond ((= "NODE" (cdr (assoc 2 ENTLIST)))
               (entmod (subst (cons 1 NODESTR) (assoc 1 ENTLIST) ENTLIST))
              )
         )
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
       )
      )
     )
    )
   )
  )
  (setq ANGBASE (getvar "ANGBASE"))
  (setvar "ANGBASE" 0.0)
  (setq ANGDIR (getvar "ANGDIR"))
  (setvar "ANGDIR" 0)
  (setq CLAYER (getvar "CLAYER"))
  (setq NLAYER (cdr (assoc "NODELAYER" RFL:LALIGNLIST)))
  (if (= "*" (substr NLAYER 1 1)) (setq NLAYER (strcat CLAYER (substr NLAYER 2))))
  (if (not (tblsearch "LAYER" NLAYER))
   (entmake (list (cons 0 "LAYER")
                  (cons 100 "AcDbSymbolTableRecord")
                  (cons 100 "AcDbLayerTableRecord")
                  (cons 2 NLAYER)
                  (cons 70 0)
            )
   )
  )
  (setvar "CLAYER" NLAYER)
  (if (not (tblsearch "BLOCK" (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST))))
   (RFL:MAKEENT (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
  )
  (if (not (tblsearch "BLOCK" (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST))))
   (RFL:MAKEENT (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
  )
  (if (and (tblsearch "BLOCK" (cdr (assoc "NODELEFTBLOCK" RFL:LALIGNLIST)))
           (tblsearch "BLOCK" (cdr (assoc "NODERIGHTBLOCK" RFL:LALIGNLIST)))
      )
   (progn
    (setq NODEPREV nil)
    (foreach NODE RFL:ALIGNLIST
     (setq STA (car NODE))
     (setq STAH (RFL:STATXT STA))
     (setq STAH (strcat (NODELABEL NODE NODEPREV) STAH))
     (NODEINSERT STA STAH)
     (setq NODEPREV NODE)
    )
    (setq STA (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
    (setq STAH (RFL:STATXT STA))
    (setq STAH (strcat (NODELABEL (last RFL:ALIGNLIST) nil) STAH))
    (NODEINSERT STA STAH)
   )
   (princ "\n!!! Unable to locate or create Lable Block !!!")
  )
  (setvar "CLAYER" CLAYER)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  1
 )
 (if RFL:ALIGNLIST
  (progn
   (setq PREVENT nil)
   (if (= 1 (cdr (assoc "LABEL" RFL:LALIGNLIST))) (LLABEL))
   (if (= 1 (cdr (assoc "TICK" RFL:LALIGNLIST))) (LTICK))
   (if (= 1 (cdr (assoc "NODE" RFL:LALIGNLIST))) (LNODE))
   T
  )
  (progn
   (princ "\n!!! No alignment defined !!!")
   nil
  )
 )
)
;
;
;     Program written by Robert Livingston, 01/02/14
;
;     LARC is a small utility for labelling arc and spiral entities
;
;
(setq RFL:LARCSCALE 0.1 RFL:LARCLAYER "")
(setq RFL:LARCCIRCLES "Yes")
(setq RFL:LARCSPIRALS "B")
(setq RFL:LARCTHEIGHT 0.75)
(defun C:LARCSETUP (/ CMDECHO TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq TMP (getreal (strcat "\nEnter scale for blocks <" (rtos RFL:LARCSCALE) "> : " )))
 (if (/= nil TMP) (setq RFL:LARCSCALE TMP))
 (setq RFL:LARCLAYER (getstring "\nEnter layer of new entities (<return> for current layer) : "))
 (initget "Yes No")
 (setq RFL:LARCCIRCLES (getkword "\nDraw circles at entity ends (<Yes>/No) : "))
 (initget "Yes No")
 (if (= RFL:LARCCIRCLES nil) (setq RFL:LARCCIRCLES "Yes"))
 (setq LARCEQUALS (getkword "\nInclude equals '=' (Yes/<No>) : "))
 (if (= LARCEQUALS nil) (setq LARCEQUALS "No"))
 (initget "A L B")
 (setq RFL:LARCSPIRALS (getkword "\nLabel spiral A, Ls or Both (A/L/<B>) : "))
 (if (= RFL:LARCSPIRALS nil) (setq RFL:LARCSPIRALS "B"))
 (setq RFL:LARCTHEIGHT (getdist "\nLabel text height <0.75> :"))
 (if (or (= RFL:LARCTHEIGHT nil) (= RFL:LARCTHEIGHT 0.0)) (setq RFL:LARCTHEIGHT 0.75))

 (setvar "CMDECHO" CMDECHO)
)
(defun C:LARC (/ *error* A ACTIVEDOC ACTIVESPC ANG ANG1 ANG2 ANGBASE ANGDIR CHECKDUPLICATE CLAYER CMDECHO DIMZIN ENT ENTLIST LO LS OS OSMODE P P1 P2 PC R RL SPIRALDATA TEXTOBJ TEXTSTRING VT)
 (setq CLAYER (getvar "CLAYER"))
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 8)

 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )

 (command "._UNDO" "M")
 
 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CLAYER" CLAYER)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "DIMZIN" DIMZIN)
  ;(setq *error* nil)
  (princ msg)
 )

 (defun CHECKDUPLICATE (/ ENT ENTLIST ENTSET)
  (setq ENT (entlast))
  (setq ENTLIST (entget ENT))
  (if (and (= "INSERT" (cdr (assoc 0 ENTLIST))) (= "CIRC" (cdr (assoc 2 ENTLIST))))
   (progn
    (setq ENTSET (ssget "X" (list (cons 0 "INSERT")
                                  (cons 2 "CIRC")
                                  (assoc 8 ENTLIST)
                                  (assoc 10 ENTLIST)
                                  (assoc 41 ENTLIST)
                                  (assoc 42 ENTLIST)
                                  (assoc 43 ENTLIST)
                                  (assoc 50 ENTLIST)
                            )
                 )
    )
    (if (> (sslength ENTSET) 1) (command "._ERASE" ENT ""))
   )
  )
 )
 (command "._UNDO" "M")

 (command "._UCS" "W")

 (if (/= "" RFL:LARCLAYER)
  (progn
   (if (= nil (tblsearch "LAYER" RFL:LARCLAYER))
    (command "._LAYER" "M" RFL:LARCLAYER)
    (setvar "CLAYER" RFL:LARCLAYER)
   )
  )
 )

 (setq VT (getvar "VIEWTWIST"))
 (if (> VT pi) (setq VT (- VT (* 2.0 pi))))
 (if (and (= RFL:LARCCIRCLES "Yes") (not (tblsearch "BLOCK" "CIRC"))) (RFL:MAKEENT "CIRC"))
 (if (/= nil (setq ENT (car (entsel "Select arc or LDD spiral : "))))
  (progn
   (setq ENTLIST (entget ENT))
   (if (/= "ARC" (cdr (assoc 0 ENTLIST)))
    (if (= (setq SPIRALDATA (RFL:GETSPIRALDATA ENT)) nil)
     (if (/= "LINE" (cdr (assoc 0 ENTLIST)))
      (princ "\n***** NOT AN ARC OR LDD SPIRAL *****")
      (progn
       (setq P1 (cdr (assoc 10 ENTLIST)))
       (setq P2 (cdr (assoc 11 ENTLIST)))
       (if (= RFL:LARCCIRCLES "Yes")
        (progn
         (vla-insertblock ACTIVESPC
                          (vlax-3D-point P1)
                          "CIRC"
                          RFL:LARCSCALE
                          RFL:LARCSCALE
                          RFL:LARCSCALE
                          0.0
         )
         (CHECKDUPLICATE)
         (vla-insertblock ACTIVESPC
                          (vlax-3D-point P2)
                          "CIRC"
                          RFL:LARCSCALE
                          RFL:LARCSCALE
                          RFL:LARCSCALE
                          0.0
         )
         (CHECKDUPLICATE)
        )
       )

       (setq P (list (/ (+ (nth 0 P1) (nth 0 P2)) 2.0) (/ (+ (nth 1 P1) (nth 1 P2)) 2.0)))
       (if (and (> (angle P P2) (- (* pi 0.5) VT)) (< (angle P P2) (- (* pi 1.5) VT)))
        (setq ANG (- (angle P P2) pi))
        (setq ANG (angle P P2))
       )
       (setq TEXTSTRING "TAN")
       (if (setq TEXTOBJ (vla-addtext ACTIVESPC
                                      TEXTSTRING
                                      (vlax-3D-point P)
                                      RFL:LARCTHEIGHT
                         )
           )
        (progn
         (vla-put-Alignment textObj acAlignmentMiddle)
         (vla-put-Rotation textObj ANG)
         (vla-put-TextAlignmentPoint textObj (vlax-3D-point P))
        )
       )
      )
     )
     (progn
      (setq LS (RFL:GETSPIRALLS ENT))
      (setq A (RFL:GETSPIRALA ENT))

      (if (listp (last SPIRALDATA))
       (setq LO 0.0)
       (setq LO (last SPIRALDATA))
      )
      (setq LS (- LS LO))

      (setq OS (RFL:SPIRALOFFSET ENT))
      (if (< (abs OS) RFL:TOL) (setq OS 0.0))

      (if (/= 0.0 OS)
       (progn
        (setq R (RFL:GETSPIRALR ENT))
        (if (= LO 0.0)
         (setq RL 0.0)
         (setq RL (/ (* A A) LO))
        )
        (setq LS (+ LS (* OS (* A A 0.5 (- (/ 1.0 (* R R))
                                         (if (= LO 0.0) 0.0 (/ 1.0 (* RL RL)))
                                      )
                             )
                       )
                 )
        )
       )
      )

      (if (= "LWPOLYLINE" (cdr (assoc 0 ENTLIST)))
       (progn
        (setq P1 (cdr (assoc 10 ENTLIST)))
        (setq P1 (list (nth 0 P1) (nth 1 P1) 0.0))
        (setq P2 (cdr (assoc 10 (reverse ENTLIST))))
        (setq P2 (list (nth 0 P2) (nth 1 P2) 0.0))
       )
       (progn
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
        (setq P1 (cdr (assoc 10 ENTLIST)))
        (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
         (setq P2 (cdr (assoc 10 ENTLIST)))
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
        )
       )
      )
      (if (= RFL:LARCCIRCLES "Yes")
       (progn
        (vla-insertblock ACTIVESPC
                         (vlax-3D-point P1)
                         "CIRC"
                         RFL:LARCSCALE
                         RFL:LARCSCALE
                         RFL:LARCSCALE
                         0.0
        )
        (CHECKDUPLICATE)
        (vla-insertblock ACTIVESPC
                         (vlax-3D-point P2)
                         "CIRC"
                         RFL:LARCSCALE
                         RFL:LARCSCALE
                         RFL:LARCSCALE
                         0.0
        )
        (CHECKDUPLICATE)
       )
      )

      (setq P (list (/ (+ (nth 0 P1) (nth 0 P2)) 2.0) (/ (+ (nth 1 P1) (nth 1 P2)) 2.0)))
      (if (and (> (angle P P2) (- (* pi 0.5) VT)) (< (angle P P2) (- (* pi 1.5) VT)))
       (setq ANG (- (angle P P2) pi))
       (setq ANG (angle P P2))
      )
      (if (or (= RFL:LARCSPIRALS "L") (= RFL:LARCSPIRALS "B"))
       (progn
        (setq TEXTSTRING (strcat (if (> (abs OS) 0.0) "os-" "") (if (> LO 0.0) "c" "") (if (= LARCEQUALS "Yes") "Ls=" "Ls") (rtos LS 2 1)))
        (if (= RFL:LARCSPIRALS "B")
         (progn
          (setq TEXTSTRING (strcat TEXTSTRING " / " (if (= LARCEQUALS "Yes") "A=" "A") (rtos A 2 1)))
         )
        )
       )
       (progn
        (if (= RFL:LARCSPIRALS "A")
         (progn
          (setq TEXTSTRING (strcat (if (= LARCEQUALS "Yes") "A=" "A") (rtos A 2 1)))
         )
        )
       )
      )
      (if (setq TEXTOBJ (vla-addtext ACTIVESPC
                                     TEXTSTRING
                                     (vlax-3D-point P)
                                     RFL:LARCTHEIGHT
                        )
          )
       (progn
        (vla-put-Alignment textObj acAlignmentMiddle)
        (vla-put-Rotation textObj ANG)
        (vla-put-TextAlignmentPoint textObj (vlax-3D-point P))
       )
      )
     )
    )
    (progn
     (setq PC (cdr (assoc 10 ENTLIST)))
     (setq R (cdr (assoc 40 ENTLIST)))
     (setq ANG1 (cdr (assoc 50 ENTLIST)))
     (setq ANG2 (cdr (assoc 51 ENTLIST)))
     (setq P1 (list (+ (nth 0 PC) (* R (cos ANG1)))
                    (+ (nth 1 PC) (* R (sin ANG1)))
              )
     )
     (setq P2 (list (+ (nth 0 PC) (* R (cos ANG2)))
                    (+ (nth 1 PC) (* R (sin ANG2)))
              )
     )
     (if (= RFL:LARCCIRCLES "Yes")
      (progn
       (vla-insertblock ACTIVESPC
                        (vlax-3D-point P1)
                        "CIRC"
                        RFL:LARCSCALE
                        RFL:LARCSCALE
                        RFL:LARCSCALE
                        0.0
       )
       (CHECKDUPLICATE)
       (vla-insertblock ACTIVESPC
                        (vlax-3D-point P2)
                        "CIRC"
                        RFL:LARCSCALE
                        RFL:LARCSCALE
                        RFL:LARCSCALE
                        0.0
       )
       (CHECKDUPLICATE)
      )
     )

     (setq P (list (/ (+ (nth 0 P1) (nth 0 P2)) 2.0) (/ (+ (nth 1 P1) (nth 1 P2)) 2.0)))
     (if (and (> (angle P P2) (- (* pi 0.5) VT)) (< (angle P P2) (- (* pi 1.5) VT)))
      (setq ANG (- (angle P P2) pi))
      (setq ANG (angle P P2))
     )
     (setq TEXTSTRING (strcat (if (= LARCEQUALS "Yes") "R=" "R") (rtos R 2 1)))
     (if (setq TEXTOBJ (vla-addtext ACTIVESPC
                                    TEXTSTRING
                                    (vlax-3D-point P)
                                    RFL:LARCTHEIGHT
                       )
         )
      (progn
       (vla-put-Alignment textObj acAlignmentMiddle)
       (vla-put-Rotation textObj ANG)
       (vla-put-TextAlignmentPoint textObj (vlax-3D-point P))
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CLAYER" CLAYER)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "DIMZIN" DIMZIN)
)
(princ "\n*****  Use LARCSETUP to change defaults *****\n");
;
;     Program written by Robert Livingston, 2016/07/11
;
;     C:LPROF is a utility for labelling profiles
;
;     xxxLAYER  :  '*' concatinates current layer
;
(setq RFL:LPROFLIST (list (cons "PROFDRAW" 0)           ;  Draw profile
                          (cons "PROFLAYER" "*")        ;  Profile Layer
                          (cons "TEXTLAYER" "*-LBL")    ;  Text Layer
                          (cons "TEXTHEIGHT" 3.5)       ;  Text Height
                          (cons "UNITS" "m")            ;  Linear Units
                          (cons "LSLOPE" 1)             ;  Label Slope
                          (cons "LL" 1)                 ;  Label 'L'
                          (cons "LK" 1)                 ;  Label 'K'
                          (cons "CNODES" 1)             ;  Circle Nodes
                          (cons "CNODERAD" 1.0)         ;  Node Circle Radius
                          (cons "CNODELENGTH" 10.0)     ;  Node Line Length
                          (cons "CNODEVOFFSET" 1.0)     ;  Node Text Vertical Offset
                          (cons "CNODEHOFFSET" 0.875)   ;  Node Text Horisontal Offset
                          (cons "DPVI" 1)               ;  Draw PVI
                          (cons "LPVI" 1)               ;  Label PVI
                          (cons "LBVC" 1)               ;  Label BVC and EVC
                          (cons "LHIGH" 0)              ;  Label 'high' Chainage (if not stations are labelled as '+234.567'
                          (cons "LELEVATIONSC" 1)       ;  Label Elevations Curves
                          (cons "LELEVATIONST" 1)       ;  Label Elevations Tangents
                          (cons "ELEVTEXTHEIGHT" 2.5)   ;  Elevation Text Height
                          (cons "ELEVTEXTINC" 20.0)     ;  Elevation Text Increment
                          (cons "ELEVTEXTOS" -20.0)     ;  Elevation Text Offset (from grid basepoint)
                          (cons "RAB" 0)                ;  Reverse Above/Below flag (1 = labels above with K/L below)
                          (cons "DIRECTION" "DIRRIGHT") ;  Label Direction (DIRRIGHT / DIRLEFT / DIRUP / DIRDOWN)
                          (cons "KPREC" 1)              ;  'K' Precision
                          (cons "LPREC" 0)              ;  'L' Precision
                          (cons "SLOPEPREC" 3)          ;  Slope Precision
                          (cons "STAPREC" 3)            ;  Station Precision
                          (cons "ELEVPREC" 3)           ;  Elevation Precision
                    )
)
(defun C:LPROF (/ ACTIVEDOC ACTIVESPC ADDTEXT ANG ANGBASE ANGDIR C CLAYER CMDECHO DIMZIN DIRECTIONT DIRECTIONS ENT
                  G1 G2 K L1 L2 L3 LUPREC MLMR MLMRT MLMRB NLAYER OSMODE P P1 P2 PLINETYPE PREVENT
                  REGENMODE REP SIDE STA STA1 STA2 STA3 STAH STAL STAHTXT SPLINETYPE
                  SPLINESEGS TEXTSTYLE TOL Z1 Z2 Z3 ZMAX ZMIN)
 (setq REGENMODE (getvar "REGENMODE"))
 (setvar "REGENMODE" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setq LUPREC (getvar "LUPREC"))
 (setvar "DIMZIN" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq SPLINETYPE (getvar "SPLINETYPE"))
 (setvar "SPLINETYPE" 5)
 (setq SPLINESEGS (getvar "SPLINESEGS"))
 (setvar "SPLINESEGS" 65)
 (setq PLINETYPE (getvar "PLINETYPE"))
 (setvar "PLINETYPE" 0)
 (setq TEXTSTYLE (getvar "TEXTSTYLE"))

 (setq TOL 0.000001)
 
 (setq PREVENT nil)
 
 (command "._UNDO" "M")

 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )

 (defun ADDTEXT (STR P H AL A / ANGBASE ANGDIR OBJ P1)
  (setq ANGBASE (getvar "ANGBASE"))
  (setvar "ANGBASE" 0.0)
  (setq ANGDIR (getvar "ANGDIR"))
  (setvar "ANGDIR" 0)
  ; acAlignmentLeft          :   0
  ; acAlignmentCenter        :   1
  ; acAlignmentRight         :   2
  ; acAlignmentMiddle        :   4
  ; acAlignmentTopLeft       :   6
  ; acAlignmentTopCenter     :   7
  ; acAlignmentTopRight      :   8
  ; acAlignmentMiddleLeft    :   9
  ; acAlignmentMiddleCenter  :  10
  ; acAlignmentMiddleRight   :  11
  ; acAlignmentBottomLeft    :  12
  ; acAlignmentBottomCenter  :  13
  ; acAlignmentBottomRight   :  14
  (vla-addtext ACTIVESPC
               STR
               (vlax-3d-point P)
               H
  )
  (setq ENT (entlast))
  (setq OBJ (vlax-ename->vla-object ENT))
  (setq ENTLIST (entget ENT))
  (setq P1 (vlax-get-property OBJ 'InsertionPoint))
  (cond ((= AL "L")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentLeft)
         )
        )
        ((= AL "C")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentCenter)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "R")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentRight)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "M")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentMiddle)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "TL")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentTopLeft)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "TC")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentTopCenter)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "TR")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentTopRight)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "ML")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentMiddleLeft)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "MC")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentMiddleCenter)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "MR")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentMiddleRight)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "BL")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentBottomLeft)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "BC")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentBottomCenter)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
        ((= AL "BR")
         (progn
          (vlax-put-property OBJ 'Alignment acAlignmentBottomRight)
          (vlax-put-property OBJ 'TextAlignmentPoint P1)
         )
        )
  )
  (vlax-put-property OBJ 'Rotation A)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
 )
 
 (if RFL:PVILIST
  (progn
   (RFL:PROFDEF)
   (if RFL:PROFDEFLIST
    (progn
     (if (= (cdr (assoc "PROFDRAW" RFL:LPROFLIST)) 1)
      (progn
       (setq NLAYER (cdr (assoc "PROFLAYER" RFL:LPROFLIST)))
       (if (= "*" (substr NLAYER 1 1)) (setq NLAYER (strcat CLAYER (substr NLAYER 2))))
       (if (not (tblsearch "LAYER" NLAYER))
        (entmake (list (cons 0 "LAYER")
                       (cons 100 "AcDbSymbolTableRecord")
                       (cons 100 "AcDbLayerTableRecord")
                       (cons 2 NLAYER)
                       (cons 70 0)
                 )
        )
       )
       (setvar "CLAYER" NLAYER)
       (command "._PLINE")
       (foreach TMP RFL:PVILIST
        (progn
         (if (< (cadddr TMP) TOL)
          (command (RFL:PROFPOINT (car TMP) (cadr TMP)))
          (progn
           (setq C 0)
           (while (<= C 64)
            (command (RFL:PROFPOINT (+ (- (car TMP) (/ (cadddr TMP) 2.0)) (* (/ (cadddr TMP) 64) C))
                                    (RFL:ELEVATION (+ (- (car TMP) (/ (cadddr TMP) 2.0)) (* (/ (cadddr TMP) 64) C)))
                     )
            )
            (setq C (+ C 1))
           )
          )
         )
        )
       )
       (command "")
       (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      )
     )
     (if (or (= (cdr (assoc "LSLOPE" RFL:LPROFLIST)) 1)
             (= (cdr (assoc "LL" RFL:LPROFLIST)) 1)
             (= (cdr (assoc "LK" RFL:LPROFLIST)) 1)
             (= (cdr (assoc "CNODES" RFL:LPROFLIST)) 1)
             (= (cdr (assoc "DPVI" RFL:LPROFLIST)) 1)
             (= (cdr (assoc "LPVI" RFL:LPROFLIST)) 1)
             (= (cdr (assoc "LBVC" RFL:LPROFLIST)) 1)
             (= (cdr (assoc "LELEVATIONS" RFL:LPROFLIST)) 1)
         )
      (progn
       (if (or (= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) 1)
               (= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) nil)
           )
        (cond ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRLEFT")
               (setq DIRECTIONT 1 DIRECTIONS 1)
              )
              ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRRIGHT")
               (setq DIRECTIONT -1 DIRECTIONS 1)
              )
              ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRUP")
               (setq DIRECTIONT 1 DIRECTIONS 1)
              )
              ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRDOWN")
               (setq DIRECTIONT -1 DIRECTIONS 1)
              )
        )
        (cond ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRLEFT")
               (setq DIRECTIONT 1 DIRECTIONS -1)
              )
              ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRRIGHT")
               (setq DIRECTIONT -1 DIRECTIONS -1)
              )
              ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRUP")
               (setq DIRECTIONT -1 DIRECTIONS -1)
              )
              ((= (cdr (assoc "DIRECTION" RFL:LPROFLIST)) "DIRDOWN")
               (setq DIRECTIONT 1 DIRECTIONS -1)
              )
        )
       )
       (if (= DIRECTIONT 1)
        (progn
         (if (= (cdr (assoc "RAB" RFL:LPROFLIST)) 0)
          (progn
           (setq MLMR "MR")
           (setq MLMRT "R")
           (setq MLMRB "TR")
           (setq SIDE 1)
          )
          (progn
           (setq MLMR "ML")
           (setq MLMRT "L")
           (setq MLMRB "TL")
           (setq SIDE -1)
          )
         )
        )
        (progn
         (if (= (cdr (assoc "RAB" RFL:LPROFLIST)) 0)
          (progn
           (setq MLMR "ML")
           (setq MLMRT "L")
           (setq MLMRB "TL")
           (setq SIDE 1)
          )
          (progn
           (setq MLMR "MR")
           (setq MLMRT "R")
           (setq MLMRB "TR")
           (setq SIDE -1)
          )
         )
        )
       )
       (setq ZMAX (nth 1 (nth 0 RFL:PVILIST)))
       (setq ZMIN (nth 1 (nth 0 RFL:PVILIST)))
       (setq C 1)
       (while (< C (length RFL:PVILIST))
        (if (> (nth 1 (nth C RFL:PVILIST)) ZMAX)
         (setq ZMAX (nth 1 (nth C RFL:PVILIST)))
        )
        (if (< (nth 1 (nth C RFL:PVILIST)) ZMIN)
         (setq ZMIN (nth 1 (nth C RFL:PVILIST)))
        )
        (setq C (+ C 1))
       )
       (setq C 1)
       (setq NLAYER (cdr (assoc "TEXTLAYER" RFL:LPROFLIST)))
       (if (= "*" (substr NLAYER 1 1)) (setq NLAYER (strcat CLAYER (substr NLAYER 2))))
       (if (not (tblsearch "LAYER" NLAYER))
        (entmake (list (cons 0 "LAYER")
                       (cons 100 "AcDbSymbolTableRecord")
                       (cons 100 "AcDbLayerTableRecord")
                       (cons 2 NLAYER)
                       (cons 70 0)
                 )
        )
       )
       (setvar "CLAYER" NLAYER)
       (setq STA1 (nth 0 (nth 0 RFL:PVILIST)))
       (setq Z1 (nth 1 (nth 0 RFL:PVILIST)))
       (setq L1 (nth 3 (nth 0 RFL:PVILIST)))
       (setq P (RFL:PROFPOINT STA1 Z1))
       (if (= (cdr (assoc "CNODES" RFL:LPROFLIST)) 1)
        (progn
         (command "._CIRCLE" P (cdr (assoc "CNODERAD" RFL:LPROFLIST)))
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         (command "._LINE"
                  (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "CNODERAD" RFL:LPROFLIST)))))
                  (list (nth 0 P) (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST))))))
                  ""
         )
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
        )
       )
       (if (= (cdr (assoc "LBVC" RFL:LPROFLIST)) 1)
        (progn
         (setq TMP (RFL:STATXT STA1))
         (if (= (cdr (assoc "LHIGH" RFL:LPROFLIST)) 0)
          (setq TMP (substr TMP (1+ (vl-string-search "+" TMP))))
         )
         (ADDTEXT (strcat "STA " TMP)
                  (list (+ (nth 0 P) (* DIRECTIONT (* 1.0 (cdr (assoc "CNODEHOFFSET" RFL:LPROFLIST)))))
                        (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                  )
                  (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                  MLMRT
                  (if (= DIRECTIONT 1)
                   (/ pi -2.0)
                   (/ pi 2.0)
                  )
         )
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         (setq TMP (RFL:ROUND Z1 (cdr (assoc "ELEVPREC" RFL:LPROFLIST))))
         (ADDTEXT (strcat "PIVC  "
                          (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                          " "
                          (cdr (assoc "UNITS" RFL:LPROFLIST))
                  )
                  (list (+ (nth 0 P) (* DIRECTIONT (* -1.0 (cdr (assoc "CNODEHOFFSET" RFL:LPROFLIST)))))
                        (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                  )
                  (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                  MLMRB
                  (if (= DIRECTIONT 1)
                   (/ pi -2.0)
                   (/ pi 2.0)
                  )
         )
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
        )
       )
       (while (< (+ C 1) (length RFL:PVILIST))
        (setq STA1 (nth 0 (nth (- C 1) RFL:PVILIST)))
        (setq Z1 (nth 1 (nth (- C 1) RFL:PVILIST)))
        (setq L1 (nth 3 (nth (- C 1) RFL:PVILIST)))
        (setq STA2 (nth 0 (nth C RFL:PVILIST)))
        (setq Z2 (nth 1 (nth C RFL:PVILIST)))
        (setq L2 (nth 3 (nth C RFL:PVILIST)))
        (setq STA3 (nth 0 (nth (+ C 1) RFL:PVILIST)))
        (setq Z3 (nth 1 (nth (+ C 1) RFL:PVILIST)))
        (setq L3 (nth 3 (nth (+ C 1) RFL:PVILIST)))
        (setq G1 (* (/ (- Z2 Z1) (- STA2 STA1)) 100.0))
        (setq G2 (* (/ (- Z3 Z2) (- STA3 STA2)) 100.0))
        (setq STA (/ (+ (+ STA1
                           (/ L1 2.0)
                        )
                        (- STA2
                           (/ L2 2.0)
                        )
                     )
                     2.0
                  )
        )
        (if (= (cdr (assoc "LSLOPE" RFL:LPROFLIST)) 1)
         (progn
          (ADDTEXT (strcat (if (> G1 0.0) "+" "") (rtos G1 2 (cdr (assoc "SLOPEPREC" RFL:LPROFLIST))) "%")
                   (list (+ (car (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                            (* 1.75
                               SIDE
                               (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                               (sin (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)))
                            )
                         )
                         (+ (cadr (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                            (* -1.75
                               SIDE
                               (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                               (cos (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)))
                            )
                         )
                   )
                   (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                   (if (= SIDE 1) "C" "TC")
                   (if (= DIRECTIONS 1)
                    (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1))
                    (angle (RFL:PROFPOINT STA1 Z1) (RFL:PROFPOINT STA2 Z2))
                   )
          )
          (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         )
        )
        (setq P (RFL:PROFPOINT STA2 Z2))
        (if (= (cdr (assoc "LPVI" RFL:LPROFLIST)) 1)
         (progn
          (setq TMP (RFL:STATXT STA2))
          (if (= (cdr (assoc "LHIGH" RFL:LPROFLIST)) 0)
           (setq TMP (substr TMP (1+ (vl-string-search "+" TMP))))
          )
          (ADDTEXT (strcat "STA  " TMP)
                   (list (+ (nth 0 P) (* DIRECTIONT (* 1.0 (cdr (assoc "CNODEHOFFSET" RFL:LPROFLIST)))))
                         (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                   )
                   (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                   MLMRT
                  (if (= DIRECTIONT 1)
                   (/ pi -2.0)
                   (/ pi 2.0)
                  )
          )
          (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          (setq TMP (RFL:ROUND Z2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST))))
          (ADDTEXT (strcat "PIVC  "
                           (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                           " "
                           (cdr (assoc "UNITS" RFL:LPROFLIST))
                   )
                   (list (+ (nth 0 P) (* DIRECTIONT (* -1.0 (cdr (assoc "CNODEHOFFSET" RFL:LPROFLIST)))))
                         (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                   )
                   (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                   MLMRB
                  (if (= DIRECTIONT 1)
                   (/ pi -2.0)
                   (/ pi 2.0)
                  )
          )
          (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         )
        )
        (if (= (cdr (assoc "DPVI" RFL:LPROFLIST)) 1)
         (progn
          (command "._CIRCLE" (RFL:PROFPOINT STA2 Z2) (cdr (assoc "CNODERAD" RFL:LPROFLIST)))
          (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          (command "._LINE"
                   (list (nth 0 (RFL:PROFPOINT STA2 Z2)) (+ (nth 1 (RFL:PROFPOINT STA2 Z2)) (* SIDE (cdr (assoc "CNODERAD" RFL:LPROFLIST)))))
                   (list (nth 0 (RFL:PROFPOINT STA2 Z2)) (+ (nth 1 (RFL:PROFPOINT STA2 Z2)) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST))))))
                   ""
          )
          (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         )
        )
        (if (> L2 0.0)
         (progn
          (setq K (abs (/ L2
                          (- G2 G1)
                       )
                  )
          )
          (if (= (cdr (assoc "LL" RFL:LPROFLIST)) 1)
           (progn
            (setq TMP (RFL:ROUND L2 (cdr (assoc "LPREC" RFL:LPROFLIST))))
            (ADDTEXT (strcat (rtos TMP 2 (cdr (assoc "LPREC" RFL:LPROFLIST))) " VC")
                     (list (nth 0 P) (- (nth 1 P) (* SIDE 50.0)))
                     (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                     "TC"
                    0.0
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (if (= (cdr (assoc "LK" RFL:LPROFLIST)) 1)
           (progn
            (setq TMP (RFL:ROUND K (cdr (assoc "KPREC" RFL:LPROFLIST))))
            (ADDTEXT (strcat "K = " (rtos TMP 2 (cdr (assoc "KPREC" RFL:LPROFLIST))))
                     (list (nth 0 P) (- (nth 1 P) (* SIDE 50.0) 5.25))
                     (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                     "TC"
                    0.0
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (if (= (cdr (assoc "DPVI" RFL:LPROFLIST)) 1)
           (progn
            (setq ANG (angle P (RFL:PROFPOINT STA1 Z1)))
            (command "._LINE"
                     (list (+ (nth 0 P)
                              (* (cdr (assoc "CNODERAD" RFL:LPROFLIST))
                                 (cos ANG)
                              )
                           )
                           (+ (nth 1 P)
                              (* (cdr (assoc "CNODERAD" RFL:LPROFLIST))
                                 (sin ANG)
                              )
                           )
                     )
                     (list (+ (nth 0 P)
                              (* (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)))
                                 (cos ANG)
                              )
                           )
                           (+ (nth 1 P)
                              (* (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)))
                                 (sin ANG)
                              )
                           )
                     )
                     ""
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (setq ANG (angle P (RFL:PROFPOINT STA3 Z3)))
            (command "._LINE"
                     (list (+ (nth 0 P)
                              (* (cdr (assoc "CNODERAD" RFL:LPROFLIST))
                                 (cos ANG)
                              )
                           )
                           (+ (nth 1 P)
                              (* (cdr (assoc "CNODERAD" RFL:LPROFLIST))
                                 (sin ANG)
                              )
                           )
                     )
                     (list (+ (nth 0 P)
                              (* (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)))
                                 (cos ANG)
                              )
                           )
                           (+ (nth 1 P)
                              (* (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)))
                                 (sin ANG)
                              )
                           )
                     )
                     ""
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (setq P (RFL:PROFPOINT (- STA2 (/ L2 2.0)) (RFL:ELEVATION (- STA2 (/ L2 2.0)))))
          (if (= (cdr (assoc "LBVC" RFL:LPROFLIST)) 1)
           (progn
            (setq TMP (RFL:ROUND (RFL:ELEVATION (- STA2 (/ L2 2.0))) (cdr (assoc "ELEVPREC" RFL:LPROFLIST))))
            (ADDTEXT (strcat "BVC  "
                             (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                             " "
                             (cdr (assoc "UNITS" RFL:LPROFLIST))
                     )
                     (list (nth 0 P)
                           (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                     )
                     (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                     MLMR
                     (if (= DIRECTIONT 1)
                      (/ pi -2.0)
                      (/ pi 2.0)
                     )
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (if (= (cdr (assoc "CNODES" RFL:LPROFLIST)) 1)
           (progn
            (command "._CIRCLE" P (cdr (assoc "CNODERAD" RFL:LPROFLIST)))
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (command "._LINE"
                     (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "CNODERAD" RFL:LPROFLIST)))))
                     (list (nth 0 P) (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST))))))
                     ""
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (setq P (RFL:PROFPOINT (+ STA2 (/ L2 2.0)) (RFL:ELEVATION (+ STA2 (/ L2 2.0)))))
          (if (= (cdr (assoc "LBVC" RFL:LPROFLIST)) 1)
           (progn
            (setq TMP (RFL:ROUND (RFL:ELEVATION (+ STA2 (/ L2 2.0))) (cdr (assoc "ELEVPREC" RFL:LPROFLIST))))
            (ADDTEXT (strcat "EVC  "
                             (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                             " "
                             (cdr (assoc "UNITS" RFL:LPROFLIST))
                     )
                     (list (nth 0 P)
                           (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                     )
                     (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                     MLMR
                     (if (= DIRECTIONT 1)
                      (/ pi -2.0)
                      (/ pi 2.0)
                     )
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (if (= (cdr (assoc "CNODES" RFL:LPROFLIST)) 1)
           (progn
            (command "._CIRCLE" P (cdr (assoc "CNODERAD" RFL:LPROFLIST)))
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
            (command "._LINE"
                     (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "CNODERAD" RFL:LPROFLIST)))))
                     (list (nth 0 P) (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST))))))
                     ""
            )
            (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
           )
          )
          (if (= (cdr (assoc "LELEVATIONSC" RFL:LPROFLIST)) 1)
           (progn
            (setq STA (float (* (+ (fix (/ (- STA2 (/ L2 2.0)) (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST)))) 1) (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST)))))
            (while (< STA (+ STA2 (/ L2 2.0)))
             (setq P (RFL:PROFPOINT STA (cdr (assoc "ELEV" RFL:PROFDEFLIST))))
             (setq P (list (car P)
                           (+ (cadr P)
                              (cdr (assoc "ELEVTEXTOS" RFL:LPROFLIST))
                           )
                     )
             )
             (setq TMP (RFL:ROUND (RFL:ELEVATION STA) (cdr (assoc "ELEVPREC" RFL:LPROFLIST))))
             (ADDTEXT (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                      P
                      (cdr (assoc "ELEVTEXTHEIGHT" RFL:LPROFLIST))
                      MLMR
                      (if (= DIRECTIONT 1)
                       (/ pi -2.0)
                       (/ pi 2.0)
                      )
             )
             (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             (setq STA (+ STA (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST))))
            )
           )
          )
          (if (= (cdr (assoc "LELEVATIONST" RFL:LPROFLIST)) 1)
           (progn
            (setq STA (float (* (+ (fix (/ (+ STA1 (/ L1 2.0)) (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST)))) 1) (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST)))))
            (while (< STA (- STA2 (/ L2 2.0)))
             (setq P (RFL:PROFPOINT STA (cdr (assoc "ELEV" RFL:PROFDEFLIST))))
             (setq P (list (car P)
                           (+ (cadr P)
                              (cdr (assoc "ELEVTEXTOS" RFL:LPROFLIST))
                           )
                     )
             )
             (setq TMP (RFL:ROUND (RFL:ELEVATION STA) (cdr (assoc "ELEVPREC" RFL:LPROFLIST))))
             (ADDTEXT (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                      P
                      (cdr (assoc "ELEVTEXTHEIGHT" RFL:LPROFLIST))
                      MLMR
                      (if (= DIRECTIONT 1)
                       (/ pi -2.0)
                       (/ pi 2.0)
                      )
             )
             (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
             (setq STA (+ STA (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST))))
            )
           )
          )
         )
        )
        (setq C (+ C 1))
       )
       (setq STA (/ (+ (+ STA2
                          (/ L2 2.0)
                       )
                       (- STA3
                          (/ L3 2.0)
                       )
                    )
                    2.0
                 )
       )
       (if (= (cdr (assoc "LSLOPE" RFL:LPROFLIST)) )
        (progn
         (ADDTEXT (strcat (if (> G2 0.0) "+" "") (rtos G2 2 (cdr (assoc "SLOPEPREC" RFL:LPROFLIST))) "%")
                  (list (+ (car (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                           (* 1.75
                              SIDE
                              (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                              (sin (angle (RFL:PROFPOINT STA3 Z3) (RFL:PROFPOINT STA2 Z2)))
                           )
                        )
                        (+ (cadr (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                           (* -1.75
                              SIDE
                              (if (= (cdr (assoc "DIRECTION" RFL:PROFDEFLIST)) -1) -1 1)
                              (cos (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA1 Z1)))
                           )
                        )
                  )
                  (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                  (if (= SIDE 1) "C" "TC")
                  (if (= DIRECTIONS 1)
                   (angle (RFL:PROFPOINT STA3 Z3) (RFL:PROFPOINT STA2 Z2))
                   (angle (RFL:PROFPOINT STA2 Z2) (RFL:PROFPOINT STA3 Z3))
                  )
         )
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
        )
       )
       (setq P (RFL:PROFPOINT STA3 Z3))
       (if (= (cdr (assoc "CNODES" RFL:LPROFLIST)) 1)
        (progn
         (command "._CIRCLE" P (cdr (assoc "CNODERAD" RFL:LPROFLIST)))
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         (command "._LINE"
                  (list (nth 0 P) (+ (nth 1 P) (* SIDE (cdr (assoc "CNODERAD" RFL:LPROFLIST)))))
                  (list (nth 0 P) (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST))))))
                  ""
         )
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
        )
       )
       (if (= (cdr (assoc "LBVC" RFL:LPROFLIST)) 1)
        (progn
         (setq TMP (RFL:STATXT STA3))
         (if (= (cdr (assoc "LHIGH" RFL:LPROFLIST)) 0)
          (setq TMP (substr TMP (1+ (vl-string-search "+" TMP))))
         )
         (ADDTEXT (strcat "STA  " TMP)
                  (list (+ (nth 0 P) (* DIRECTIONT (* 1.0 (cdr (assoc "CNODEHOFFSET" RFL:LPROFLIST)))))
                        (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                  )
                  (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                  MLMRT
                  (if (= DIRECTIONT 1)
                   (/ pi -2.0)
                   (/ pi 2.0)
                  )
         )
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
         (setq TMP (RFL:ROUND Z3 (cdr (assoc "SLOPEPREC" RFL:LPROFLIST))))
         (ADDTEXT (strcat "PIVC  "
                          (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                          " "
                          (cdr (assoc "UNITS" RFL:LPROFLIST))
                  )
                  (list (+ (nth 0 P) (* DIRECTIONT (* -1.0 (cdr (assoc "CNODEHOFFSET" RFL:LPROFLIST)))))
                        (+ (nth 1 P) (* SIDE (+ (cdr (assoc "CNODERAD" RFL:LPROFLIST)) (cdr (assoc "CNODELENGTH" RFL:LPROFLIST)) (cdr (assoc "CNODEVOFFSET" RFL:LPROFLIST)))))
                  )
                  (cdr (assoc "TEXTHEIGHT" RFL:LPROFLIST))
                  MLMRB
                  (if (= DIRECTIONT 1)
                   (/ pi -2.0)
                   (/ pi 2.0)
                  )
         )
         (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
        )
       )
       (if (= (cdr (assoc "LELEVATIONSC" RFL:LPROFLIST)) 1)
        (progn
         (setq STA (float (* (+ (fix (/ (+ STA2 (/ L2 2.0)) (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST)))) 1) (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST)))))
         (while (< STA (- STA3 (/ L3 2.0)))
          (setq P (RFL:PROFPOINT STA (cdr (assoc "ELEV" RFL:PROFDEFLIST))))
          (setq P (list (car P)
                        (+ (cadr P)
                           (cdr (assoc "ELEVTEXTOS" RFL:LPROFLIST))
                        )
                  )
          )
          (setq TMP (RFL:ROUND (RFL:ELEVATION STA) (cdr (assoc "ELEVPREC" RFL:LPROFLIST))))
          (ADDTEXT (rtos TMP 2 (cdr (assoc "ELEVPREC" RFL:LPROFLIST)))
                   P
                   (cdr (assoc "ELEVTEXTHEIGHT" RFL:LPROFLIST))
                   MLMR
                   (if (= DIRECTIONT 1)
                    (/ pi -2.0)
                    (/ pi 2.0)
                   )
          )
          (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          (setq STA (+ STA (cdr (assoc "ELEVTEXTINC" RFL:LPROFLIST))))
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "REGENMODE" REGENMODE)
 (setvar "CMDECHO" CMDECHO)
 (setvar "DIMZIN" DIMZIN)
 (setvar "LUPREC" LUPREC)
 (setvar "CLAYER" CLAYER)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "SPLINETYPE" SPLINETYPE)
 (setvar "SPLINESEGS" SPLINESEGS)
 (setvar "PLINETYPE" PLINETYPE)
 (setvar "TEXTSTYLE" TEXTSTYLE)
);
;
;     Program written by Robert Livingston, 2018/10/01
;
;     LSPACE is a utility for labelling spaces
;
;
(setq RFL:LSPACELAYER "")
(setq RFL:LSPACETHEIGHT 0.75)
(setq RFL:LSPACESUFFIX "m")
(setq RFL:LSPACEPREC 2)
(defun C:LSPACESETUP (/ CMDECHO TMP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq RFL:LSPACELAYER (getstring "\nEnter layer of new entities (<return> for current layer) : "))
 (setq RFL:LSPACETHEIGHT (getdist "\nLabel text height <0.75> : "))
 (if (or (= RFL:LSPACETHEIGHT nil) (= RFL:LSPACETHEIGHT 0.0)) (setq RFL:LSPACETHEIGHT 0.75))
 (setq RFL:LSPACESUFFIX (getstring "\nEnter suffix for label text : "))
 (setq RFL:LSPACEPREC (getint "\nLabel text precision <2> : "))
 (if (or (= RFL:LSPACEPREC nil) (<= RFL:LSPACEPREC 0)) (setq RFL:LSPACEPREC 2))

 (setvar "CMDECHO" CMDECHO)
)
(defun C:LSPACE (/ *error* ACTIVEDOC ACTIVESPC ANG P P1 P2 VT)
 (setq CLAYER (getvar "CLAYER"))
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 640)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)

 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )

 (command "._UNDO" "M")
 
 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CLAYER" CLAYER)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "DIMZIN" DIMZIN)
  ;(setq *error* nil)
  (princ msg)
 )

 (command "._UNDO" "M")

 (command "._UCS" "W")

 (if (/= "" RFL:LSPACELAYER)
  (progn
   (if (= nil (tblsearch "LAYER" RFL:LSPACELAYER))
    (command "._LAYER" "M" RFL:LSPACELAYER)
    (setvar "CLAYER" RFL:LSPACELAYER)
   )
  )
 )

 (setq VT (getvar "VIEWTWIST"))
 (if (> VT pi) (setq VT (- VT (* 2.0 pi))))
 (setq P1 (getpoint "\nFirst point : "))
 (setq P1 (list (car P1) (cadr P1)))
 (setq P2 (getpoint P1 "\nSecond point : "))
 (setq P2 (list (car P2) (cadr P2)))
 (setq P (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))
 (if (and (> (angle P P2) (- 0.0 VT)) (< (angle P P2) (- pi VT)))
  (setq ANG (- (angle P P2) (/ pi 2)))
  (setq ANG (+ (angle P P2) (/ pi 2)))
 )
 (setq TEXTSTRING (strcat (rtos (distance P1 P2) 2 RFL:LSPACEPREC) RFL:LSPACESUFFIX))
 (if (setq TEXTOBJ (vla-addtext ACTIVESPC
                                TEXTSTRING
                                (vlax-3D-point P)
                                RFL:LSPACETHEIGHT
                   )
     )
  (progn
   (vla-put-Alignment textObj acAlignmentMiddle)
   (vla-put-Rotation textObj ANG)
   (vla-put-TextAlignmentPoint textObj (vlax-3D-point P))
  )
 )

 (command "._UCS" "P")
 (setvar "CLAYER" CLAYER)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "DIMZIN" DIMZIN)
)
(princ "\n*****  Use LSPACESETUP to change defaults *****\n");
;
;     Program written by Robert Livingston, 04-12-08
;
;     LVCURVE is a utility for labelling Vertical Profile entities
;
;
(defun C:LVCURVE (/ *error* ANGBASE ANGDIR CMDECHO ENT ENTLIST G1 G2 K L P P1 P2 P3 STR TMP VEXAG)
 (command "._UNDO" "M")

 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (defun *error* (msg)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (print msg)
  ;(setq *error* nil)
 )

 (setq H nil)
 (setq ENTLIST (tblsearch "STYLE" (getvar "TEXTSTYLE")))
 (setq H (cdr (assoc 40 ENTLIST)))

 (setq VEXAG (getreal "\nEnter vertical exageration <10.000> : "))
 (if (= VEXAG nil) (setq VEXAG 10.0))

 (while (/= nil (setq ENT (car (entsel "\nSelect profile entity : "))))
  (setq ENTLIST (entget ENT))
  (if (= "LINE" (cdr (assoc 0 ENTLIST)))
   (progn
    (setq P1 (cdr (assoc 10 ENTLIST)))
    (setq P2 (cdr (assoc 11 ENTLIST)))
    (setq P (list (/ (+ (car P1) (car P2)) 2.0) (/ (+ (cadr P1) (cadr P2)) 2.0)))
    (if (< (car P2) (car P1))
     (progn
      (setq TMP P1)
      (setq P1 P2)
      (setq P2 TMP)
     )
    )
    (setq TMP (/ (- (cadr P2) (cadr P1)) (- (car P2) (car P1)) VEXAG 0.01))
    (if (= H 0.0)
     (command "._TEXT" "BC" P 5.0 P2 (strcat (if (< TMP 0.0) "-" "+") (rtos (abs TMP)) "%"))
     (command "._TEXT" "BC" P P2 (strcat (if (< TMP 0.0) "-" "+") (rtos (abs TMP)) "%"))
    )
   )
   (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (progn
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P2 (cdr (assoc 10 ENTLIST)))
     (if (/= nil P2)
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P3 (cdr (assoc 10 ENTLIST)))
       (if (/= nil P3)
        (progn
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
         (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
          (setq P2 P3)
          (setq P3 (cdr (assoc 10 ENTLIST)))
          (setq ENT (entnext ENT))
          (setq ENTLIST (entget ENT))
         )
        )
       )
      )
     )
     (if (and (/= nil P1) (/= nil P2) (/= nil P3))
      (progn
       (setq P (list (car P2) (/ (+ (cadr P1) (cadr P2) (cadr P3)) 3.0)))
       (setq L (abs (- (nth 0 P3) (nth 0 P1))))
       (setq G1 (/ (- (nth 1 P2) (nth 1 P1))
                   (- (nth 0 P2) (nth 0 P1))
                   VEXAG
                )
       )
       (setq G2 (/ (- (nth 1 P3) (nth 1 P2))
                   (- (nth 0 P3) (nth 0 P2))
                   VEXAG
                )
       )
       (setq K (abs (/ L (- G2 G1) 100.0)))
       (if (= H 0.0)
        (progn
         (command "._TEXT" "M" P 5.0 0.0 (strcat "K = " (rtos (abs K))))
         (command "._TEXT" "" (strcat "L = " (rtos (abs L))))
        )
        (progn
         (command "._TEXT" "M" P 0.0 (strcat "K = " (rtos (abs K))))
         (command "._TEXT" "" (strcat "L = " (rtos (abs L))))
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 2019-08-16
;
;     C:LISTK is a simple routine for displaying the K value for a selected vertical curve
;
;
(defun C:LISTK (/ ENT ENTLIST G1 G2 K L P1 P2 P3 X1 X2 X3 Y1 Y2 Y3)
 (setq K nil)
 (setq ENT (car (entsel "\nSelect Vertical curve : ")))
 (setq ENTLIST (entget ENT))
 (if (/= "POLYLINE" (cdr (assoc 0 ENTLIST)))
  (princ "\n*** Entity not a polyline ***")
  (progn
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (setq P1 (cdr (assoc 10 ENTLIST)))
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (setq P2 (cdr (assoc 10 ENTLIST)))
   (if (/= nil P2)
    (progn
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P3 (cdr (assoc 10 ENTLIST)))
     (if (/= nil P3)
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
        (setq P2 P3)
        (setq P3 (cdr (assoc 10 ENTLIST)))
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
       )
      )
     )
    )
   )
   (if (and (/= nil P1) (/= nil P2) (/= nil P3))
    (progn
     (setq VEXAG (getreal (strcat "\nEnter vertical exageration (" (rtos 10.0) ") : ")))
     (if (= nil VEXAG) (setq VEXAG 10.0))
     (setq X1 (nth 0 P1))
     (setq Y1 (/ (nth 1 P1) VEXAG))
     (setq X2 (nth 0 P2))
     (setq Y2 (/ (nth 1 P2) VEXAG))
     (setq X3 (nth 0 P3))
     (setq Y3 (/ (nth 1 P3) VEXAG))
     (setq G1 (/ (- Y2 Y1) (- X2 X1)))
     (setq G2 (/ (- Y3 Y2) (- X3 X2)))
     (setq L (- X3 X1))
     (setq K (abs (/ L (- G2 G1) 100.0)))
    )
   )
  )
 )
 (princ "\n")
 (if K
  (rtos K 2 8)
  nil
 )
);
;
;     Program written by Robert Livingston, 2017-02-18
;
;     C:MAKESUPER is a utility for generating Superelevations along an alignment.
;
;
(defun C:MAKESUPER (/ C GETSUPER L NODE REP R R1 R2 RUNOUT S S1 S2 STA TABLE VDES)
 (defun GETSUPER (TABLE R VDES)
  (apply (read TABLE) (list R VDES))
 )
 (initget "Bc Tac")
 (if (setq REP (getkword "\n6% BC Sup or 6% TAC (BC/TAC) <TAC> : "))
  (setq TABLE REP)
  (setq TABLE "TAC")
 )
 (if (= TABLE "TAC")
  (setq TABLE "RFL:GETTACSUPER")
  (setq TABLE "RFL:GETBCSUPER")
 )
 (if (setq REP (getdist "\nDesign speed (must be table column value) <60>: "))
  (setq VDES REP)
  (setq VDES 60.0)
 )
 (if (setq REP (getdist "\nEnter spiral runout distance <60.0> : "))
  (setq RUNOUT REP)
  (setq RUNOUT 60.0)
 )
 (setq RFL:SUPERLIST nil)
 (foreach NODE RFL:ALIGNLIST
  (cond ((listp (last NODE))
         (progn ; Spiral
          (print "SPIRAL")
          (setq S nil S1 nil S2 nil)
          (setq STA (car NODE))
          (setq L (- (RFL:ARCLENGTH (nth 1 NODE) (nth 2 NODE) (nth 3 NODE)) (last (nth 3 NODE))))
          (setq R1 (RFL:GETRADIUS STA))
          (if (> (abs R1) 10000.0) (setq R1 0.0))
          (setq R2 (RFL:GETRADIUS (+ STA L)))
          (if (> (abs R2) 10000.0) (setq R2 0.0))
          (if (< (abs R1) RFL:TOL)
           (setq S1 (list -2.0 0.0))
           (setq S1 (GETSUPER TABLE (abs R1) VDES))
          )
          (if (or (< R1 0.0) (< R2 0.0)) (setq S1 (reverse S1)))
          (if (< (abs R2) RFL:TOL)
           (setq S2 (list -2.0 0.0))
           (setq S2 (GETSUPER TABLE (abs R2) VDES))
          )
          (if (or (< R1 0.0) (< R2 0.0)) (setq S2 (reverse S2)))
          (cond ((= 0.0 (car S1))
                 (setq S (list (+ STA (* L (/ 2.0 (car S2)))) 2.0 -2.0))
                )
                ((= 0.0 (cadr S1))
                 (setq S (list (+ STA (* L (/ 2.0 (cadr S2)))) -2.0 2.0))
                )
                ((= 0.0 (car S2))
                 (setq S (list (- (+ STA L) (* L (/ 2.0 (car S1)))) 2.0 -2.0))
                )
                ((= 0.0 (cadr S2))
                 (setq S (list (- (+ STA L) (* L (/ 2.0 (cadr S1)))) -2.0 2.0))
                )
          )
          (if (/= S nil)
           (progn
            (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list STA (car S1) (cadr S1)))))
            (setq RFL:SUPERLIST (append RFL:SUPERLIST (list S)))
            (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (+ STA L) (car S2) (cadr S2)))))
           )
          )
         )
        )
        ((< (abs (last NODE)) RFL:TOL)
         (progn ; Line
          (print "LINE")
          (if (> (distance (nth 1 NODE) (nth 2 NODE)) (* 2.0 RUNOUT))
           (progn
            (if (= (car NODE) (car (car RFL:ALIGNLIST)))
             (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (nth 0 NODE) -2.0 -2.0))))
             (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (+ (nth 0 NODE) RUNOUT) -2.0 -2.0))))
            )
            (if (= (car NODE) (car (last RFL:ALIGNLIST)))
             (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (+ (nth 0 NODE) (distance (nth 1 NODE) (nth 2 NODE))) -2.0 -2.0))))
             (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (- (+ (nth 0 NODE) (distance (nth 1 NODE) (nth 2 NODE))) RUNOUT) -2.0 -2.0))))
            )
           )
          )
         )
        )
        (T
         (progn ; Arc
          (print "ARC")
          (setq S (GETSUPER TABLE (RFL:RADIUS (nth 1 NODE) (nth 2 NODE) (abs (nth 3 NODE))) VDES))
          (if (< (nth 3 NODE) 0.0)
           (setq S (reverse S))
          )
          (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (nth 0 NODE) (car S) (cadr S)))))
          (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (+ (nth 0 NODE) (RFL:ARCLENGTH (nth 1 NODE) (nth 2 NODE) (nth 3 NODE))) (car S) (cadr S)))))
         )
        )
  )
 )
 (setq S RFL:SUPERLIST)
 (setq RFL:SUPERLIST (list (car S)))
 (setq C 1)
 (while (< C (length S))
  (if (> (abs (- (car (nth C S)) (car (nth (1- C) S)))) RFL:TOL)
   (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (nth C S))))
   (if (and (or (= (cadr (nth C S)) 0.0) (= (cadr (nth C S)) -2.0))
            (or (= (caddr (nth C S)) 0.0) (= (caddr (nth C S)) -2.0))
       )
    (progn
     (setq RFL:SUPERLIST (reverse (cdr (reverse RFL:SUPERLIST))))
     (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list (car (nth C S)) 0.0 0.0))))
    )
   )
  )
  (setq C (1+ C))
 )
);
;
;     Program written by Robert Livingston, 2015-02-20
;
;     C:PCHANNEL is a routine for finding a simple flat bottom section with constant grade along a surface between two selected points
;
;
(defun C:PCHANNEL (/ *error* ANG ANGBASE ANGDIR CMDECHO CONTINUE CSLOPE CWIDTH2 D D1 D2 DIST2D ENT ENTOBJ ENTL ENTLOBJ ENTR ENTROBJ FSLOPE GETOS GRADE GRSECTION NODE OBSURFACE OGLIST ORTHOMODE OS OSMODE P P0 P1 P2 PL PLI PLI0 PR PRI PRI0 REP STEP SWATH TMP Z0 Z1)
 (vl-load-com)
 (command "._UNDO" "M")
 (command "._UCS" "W")
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  ;(setq *error* nil)
  (print msg)
 )

 (defun GETOS (/ C P1 P2 P3 P3C P3F P3I P4 P4C P4F P4I)
  (setq P3 (list (/ CWIDTH2 -2.0) Z)
        P3C (list (/ SWATH -2.0) (+ Z (/ (- SWATH CWIDTH2) 2.0 CSLOPE)))
        P3F (list (/ SWATH -2.0) (- Z (/ (- SWATH CWIDTH2) 2.0 FSLOPE)))
        P4 (list (/ CWIDTH2 2.0) Z)
        P4C (list (/ SWATH 2.0) (+ Z (/ (- SWATH CWIDTH2) 2.0 CSLOPE)))
        P4F (list (/ SWATH 2.0) (- Z (/ (- SWATH CWIDTH2) 2.0 FSLOPE)))
  )
  (setq P3I nil P4I nil)
  (setq C 0)
  (while (< (+ C 1) (length OGLIST))
   (setq P1 (nth C OGLIST))
   (setq P2 (nth (+ C 1) OGLIST))
   (if (setq TMP (inters P1 P2 P3 P3C))
    (if (< (car TMP) (/ CWIDTH2 -2.0))
     (setq P3I TMP)
    )
    (if (setq TMP (inters P1 P2 P3 P3F))
     (if (< (car TMP) (/ CWIDTH2 -2.0))
      (setq P3I TMP)
     )
    )
   )
   (if (setq TMP (inters P1 P2 P4 P4C))
    (if (and (> (car TMP) (/ CWIDTH2 2.0))
             (= P4I nil)
        )
     (setq P4I TMP)
    )
    (if (setq TMP (inters P1 P2 P4 P4F))
     (if (and (> (car TMP) (/ CWIDTH2 2.0))
              (= P4I nil)
         )
      (setq P4I TMP)
     )
    )
   )
   (setq C (+ C 1))
  )
  (if (and P3I P3 P4 P4I)
   (list P3I P3 P4 P4I)
   nil
  )
 )
 
 (defun GRSECTION (/ C H NODE P1 P2 P3 P4 PC PB SCALE)
  (setq PC (getvar "VIEWCTR"))
  (setq H (getvar "VIEWSIZE"))
  (setq PB (list (+ (car PC) (/ H 3.0)) (- (cadr PC) (/ H 4.0))))
  (setq SCALE (/ (/ H 2.0) SWATH))
  (setq C 0)
  (setq P1 (nth C OGLIST))
  (setq P1 (list (+ (car PB) (* SCALE (car P1))) (+ (cadr PB) (* SCALE (- (cadr P1) Z)))))
  (while (< (+ C 1) (length OGLIST))
   (progn
    (setq P2 (nth (+ C 1) OGLIST))
    (setq P2 (list (+ (car PB) (* SCALE (car P2))) (+ (cadr PB) (* SCALE (- (cadr P2) Z)))))
    (grdraw P1 P2 -1)
    (setq P1 P2)
    (setq C (+ C 1))
   )
  )
  (if OS
   (progn
    (setq P1 (nth 0 OS))
    (setq P1 (list (+ (car PB) (* SCALE (car P1))) (+ (cadr PB) (* SCALE (- (cadr P1) Z)))))
    (setq P2 (nth 1 OS))
    (setq P2 (list (+ (car PB) (* SCALE (car P2))) (+ (cadr PB) (* SCALE (- (cadr P2) Z)))))
    (grdraw P1 P2 -1)
    (setq P3 (nth 2 OS))
    (setq P3 (list (+ (car PB) (* SCALE (car P3))) (+ (cadr PB) (* SCALE (- (cadr P3) Z)))))
    (grdraw P2 P3 -1)
    (setq P4 (nth 3 OS))
    (setq P4 (list (+ (car PB) (* SCALE (car P4))) (+ (cadr PB) (* SCALE (- (cadr P4) Z)))))
    (grdraw P3 P4 -1)
   )
  )
 )
 
 (defun DIST2D (P1 P2)
  (distance (list (car P1) (cadr P1)) (list (car P2) (cadr P2)))
 )
 
 (if (/= nil (setq OBSURFACE (RFL:GETC3DSURFACE)))
  (if (/= nil (setq P0 (getpoint "\nChannel start point : ")))
   (if (/= nil (setq Z0 (RFL:GETSURFACEPOINT P0 OBSURFACE)))
    (progn
     (setq P0 (list (car P0) (cadr P0)))
     (setq REP (getreal (strcat "\nEnter channel start elevation <" (rtos Z0) "> : ")))
     (if (/= nil REP) (setq Z0 REP))
     (setq P2 (getpoint "\nChannel end point : "))
     (if (/= nil (setq Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)))
      (progn
       (setq REP (getreal (strcat "\nEnter channel end elevation <" (rtos Z2) "> : ")))
       (if (/= nil REP) (setq Z2 REP))
       (setq GRADE (* 100.0 (/ (- Z2 Z0) (DIST2D P0 P2))))
       (princ (strcat "\nGrade (%) = " (rtos GRADE)))
       (setq GRADE (/ GRADE 100.0))
       (setq SWATH 50.0)
       (setq REP (getreal (strcat "\nEnter swath width <" (rtos SWATH) "> : ")))
       (if (/= nil REP) (setq SWATH REP))
       (setq CSLOPE 2.0)
       (setq REP (getdist (strcat "\nEnter cut slope (X:1) <" (rtos CSLOPE) "> : ")))
       (if (/= nil REP) (setq CSLOPE REP))
       (setq FSLOPE CSLOPE)
       (setq REP (getdist (strcat "\nEnter fill slope (X:1) <" (rtos FSLOPE) "> : ")))
       (if (/= nil REP) (setq FSLOPE REP))
       (setq CWIDTH 2.0)
       (setq REP (getdist (strcat "\nEnter channel width <" (rtos CWIDTH) "> : ")))
       (if (/= nil REP) (setq CWIDTH REP))
       (setq CONTINUE T)
       (setvar "OSMODE" 0)
       ;(command "._PLINE" P0)
       (setq ENTL nil ENT nil ENTR nil)
       ; Get Start Catch Points
       (setq ANG (angle P0 P2))
       (setq PL (list (+ (car P0) (* (/ SWATH 2.0) (cos (+ ANG (/ pi 2.0)))))
                      (+ (cadr P0) (* (/ SWATH 2.0) (sin (+ ANG (/ pi 2.0)))))
                )
       )       
       (setq PR (list (+ (car P0) (* (/ SWATH 2.0) (cos (- ANG (/ pi 2.0)))))
                      (+ (cadr P0) (* (/ SWATH 2.0) (sin (- ANG (/ pi 2.0)))))
                )
       )
       (setq CWIDTH2 CWIDTH)
       (setq OGLIST nil)
       (if (and (/= nil PL) (/= nil PR))
        (progn
         (setq TMP (RFL:GETSURFACELINE PL P0 OBSURFACE))
         (foreach NODE TMP
          (setq OGLIST (append OGLIST (list (list (* -1.0 (DIST2D NODE P0)) (last NODE)))))
         )
         (setq TMP (cdr (RFL:GETSURFACELINE P0 PR OBSURFACE)))
         (foreach NODE TMP
          (setq OGLIST (append OGLIST (list (list (DIST2D NODE P0) (last NODE)))))
         )
        )
       )
       (if OGLIST
        (setq OS (GETOS))
        (setq OS nil)
       )
       (if OS
        (setq PLI0 (list (+ (car P0) (* -1.0 (car (nth 0 OS)) (cos (+ ANG (/ pi 2.0)))))
                         (+ (cadr P0) (* -1.0 (car (nth 0 OS)) (sin (+ ANG (/ pi 2.0)))))
                   )
              PRI0 (list (+ (car P0) (* (car (nth 3 OS)) (cos (- ANG (/ pi 2.0)))))
                         (+ (cadr P0) (* (car (nth 3 OS)) (sin (- ANG (/ pi 2.0)))))
                   )
        )
        (setq PLI0 P0
              PRI0 P0
        )
       )
       ; End Get Start Catch Points
       (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
       (while (and (or (= 5 (car (setq P1 (grread T))))
                       (= 3 (car P1))
                       (= 2 (car P1))
                   )
                   CONTINUE
              )
        (if (= 2 (car P1))
         (if (= 43 (cadr P1))
          (progn
           (setq GRADE (+ GRADE 0.001))
           (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
          )
          (if (= 45 (cadr P1))
           (progn
            (setq GRADE (- GRADE 0.001))
            (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
           )
           (if (= 13 (cadr P1))
            (setq CONTINUE nil)
            (if (= 32 (cadr P1))
             (setq CONTINUE nil)
            )
           )
          )
         )
         (progn
          (setq P (list (caadr P1) (cadadr P1)))
          (setq ANG (/ (+ (angle P0 P) (angle P P2)) 2.0))
          (setq D1 (distance P0 P))
          (setq D2 (distance P P2))
          (setq Z (+ Z0 (* (- Z2 Z0) (/ D1 (+ D1 D2)))))
          (setq PL (list (+ (car P) (* (/ SWATH 2.0) (cos (+ ANG (/ pi 2.0)))))
                         (+ (cadr P) (* (/ SWATH 2.0) (sin (+ ANG (/ pi 2.0)))))
                   )
          )
          (setq PR (list (+ (car P) (* (/ SWATH 2.0) (cos (- ANG (/ pi 2.0)))))
                         (+ (cadr P) (* (/ SWATH 2.0) (sin (- ANG (/ pi 2.0)))))
                   )
          )
          (setq CWIDTH2 (/ CWIDTH (cos (/ (- (angle P P2) (angle P0 P)) 2.0))))
          (setq OGLIST nil)
          (if (and (/= nil PL) (/= nil PR))
           (progn
            (setq TMP (RFL:GETSURFACELINE PL P OBSURFACE))
            (foreach NODE TMP
             (setq OGLIST (append OGLIST (list (list (* -1.0 (DIST2D NODE P)) (last NODE)))))
            )
            (setq TMP (cdr (RFL:GETSURFACELINE P PR OBSURFACE)))
            (foreach NODE TMP
             (setq OGLIST (append OGLIST (list (list (DIST2D NODE P) (last NODE)))))
            )
           )
          )
          (if OGLIST
           (progn
            (setq OS (GETOS))
            (if OS
             (setq PLI (list (+ (car P) (* -1.0 (car (nth 0 OS)) (cos (+ ANG (/ pi 2.0)))))
                             (+ (cadr P) (* -1.0 (car (nth 0 OS)) (sin (+ ANG (/ pi 2.0)))))
                       )
                   PRI (list (+ (car P) (* (car (nth 3 OS)) (cos (- ANG (/ pi 2.0)))))
                             (+ (cadr P) (* (car (nth 3 OS)) (sin (- ANG (/ pi 2.0)))))
                       )
             )
             (setq PLI P
                   PRI P
             )
            )
            (command "'REDRAW")
            (grdraw PL PR -1)
            (GRSECTION)
            (grdraw P0 P -1)
            (grdraw PLI0 PLI -1)
            (grdraw PRI0 PRI -1)
           )
          )
          (if (= 3 (car P1))
           (progn
            (command "'REDRAW")
            (if ENT
             (progn
              (setq C (1+ C))
              (vlax-invoke ENTOBJ 'AddVertex C P)
              (vlax-invoke ENTLOBJ 'AddVertex C PLI)
              (vlax-invoke ENTROBJ 'AddVertex C PRI)
             )
             (progn
              (entmake)
              (entmake (list (cons 0 "LWPOLYLINE")
                             (cons 100 "AcDbEntity")
                             (cons 100 "AcDbPolyline")
                             (cons 90 2)
                             (append (list 10) P0)
                             (append (list 10) P)
                       )
              )
              (setq ENT (entlast))
              (setq ENTOBJ (vlax-ename->vla-object ENT))
              (entmake)
              (entmake (list (cons 0 "LWPOLYLINE")
                             (cons 100 "AcDbEntity")
                             (cons 100 "AcDbPolyline")
                             (cons 90 2)
                             (append (list 10) PLI0)
                             (append (list 10) PLI)
                       )
              )
              (setq ENTL (entlast))
              (setq ENTLOBJ (vlax-ename->vla-object ENTL))
              (entmake)
              (entmake (list (cons 0 "LWPOLYLINE")
                             (cons 100 "AcDbEntity")
                             (cons 100 "AcDbPolyline")
                             (cons 90 2)
                             (append (list 10) PRI0)
                             (append (list 10) PRI)
                       )
              )
              (setq ENTR (entlast))
              (setq ENTROBJ (vlax-ename->vla-object ENTR))
              (setq C 1)
             )
            )
            (setq P0 P
                  Z0 Z
                  PLI0 PLI
                  PRI0 PRI
            )
            (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (command "'REDRAW")
 nil
);
;
;     Program written by Robert Livingston, 2015-02-20
;
;     C:PGRADE is a routine for finding a polyline with constant grade along a surface between two selected points
;
;
(defun C:PGRADE (/ *error* ANG ANGBASE ANGDIR CMDECHO CONTINUE D DIST2D GETOS GRADE GRSECTION NODE OBSURFACE OGLIST OS OSMODE P P0 P1 P2 PL PR REP STEP SWATH TMP Z0 Z1 Z2)
;(defun C:PGRADE ()
 (command "._UNDO" "M")
 (command "._UCS" "W")
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq ALSAVE RFL:ALIGNLIST)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  (setq RFL:ALIGNLIST ALSAVE)
  ;(setq *error* nil)
  (print msg)
 )

 (defun GETOS (/ C OSBEST L P1 P2 P3 P4 TMP ZBEST)
  (setq OSBEST nil ZBEST nil)
  (setq C 0)
  (while (< (+ C 1) (length OGLIST))
   (setq P1 (nth C OGLIST))
   (setq L (sqrt (+ (expt (car P1) 2) (expt D 2))))
   (setq P3 (list (car P1) (+ Z0 (* L GRADE))))
   (setq P2 (nth (+ C 1) OGLIST))
   (setq L (sqrt (+ (expt (car P2) 2) (expt D 2))))
   (setq P4 (list (car P2) (+ Z0 (* L GRADE))))
   (setq TMP (inters P1 P2 P3 P4))
   (if (/= nil TMP)
    (if (= nil OSBEST)
     (setq OSBEST (car TMP) ZBEST (cadr TMP))
     (if (< (abs (car TMP)) (abs OSBEST))
      (setq OSBEST (car TMP) ZBEST (cadr TMP))
     )
    )
   )
   (setq C (+ C 1))
  )
  (list OSBEST ZBEST)
 )
 
 (defun GRSECTION (/ C H NODE P1 P2 PC PB SCALE)
  (setq PC (getvar "VIEWCTR"))
  (setq H (getvar "VIEWSIZE"))
  (setq PB (list (+ (car PC) (/ H 3.0)) (- (cadr PC) (/ H 4.0))))
  (setq SCALE (/ (/ H 2.0) SWATH))
  (setq C 0)
  (setq P1 (nth C OGLIST))
  (setq P1 (list (+ (car PB) (* SCALE (car P1))) (+ (cadr PB) (* SCALE (- (cadr P1) Z2)))))
  (while (< (+ C 1) (length OGLIST))
   (progn
    (setq P2 (nth (+ C 1) OGLIST))
    (setq P2 (list (+ (car PB) (* SCALE (car P2))) (+ (cadr PB) (* SCALE (- (cadr P2) Z2)))))
    (grdraw P1 P2 -1)
    (setq P1 P2)
    (setq C (+ C 1))
   )
  )
  (setq P1 (list (+ (car PB) (* SCALE (car OS))) (+ (cadr PB) (* SCALE (- (cadr OS) Z2)))))
  (grdraw (list (+ (car P1) (/ H -25.0)) (cadr P1))
          (list (+ (car P1) (/ H 25.0)) (cadr P1)) -1)
  (grdraw (list (car P1) (+ (cadr P1) (/ H -25.0)))
          (list (car P1) (+ (cadr P1) (/ H 25.0))) -1)
 )
 
 (defun DIST2D (P1 P2)
  (distance (list (car P1) (cadr P1)) (list (car P2) (cadr P2)))
 )
 
 (if (/= nil (setq OBSURFACE (RFL:GETC3DSURFACE)))
  (if (/= nil (setq P0 (getpoint "\nStart Point : ")))
   (if (/= nil (setq Z0 (RFL:GETSURFACEPOINT P0 OBSURFACE)))
    (progn
     (setq P0 (list (car P0) (cadr P0)))
     (princ (strcat "\nElevation at start point = " (rtos Z0)))
     (setq P2 (getpoint "\nPick second point for grade reference : "))
     (if (/= nil (setq Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)))
      (progn
       (setq GRADE (* 100.0 (/ (- Z2 Z0) (DIST2D P0 P2))))
       (setq REP (getreal (strcat "\nEnter desired grade (%) <" (rtos GRADE) "> : ")))
       (if (/= nil REP) (setq GRADE REP))
       (setq GRADE (/ GRADE 100.0))
       (setq SWATH 500.0)
       (setq REP (getreal (strcat "\nEnter swath width <" (rtos SWATH) "> : ")))
       (if (/= nil REP) (setq SWATH REP))
       ;(setq STEP 100.0)
       ;(setq REP (getreal (strcat "\nEnter step size <" (rtos STEP) "> : ")))
       ;(if (/= nil REP) (setq STEP REP))
        (setq CONTINUE T)
       (setvar "OSMODE" 0)
       (command "._PLINE" P0)
       (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
       (while (and (or (= 5 (car (setq P1 (grread T))))
                       (= 3 (car P1))
                       (= 2 (car P1))
                   )
                   CONTINUE
              )
        (if (= 2 (car P1))
         (if (= 43 (cadr P1))
          (progn
           (setq GRADE (+ GRADE 0.001))
           (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
          )
          (if (= 45 (cadr P1))
           (progn
            (setq GRADE (- GRADE 0.001))
            (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
           )
           (if (= 13 (cadr P1))
            (setq CONTINUE nil)
            (if (= 32 (cadr P1))
             (setq CONTINUE nil)
            )
           )
          )
         )
         (progn
          (setq P (list (caadr P1) (cadadr P1)))
          (setq ANG (angle P0 P))
          (setq D (DIST2D P0 P))
          (setq P2 nil)
          (setq RFL:ALIGNLIST (list (list 0.0 P0 (list (+ (car P0) (* 2.0 D (cos ANG))) (+ (cadr P0) (* 2.0 D (sin ANG)))) 0.0)))
          (setq PL (RFL:XY (list D (/ SWATH -2.0))))
          (setq PR (RFL:XY (list D (/ SWATH 2.0))))
          (setq OGLIST nil)
          (if (and (/= nil PL) (/= nil PR))
           (progn
            (setq TMP (RFL:GETSURFACELINE PL P OBSURFACE))
            (foreach NODE TMP
             (setq OGLIST (append OGLIST (list (list (* -1.0 (DIST2D NODE P)) (last NODE)))))
            )
            (setq TMP (cdr (RFL:GETSURFACELINE P PR OBSURFACE)))
            (foreach NODE TMP
             (setq OGLIST (append OGLIST (list (list (DIST2D NODE P) (last NODE)))))
            )
           )
          )
          (if (/= nil OGLIST)
           (if (/= nil (car (setq OS (GETOS))))
            (progn
             (command "'REDRAW")
             (if (and (/= nil PL) (/= nil PR)) (grdraw PL PR -1))
             (GRSECTION)
             (setq P2 (RFL:XY (list D (car OS))))
             (setq Z2 (cadr OS))
             (grdraw P0 P2 -1)
            )
           )
          )
          (if (= 3 (car P1))
           (if (/= nil P2)
            (progn
             (command "'REDRAW")
             (setq P0 P2 Z0 Z2)
             (command P0)
             (princ (strcat "\n" (rtos (* GRADE 100.0)) "%, Point : "))
            )
           )
          )
         )
        )
       )
       (command "")
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setq RFL:ALIGNLIST ALSAVE)
 (command "'REDRAW")
 nil
);
;
;     Program written by Robert Livingston, 2015-10-09
;
;     PL2SUPER estimates superelevations based on selected 3D polylines
;
;
(defun C:PL2SUPER (/ *error* ALPLALPLLIST ALSAVE C ENT ENTLIST INC MP:Echo NODE ORTHOMODE OS OSMODE P P1 P2 P3 PC PL PR PLISTCENTER PLISTLEFT PLISTRIGHT PLIST PVIPL PVIPLLIST PVISAVE S STA STAEND SWATH TMP TOL Z Z1 Z2 ZLIST ZMAX)
;(defun C:PL2SUPER ()
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 
 (setq TOL 0.00001)
 
 (defun *error* (msg)
  (setq RFL:ALIGNLIST ALSAVE)
  (setq PVISAVE RFL:PVILIST)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (print msg)
  ;(setq *error* nil)
 )

 (defun MP:Echo ( x / cmdecho millisecs ceiling )

     (cond
         (   (null (setq ceiling 2000 millisecs (getvar 'millisecs)))
         )
         (   (/= 'int (type *MP:Echo:MilliSecs*))
             (setq *MP:Echo:MilliSecs* millisecs)
         )
         (   (< ceiling (- millisecs *MP:Echo:MilliSecs*))
             (setq cmdecho (getvar 'cmdecho))
             (setvar 'cmdecho 0)
             (vl-cmdf ".delay" 0)
             (setvar 'cmdecho cmdecho)
             (setq *MP:Echo:MilliSecs* millisecs)
         )
     )

     (if (eq 'str (type x)) 
         (setvar 'modemacro (vl-string-trim "\n\r\t" x))
     )

     (princ x)

     (princ)

 ) 

 
 (setq ALSAVE RFL:ALIGNLIST)
 (setq PVISAVE RFL:PVILIST)
 (if (= nil RFL:ALIGNLIST)
  (princ "\n!!! NO ALIGNMENT DEFINED !!!\n")
  (progn
   (setq INC 0.0)
   (while (= INC 0.0)
    (setq INC (getdist "\nStation increment <10.0> : "))
    (if (= INC nil) (setq INC 10.0))
   )
   (setq TMP (+ INC (* INC (fix (/ (caar RFL:ALIGNLIST) INC)))))
   (setq STA (getreal (strcat "\nStart Station <" (rtos TMP 2 3) "> : ")))
   (if (= nil STA) (setq STA TMP))
   (setq TMP (* INC (fix (/ (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)) INC))))
   (setq STAEND (getreal (strcat "\nEnd Station <" (rtos TMP 2 3) "> : ")))
   (if (= nil STAEND) (setq STAEND TMP))
   (setq ALPLLIST nil)
   (setq PVIPLLIST nil)
   (while (/= nil (setq ENT (car (entsel "\nSelect Polyline : "))))
    (setq ENTLIST (entget ENT))
    (if (= (cdr (assoc 0 ENTLIST)) "POLYLINE")
     (if (/= 0 (logand (cdr (assoc 70 ENTLIST)) 8))
      (progn
       (setq ALPL nil)
       (setq PVIPL nil)
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P1 nil)
       (setq Z1 nil)
       (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
        (setq P2 (cdr (assoc 10 ENTLIST)))
        (setq Z2 (caddr P2))
        (if (= Z2 nil) (setq Z2 0.0))
        (setq P2 (list (car P2) (cadr P2)))
        (if (/= P1 nil)
         (if (= nil ALPL)
          (setq ALPL (list (list 0.0 P1 P2 0.0)))
          (setq ALPL (append ALPL (list (list (+ (car (last ALPL)) (distance (cadr (last ALPL)) (caddr (last ALPL)))) P1 P2 0.0))))
         )
        )
        (if (= nil PVIPL)
         (setq PVIPL (list (list 0.0 Z2 "L" 0.0)))
         (setq PVIPL (append PVIPL (list (list (+ (car (last ALPL)) (distance P1 P2)) Z2 "L" 0.0))))
        )
        (setq P1 P2)
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
       )
       (setq ALPLLIST (append ALPLLIST (list ALPL)))
       (setq PVIPLLIST (append PVIPLLIST (list PVIPL)))
      )
      (princ "\n!!! NOT a 3D POLYLINE !!!\n")
     )
    )
   )
   (if (/= nil ALPLLIST)
    (progn
     (setq SWATH (getdist "\nSwath with <100.0> : "))
     (if (= nil SWATH) (setq SWATH 100.0))
     (setq RFL:SUPERLIST nil)
     (while (<= STA STAEND)
      (setq RFL:ALIGNLIST ALSAVE)
      (setq P1 (RFL:XY (list STA (/ SWATH -2.0))))
      (setq P2 (RFL:XY (list STA (/ SWATH 2.0))))
      (setq PLIST nil)
      (setq ZLIST nil)
      (setq C 0)
      (while (< C (length ALPLLIST))
       (setq RFL:ALIGNLIST (nth C ALPLLIST))
       (setq RFL:PVILIST (nth C PVIPLLIST))
       (setq P (RFL:ALINTERS P1 P2 RFL:ALIGNLIST))
       (if (/= nil P)
        (progn
         (setq Z (RFL:ELEVATION (car (RFL:STAOFF P))))
         (if (/= nil Z)
          (progn
           (setq PLIST (append PLIST (list P)))
           (setq ZLIST (append ZLIST (list Z)))
          )
         )
        )
       )
       (setq C (+ C 1))
      )
      (setq RFL:ALIGNLIST ALSAVE)
      (if (and (= 3 (length PLIST)) (= 3 (length ZLIST)))
       (progn
        (setq PL (append (RFL:STAOFF (nth 0 PLIST)) (list (nth 0 ZLIST))))
        (setq PC (append (RFL:STAOFF (nth 1 PLIST)) (list (nth 1 ZLIST))))
        (setq PR (append (RFL:STAOFF (nth 2 PLIST)) (list (nth 2 ZLIST))))
        (setq RFL:SUPERLIST (append RFL:SUPERLIST (list (list STA
                                                              (* -100.0 (/ (- (caddr PC) (caddr PL)) (- (cadr PC) (cadr PL))))
                                                              (* 100.0 (/ (- (caddr PC) (caddr PR)) (- (cadr PC) (cadr PR))))
                                                        )
                                                  )
                            )
        )
       )
      )
      (MP:Echo (strcat "\nSta : " (RFL:STATXT STA)))
      ;(princ (strcat "\nSta : " (RFL:STATXT STA)))
      (setq STA (+ STA INC))
     )
    )
   )
  )
 )
 (setq RFL:ALIGNLIST ALSAVE)
 (setq PVISAVE RFL:PVILIST)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 T
);
;
;     Program written by Robert Livingston - 2015-07-29
;
;     C:PL2TANGENT is a routine for fitting an alignment to a selected polyline
;
;
(defun C:PL2TANGENT (/ ENT ENTLIST MINTANCOUNT MINTANOS ORTHOMODE OSMODE PLIST PLISTALL PLISTPART PREVENT SUBLINE SUBLINEBEST)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (defun PLISTPART (PLIST C1 C2 / TEMPLIST)
  (setq TEMPLIST nil)
  (if (and (< C1 (length PLIST)) (< C2 (length PLIST)) (<= C1 C2))
   (while (<= C1 C2)
    (setq TEMPLIST (append TEMPLIST (list (nth C1 PLIST))))
    (setq C1 (1+ C1))
   )
  )
  TEMPLIST
 )
 (setq PLISTALL nil)
 (setq ENT (car (entsel "\nSelect polyline to fit line : ")))
 (setq ENTLIST (entget ENT))
 (if (= "LWPOLYLINE" (cdr (assoc 0 ENTLIST)))
  (while (/= nil ENTLIST)
   (if (= 10 (caar ENTLIST))
    (setq PLISTALL (append PLISTALL (list (cdar ENTLIST))))
   )
   (setq ENTLIST (cdr ENTLIST))
  )
  (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
   (progn
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (= "VERTEX" (cdr (assoc 0 ENTLIST)))
     (setq P (cdr (assoc 10 ENTLIST)))
     (setq PLISTALL (append PLISTALL (list (list (car P) (cadr P)))))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
   (princ "\n*** Not a polyline!")
  )
 )
 (if (= nil PLISTALL)
  (princ "\n!!! Problem finding vertexes !!!")
  (progn
   (setq PREVENT nil)
   (setq MINTANCOUNT (getint "\nEnter minimum number of tangent vertexes <5> : "))
   (if (= nil MINTANCOUNT) (setq MINTANCOUNT 5))
   (setq MINTANOS (getdist "\nEnter minimum tangent offset <0.5> : "))
   (if (= nil MINTANOS) (setq MINTANOS 0.5))
   (setq C1 0)
   (while (< C1 (- (length PLISTALL) MINTANCOUNT))
    (setq C2 (+ C1 MINTANCOUNT -1))
    (setq SUBLINEBEST nil)
    (setq SUBLINE (RFL:BESTLINE (PLISTPART PLISTALL C1 C2)))
    (while (and (/= nil SUBLINE) (< C2 (length PLISTALL)) (<= (last SUBLINE) MINTANOS))
     (setq SUBLINEBEST SUBLINE)
     (setq C2 (1+ C2))
     (setq SUBLINE (RFL:BESTLINE (PLISTPART PLISTALL C1 C2)))
    )
    (princ (strcat "\nC1 = " (itoa C1) ", C2 = " (itoa C2) ", OS = " (if (/= nil SUBLINE) (rtos (last SUBLINE)) "nil")))
    (if (/= nil SUBLINEBEST)
     (progn
      (entmake (list (cons 0 "LINE")
                     (list 10 (car (nth 0 SUBLINEBEST)) (cadr (nth 0 SUBLINEBEST)) 0.0)
                     (list 11 (car (nth 1 SUBLINEBEST)) (cadr (nth 1 SUBLINEBEST)) 0.0)
               )
      )
      (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
     )
    )
    (if (= nil SUBLINEBEST)
     (setq C1 (1+ C1))
     (setq C1 C2)
    )
   )
  )
 )
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 T
);
;
;   Program written by Robert Livingston, 99/07/14
;
;   C:POFFSET offsets an arc a calculated spiral 'P' distance
;   Modified 02/04/18 - presets the offset distance and starts the offset command
;                     - works for compound spirals
;
;
(defun C:POFFSET (/ A AL CMDECHO ENT ENTLIST LS1 LS2 P PCEN1 PCEN2 R1 R2 THETA1 THETA2)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq R1 nil)
 (if (/= (setq ENT (car (entsel "\nSelect first arc or circle (<return> to enter radius) :"))) nil)
  (progn
   (setq ENTLIST (entget ENT))
   (if (or (= (cdr (assoc 0 ENTLIST)) "ARC")
           (= (cdr (assoc 0 ENTLIST)) "CIRCLE"))
    (progn
     (setq R1 (cdr (assoc 40 ENTLIST)))
    )
   )
  )
 )
 (if (= R1 nil)
  (progn
   (setq R1 (getdist "\nEnter radius : "))
  )
 )
 (setq R2 nil)
 (if (/= (setq ENT (car (entsel "\nSelect second arc or circle (<return> to enter radius) :"))) nil)
  (progn
   (setq ENTLIST (entget ENT))
   (if (or (= (cdr (assoc 0 ENTLIST)) "ARC")
           (= (cdr (assoc 0 ENTLIST)) "CIRCLE"))
    (progn
     (setq R2 (cdr (assoc 40 ENTLIST)))
    )
   )
  )
 )
 (if (= R2 nil)
  (progn
   (setq R2 (getdist "\nEnter radius (<return> for simple spiral) : "))
  )
 )
 (if (= R2 nil)
  (progn
   (setq LS nil)
   (setq AL "L")
   (while (= LS nil)
    (if (= AL "L")
     (progn
      (setq LS (getreal "\nEnter spiral length <return for A>:"))
      (if (= LS nil)
       (progn
        (setq AL "A")
       )
      )
     )
     (progn
      (setq LS (getreal "\nEnter spiral A <return for length>:"))
      (if (= LS nil)
       (progn
        (setq AL "L")
       )
       (progn
        (setq LS (/ (* LS LS) R1))
       )
      )
     )
    )
   )
   (setq THETA1 (/ LS R1 2.0))
   (setq P (* R1 (RFL:SPIRALPR THETA1)))
   (command "_OFFSET" P)
  )
  (progn
   (setq LS nil)
   (setq AL "L")
   (setq A nil)
   (while (= LS nil)
    (if (= AL "L")
     (progn
      (setq LS (getreal "\nEnter spiral length <return for A>:"))
      (if (= LS nil)
       (progn
        (setq AL "A")
       )
       (progn
        (setq A (sqrt (abs (/ (* LS R1 R2) (- R2 R1)))))
       )
      )
     )
     (progn
      (setq LS (getreal "\nEnter spiral A <return for length>:"))
      (if (= LS nil)
       (progn
        (setq AL "L")
       )
       (progn
        (setq A LS)
        (setq LS (abs (* (* LS LS) (/ (- R2 R1) (* R1 R2)))))
       )
      )
     )
    )
   )
   (setq THETA1 (/ (* A A) (* 2 R1 R1)))
   (setq PCEN1 (list (* R1 (- (RFL:SPIRALFXR THETA1) (sin THETA1)))
                     (* R1 (+ (RFL:SPIRALFYR THETA1) (cos THETA1)))))
   (setq THETA2 (/ (* A A) (* 2 R2 R2)))
   (setq PCEN2 (list (* R2 (- (RFL:SPIRALFXR THETA2) (sin THETA2)))
                     (* R2 (+ (RFL:SPIRALFYR THETA2) (cos THETA2)))))
   (setq P (- (abs (- R1 R2)) (distance PCEN1 PCEN2)))
   (command "_OFFSET" P)
  )
 )

 (setvar "CMDECHO" CMDECHO)
) ;
;
;     Program written by Robert Livingston, 2015-02-20
;
;     C:PPGRADE is a routine for finding a polyline with constant grade along a surface between two selected points
;
;
(defun C:PPGRADE (/ *error* ALSAVE ANG ANGBASE ANGDIR C CMDECHO D GETL GETOS INC L NODE NSEGS OBSURFACE OGLIST OS OSLIST OSMAX OSMODE P1 P2 REP SLOPE SWATH TMP TOL Z Z1 Z2)
;(defun C:PPGRADE ()
 (command "._UNDO" "M")
 (command "._UCS" "W")
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq ALSAVE RFL:ALIGNLIST)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  (setq RFL:ALIGNLIST ALSAVE)
  ;(setq *error* nil)
  (print msg)
 )

 (defun GETOS (Z PLIST OS / C OSBEST P1 P2 TMP)
  (setq OSBEST nil)
  (setq P1 (list (/ SWATH -2.0) Z))
  (setq P2 (list (/ SWATH 2.0) Z))
  (setq C 0)
  (while (< (+ C 1) (length PLIST))
   (setq TMP (inters P1 P2 (nth C PLIST) (nth (+ C 1) PLIST)))
   (if (/= nil TMP)
    (if (= nil OSBEST)
     (setq OSBEST (car TMP))
     (if (< (abs (- (car TMP) OS)) (abs OSBEST))
      (setq OSBEST (car TMP))
     )
    )
   )
   (setq C (+ C 1))
  )
  (eval OSBEST)
 )
 
 (defun GETL (/ C L)
  (setq L 0.0)
  (setq C 1)
  (while (< C (length OSLIST))
   (setq L (+ L (sqrt (+ (expt INC 2) (expt (- (nth C OSLIST) (nth (- C 1) OSLIST)) 2)))))
   (setq C (+ C 1))
  )
  (setq L (+ L (sqrt (+ (expt INC 2) (expt (nth (- C 1) OSLIST) 2)))))
 )
 
 (setq TOL 0.1)
 (setq MAXOS (* 2.0 TOL))
 
 (if (/= nil (setq P1 (getpoint "\nFirst point : ")))
  (if (/= nil (setq P2 (getpoint "\nSecond point : ")))
   (if (/= nil (setq OBSURFACE (RFL:GETC3DSURFACE)))
    (progn
     (setq P1 (list (car P1) (cadr P1)))
     (setq Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE))
     (setq P2 (list (car P2) (cadr P2)))
     (setq Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE))
     (setvar "OSMODE" 0)
     (setq D (distance P1 P2))
     (setq NSEGS 0)
     (while (< NSEGS 2)
      (setq NSEGS (getint "\nNumber of segments (2 minimum) <10> : "))
      (if (= nil NSEGS) (setq NSEGS 10))
     )
     (setq INC (/ D NSEGS))
     (setq NSEGS (- NSEGS 1))
     (setq SWATH (float (fix (/ D NSEGS))))
     (setq SWATH 500.0)
     (setq REP (getdist (strcat "\nEnter swath width : <" (rtos SWATH) "> : ")))
     (if (/= nil REP) (setq SWATH REP))
     (setq RFL:ALIGNLIST (list (list 0.0 P1 P2 0.0)))
     (setq TMP (RFL:GETSECTIONSET INC
                                  (* INC NSEGS)
                                  SWATH
                                  INC
                                  OBSURFACE
                                  RFL:ALIGNLIST
               )
     )
     (setq OSLIST (list 0.0))
     (setq OGLIST nil)
     (setq C 0)
     (while (< C NSEGS)
      (setq OGLIST (append OGLIST (list (cadr (nth C TMP)))))
      (setq OSLIST (append OSLIST (list 0.0)))
      (setq C (+ C 1))
     )
     (while (> MAXOS TOL)
      (setq MAXOS nil)
      (setq TMP (list 0.0))
      (setq SLOPE (/ (- Z2 Z1) (GETL)))
      (setq L 0.0)
      (setq Z Z1)
      (setq C 1)
      (while (< C (length OSLIST))
       (setq L (sqrt (+ (expt INC 2) (expt (- (nth C OSLIST) (nth (- C 1) OSLIST)) 2))))
       (setq Z (+ Z (* SLOPE L)))
       (setq OS (GETOS Z (nth (- C 1) OGLIST) (nth C OSLIST)))
       (setq TMP (append TMP (list OS)))
       (if (= nil MAXOS)
        (setq MAXOS (abs (- OS (nth C OSLIST))))
        (if (> (abs (- OS (nth C OSLIST))) MAXOS)
         (setq MAXOS (abs (- OS (nth C OSLIST))))
        )
       )
       (setq C (+ C 1))
      )
      (setq OSLIST TMP)
     )
     (princ (strcat "\nFinal slope = " (rtos (* SLOPE 100.0)) "%"))
     (command "._PLINE" P1)
     (setq C 1)
     (while (< C (length OSLIST))
      (command (RFL:XY (list (* C INC) (nth C OSLIST))))
      (setq C (+ C 1))
     )
     (command P2 "")
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setq RFL:ALIGNLIST ALSAVE)
 (eval nil)
)
;
;
;     Program written by Robert Livingston, 2016/07/11
;
;     C:PVI0 draws a pviblock with 0.0 for K and L at the selected point
(defun C:PVI0 (/ ACTIVEDOC ACTIVESPACE P)
 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )
 (if (setq P (getpoint "\nSelect point : "))
  (progn
   (if (= nil (tblsearch "BLOCK" "PVI2")) (RFL:MAKEENT "PVI2"))
   (vla-insertblock ACTIVESPC
                    (vlax-3D-point P)
                    "PVI2"
                    25.4
                    25.4
                    25.4
                    0.0
   )
   (entlast)
  )
  nil
 )
)
;
;
;     Program written by Robert Livingston, 2008-11-04
;
;     RAB loads hor/vrt/E/OG from a selected RFLALign block
;
;
(defun C:RAB (/ BLKENT BLKENTLIST CMDECHO)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (progn
   (RFL:RALIGNB BLKENT)
   (RFL:RPROFB BLKENT)
   (RFL:RSUPERB BLKENT)
   (RFL:RPROFOGB BLKENT)
  )
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;     Program written by Robert Livingston, 2008-11-04
;
;     RABKILL removes alignment definition lists from RFLALIGN blocks
;
;
(defun C:RABKILL (/ ENT)
 (command "._UNDO" "M")
 (setq ENT (car (entsel "\nSelect Alignment Block : ")))
 (RFL:RABKILL ENT "HOR")
 (setq ENT (entlast))
 (RFL:RABKILL ENT "VRT")
 (setq ENT (entlast))
 (RFL:RABKILL ENT "OG")
 (setq ENT (entlast))
 (RFL:RABKILL ENT "E")
)
;
;
;     Program written by Robert Livingston, 2008-11-04
;
;     RAB loads hor/vrt/E/OG from a selected nested RFLALign block
;
;
(defun C:RABN (/ BLKENT BLKENTLIST CMDECHO)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (nentsel "\nSelect nested RFL Alignment Block : ")))
 (setq BLKENT (cdr (assoc 330 (entget BLKENT))))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (/= nil (vl-string-search "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST))))))
  (progn
   (RFL:RALIGNB BLKENT)
   (RFL:RPROFB BLKENT)
   (RFL:RSUPERB BLKENT)
   (RFL:RPROFOGB BLKENT)
  )
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 98/06/11
;
;   RALIGN reads a horizontal alignment from file
;
;
(defun C:RALIGN (/ ANGBASE ANGDIR CMDECHO INFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
  (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
 )
 (setq INFILENAME (getfiled "Select a Horizontal Alignment File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "hor" 2))
 (RFL:RALIGN INFILENAME)
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   RALIGNB reads a horizontal alignment from a RFLAlign Block
;
;
(defun C:RALIGNB (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (RFL:RALIGNB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   RALIGNBN reads a horizontal alignment from a nested RFLAlign Block
;
;
(defun C:RALIGNBN (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (nentsel "\nSelect nested RFL Alignment Block : ")))
 (setq BLKENT (cdr (assoc 330 (entget BLKENT))))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (/= nil (vl-string-search "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST))))))
  (RFL:RALIGNB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;     Program written by Robert Livingston, 10-04-30
;
;     RALIGNC3D reads the alignment from a selected C3D alignment
;     NOTE - Must be using C3D, will not work in straight AutoCAD
;     NOTE - Works for type 1, type 2, type 3 and type 4 alignment entities
;
;
(defun C:RALIGNC3D (/ *error* ALSAVE C CMAX CMDECHO E1 E2 ENT ENTITY ENTLIST NODE
                      OBALIGNMENT OBENTITIES SETARC SETSPIRAL SETTANGENT SPIRALENTITY STA STALIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (= nil vlax-create-object) (vl-load-com))

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  ;(setq *error* nil)
  (princ msg)
 )

 (defun SETTANGENT (ENTITY / P1 P2)
  (setq P1 (list (vlax-get-property ENTITY "StartEasting")
                 (vlax-get-property ENTITY "StartNorthing")
           )
  )
  (setq P2 (list (vlax-get-property ENTITY "EndEasting")
                 (vlax-get-property ENTITY "EndNorthing")
           )
  )
  (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list (vlax-get-property ENTITY "StartingStation") P1 P2 0.0))))
 )

 (defun SETARC (ENTITY / P1 P2 PC CCW R ANG BULGE)
  (setq P1 (list (vlax-get-property ENTITY "StartEasting")
                 (vlax-get-property ENTITY "StartNorthing")
           )
  )
  (setq P2 (list (vlax-get-property ENTITY "EndEasting")
                 (vlax-get-property ENTITY "EndNorthing")
           )
  )
  (setq PC (list (vlax-get-property ENTITY "CenterEasting")
                 (vlax-get-property ENTITY "CenterNorthing")
           )
  )
  (setq CCW (vlax-get-property ENTITY "Clockwise"))
  (setq R (vlax-get-property ENTITY "Radius"))
  (setq ANG (vlax-get-property ENTITY "Delta"))
  (setq BULGE (RFL:TAN (/ ANG 4.0)))
  (if (= :vlax-true CCW) (setq BULGE (* -1.0 BULGE)))
  (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list (vlax-get-property ENTITY "StartingStation") P1 P2 BULGE))))
 )

 (defun SETSPIRAL (ENTITY / A ANG BULGE L0 LT P1 P2 PLTST PINT PST RIN ROUT ST THETA TMP X Y)
  (setq RIN (vlax-get-property ENTITY "RadiusIn"))
  (setq ROUT (vlax-get-property ENTITY "RadiusOut"))
  (setq TMP (/ 1.0 (max RIN ROUT)))
  ;(setq TMP (vlax-get-property ENTITY "Compound"))
  ;(if (= TMP :vlax-false)
  (if (< TMP RFL:TOL)
   (progn
    (setq P1 (list (vlax-get-property ENTITY "StartEasting")
                   (vlax-get-property ENTITY "StartNorthing")
             )
    )
    (setq P2 (list (vlax-get-property ENTITY "EndEasting")
                   (vlax-get-property ENTITY "EndNorthing")
             )
    )
    (setq PLTST (list (vlax-get-property ENTITY "SPIEasting")
                      (vlax-get-property ENTITY "SPINorthing")
                )
    )
    (setq LO 0.0)
    (if (< (distance P2 PLTST) (distance P1 PLTST))
     (setq PLT P1 PST P2)
     (setq PLT P2 PST P1)
    )
    (setq BULGE (list PLT PLTST PST LO))
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list (vlax-get-property ENTITY "StartingStation") P1 P2 BULGE))))
   )
   (progn
    (setq P1 (list (vlax-get-property ENTITY "StartEasting")
                   (vlax-get-property ENTITY "StartNorthing")
             )
    )
    (setq P2 (list (vlax-get-property ENTITY "EndEasting")
                   (vlax-get-property ENTITY "EndNorthing")
             )
    )
    (setq PINT (list (vlax-get-property ENTITY "SPIEasting")
                     (vlax-get-property ENTITY "SPINorthing")
               )
    )
    (setq RIN (vlax-get-property ENTITY "RadiusIn"))
    (setq ROUT (vlax-get-property ENTITY "RadiusOut"))
    (setq A (vlax-get-property ENTITY "A"))
    (if (< RIN ROUT)
     (progn
      (setq THETA (/ (* A A) (* 2.0 RIN RIN)))
      (setq PST P1)
      ;(setq LO (- (/ (* A A) RIN) (vlax-get-property ENTITY "Length")))
      (setq LO (/ (* A A) ROUT))
      (setq ANG (angle PST PINT))
      (setq X (* RIN (RFL:SPIRALFXR THETA)))
      (setq Y (* RIN (RFL:SPIRALFYR THETA)))
      (setq ST (/ Y (sin THETA)))
      (setq LT (- X (/ Y (RFL:TAN THETA))))
      (setq PLTST (list (+ (car PST) (* ST (cos ANG)))
                        (+ (cadr PST) (* ST (sin ANG)))))
      (if (> (sin (- (angle PINT P2) (angle P1 PINT))) 0.0)
       (setq ANG (+ ANG THETA))
       (setq ANG (- ANG THETA))
      )
      (setq PLT (list (+ (car PLTST) (* LT (cos ANG)))
                      (+ (cadr PLTST) (* LT (sin ANG)))))
     )
     (progn
      (setq THETA (/ (* A A) (* 2.0 ROUT ROUT)))
      (setq PST P2)
      ;(setq LO (- (/ (* A A) ROUT) (vlax-get-property ENTITY "Length")))
      (setq LO (/ (* A A) RIN))
      (setq ANG (angle PST PINT))
      (setq X (* ROUT (RFL:SPIRALFXR THETA)))
      (setq Y (* ROUT (RFL:SPIRALFYR THETA)))
      (setq ST (/ Y (sin THETA)))
      (setq LT (- X (/ Y (RFL:TAN THETA))))
      (setq PLTST (list (+ (car PST) (* ST (cos ANG)))
                        (+ (cadr PST) (* ST (sin ANG)))))
      (if (> (sin (- (angle PINT P1) (angle P2 PINT))) 0.0)
       (setq ANG (+ ANG THETA))
       (setq ANG (- ANG THETA))
      )
      (setq PLT (list (+ (car PLTST) (* LT (cos ANG)))
                      (+ (cadr PLTST) (* LT (sin ANG)))))
     )
    )
    (setq BULGE (list PLT PLTST PST LO))
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list (vlax-get-property ENTITY "StartingStation") P1 P2 BULGE))))
   )
  )
 )

 (setq OBALIGNMENT (RFL:GETC3DALIGNMENT))
 (if (/= OBALIGNMENT nil) 
  (progn
   (setq RFL:ALIGNLIST nil)
   (setq OBENTITIES (vlax-get-property OBALIGNMENT "Entities"))
   (setq CMAX (vlax-get-property OBENTITIES "Count"))
   (setq C 0)
   (while (< C CMAX)
    (setq ENTITY (vlax-invoke-method OBENTITIES "Item" C))
    (cond
     ((= 1 (vlax-get-property ENTITY "Type"))
      (progn
       (SETTANGENT ENTITY)
      )
     )
     ((= 2 (vlax-get-property ENTITY "Type"))
      (progn
       (SETARC ENTITY)
      )
     )
     ((= 3 (vlax-get-property ENTITY "Type"))
      (progn
       (SETSPIRAL ENTITY)
      )
     )
     ((= 4 (vlax-get-property ENTITY "Type"))
      (progn
       (SETSPIRAL (vlax-get-property ENTITY "SpiralIn"))
       (SETARC (vlax-get-property ENTITY "Arc"))
       (SETSPIRAL (vlax-get-property ENTITY "SpiralOut"))
      )
     )
     ((= 8 (vlax-get-property ENTITY "Type"))
      (progn
       (SETSPIRAL (vlax-get-property ENTITY "SpiralIn"))
       (SETARC (vlax-get-property ENTITY "ArcOut"))
      )
     )
     ((= 9 (vlax-get-property ENTITY "Type"))
      (progn
       (SETARC (vlax-get-property ENTITY "ArcIn"))
       (SETSPIRAL (vlax-get-property ENTITY "SpiralOut"))
      )
     )
     ((= 12 (vlax-get-property ENTITY "Type"))
      (progn
       (SETSPIRAL (vlax-get-property ENTITY "Spiral1"))
       (SETARC (vlax-get-property ENTITY "Arc1"))
       (SETSPIRAL (vlax-get-property ENTITY "Spiral2"))
       (SETARC (vlax-get-property ENTITY "Arc2"))
       (SETSPIRAL (vlax-get-property ENTITY "Spiral3"))
      )
     )
    )
    (setq C (1+ C))
   )
  )
 )

 (setq ALSAVE RFL:ALIGNLIST RFL:ALIGNLIST nil)
 (if (/= nil ALSAVE)
  (progn
   (setq STALIST nil)
   (foreach NODE ALSAVE
    (setq STALIST (append STALIST (list (car NODE))))
   )
   (setq STALIST (vl-sort STALIST '<))
   (foreach STA STALIST
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (assoc STA ALSAVE))))
   )
  )
 )
 
 (setvar "CMDECHO" CMDECHO)
);
;
;    Program written by Robert Livingston, 95/04/25
;                                 Revised, 98/05/12
;
;    RNE labels the Northing and Easting
;
;
(setq RFL:RNELIST (list (cons "NE" 1)   ;  Label Northing and Easting
                        (cons "SO" 1)   ;  Label Station and Offset
                        (cons "Z" 1)    ;  Label Control Elevations
                        (cons "G" 1)    ;  Label Control Grades
                        (cons "SE" 1)   ;  Label Superelevations
                 )
)
(defun C:RNE (/ P1 P2)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq P1 (getpoint "\nEnter point :"))
 (setq P2 (getpoint P1 "Second point for leader :"))
 (RFL:RNE P1 P2)

 (setvar "CMDECHO" CMDECHO)
)
(defun RFL:RNE (P1 P2 / *error* ANGBASE ANGDIR CMDECHO ENT ENTLIST G OFFSET P3
                        S STA STR STRLIST TMP Z)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (alert msg)
  ;(setq *error* nil)
 )

 (setq STRLIST nil
       STA nil
       OFFSET nil
       G nil
       Z nil
 )
 (if (setq STA (RFL:STAOFF P1))
  (setq OFFSET (cadr STA)
        STA (car STA)
        Z (RFL:ELEVATION STA)
        G (RFL:SLOPE STA)
        S (RFL:SUPER STA)
  )
 )
 (if (and (= (cdr (assoc "NE" RFL:RNELIST)) 1)
          P1
     )
  (setq STRLIST (append STRLIST (list (strcat "N " (rtos (cadr P1)) ", E " (rtos (car P1))))))
 )
 (if (and (= (cdr (assoc "SO" RFL:RNELIST)) 1)
          STA
          OFFSET
     )
  (setq STRLIST (append STRLIST (list (strcat "Sta." (RFL:STATXT STA) ", O/S " (rtos OFFSET)))))
 )
 (if (and (= (cdr (assoc "Z" RFL:RNELIST)) 1)
          Z
     )
  (setq STRLIST (append STRLIST (list (strcat "Ctrl Elev " (rtos Z)))))
 )
 (if (and (= (cdr (assoc "G" RFL:RNELIST)) 1)
          G
     )
  (setq STRLIST (append STRLIST (list (strcat "Ctrl grade " (rtos (* 100.0 G)) "%"))))
 )
 (if (and (= (cdr (assoc "SE" RFL:RNELIST)) 1)
          S
     )
  (setq STRLIST (append STRLIST (list (strcat "Ctrl Super: L:"
                                              (rtos (abs (nth 0 S)))
                                              "%"
                                              (if (= (RFL:SIGN (nth 0 S)) 1) " up" " down")
                                              ", R:"
                                              (rtos (abs (nth 1 S)))
                                              "%"
                                              (if (= (RFL:SIGN (nth 1 S)) 1) " up" " down")
                                      )
                                )
                )
  )
 )
 (if STRLIST
  (progn
   (command "LEADER" "_NON" P1 "_NON" P2 "")
   (foreach STR STRLIST
    (command STR)
   )
   (command "")
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;   Program written by Robert Livingston, 98/05/13
;
;   C:RPROF reads a vertical alignment from file
;
;
(defun C:RPROF (/ CMDECHO INFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
  (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
 )
 (setq INFILENAME (getfiled "Select a Vertical Alignment File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "vrt" 2))
 (RFL:RPROF INFILENAME)
 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RPROFB reads a vertical profile from a RFLAlign Block
;
;
(defun C:RPROFB (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (RFL:RPROFB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RPROFBN reads a vertical profile from a nested RFLAlign Block
;
;
(defun C:RPROFBN (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (nentsel "\nSelect nested RFL Alignment Block : ")))
 (setq BLKENT (cdr (assoc 330 (entget BLKENT))))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (/= nil (vl-string-search "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST))))))
  (RFL:RPROFB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;     Program written by Robert Livingston, 11-03-09
;
;     RPROF3D reads the profile from a selected C3D profile
;     NOTE - Must be using C3D, will not work in straight AutoCAD
;     NOTE - Works for type 1 and type 3 vertical curves
;
;
(defun C:RPROFC3D (/ *error* ENT)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  ;(setq *error* nil)
  (princ msg)
 )

 (if (setq ENT (car (entsel "\nSelect C3D profile : ")))
  (RFL:RPROFC3D ENT)
 )

 (setvar "CMDECHO" CMDECHO)
 T
);
;
;   Program written by Robert Livingston, 98/05/13
;
;   C:RPROFOG reads an OG vertical alignment from file and sets the global variable RFL:OGLIST
;
;
(defun C:RPROFOG (/ CMDECHO INFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq INFILENAME (getfiled "Select an OG Vertical Alignment File" "" "vrt" 2))
 (RFL:RPROFOG INFILENAME)
 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RPROFOGB reads a vertical OG profile from a RFLAlign Block
;
;
(defun C:RPROFOGB (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (RFL:RPROFOGB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RPROFOGBN reads a vertical OG profile from a nested RFLAlign Block
;
;
(defun C:RPROFOGBN (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (nentsel "\nSelect nested RFL Alignment Block : ")))
 (setq BLKENT (cdr (assoc 330 (entget BLKENT))))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (/= nil (vl-string-search "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST))))))
  (RFL:RPROFOGB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   RSUPER reads the Superelevation from file
;
;
(defun C:RSUPER (/ CMDECHO INFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
  (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
 )
 (setq INFILENAME (getfiled "Select a Superelevation File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "e" 2))
 (RFL:RSUPER INFILENAME)
 (setvar "CMDECHO" CMDECHO)
 nil
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RSUPERB reads the Superelevation from a RFLAlign Block
;
;
(defun C:RSUPERB (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (RFL:RSUPERB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008-11-04
;
;   RSUPERBN reads the Superelevation from a nested RFLAlign Block
;
;
(defun C:RSUPERBN (/ CMDECHO BLKENT BLKENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (nentsel "\nSelect nested RFL Alignment Block : ")))
 (setq BLKENT (cdr (assoc 330 (entget BLKENT))))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (/= nil (vl-string-search "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST))))))
  (RFL:RSUPERB BLKENT)
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;     Program written by Robert Livingston, 03-06-11
;     Modified 2014-11-07 to store ramp details into nose and add functionality
;
;     C:RAMP is a utility for drawing exit and entrance ramp tapers
;
;     C:RAMPTAPERLABEL : Toggles labelling of taper
;     C:MOVENOSE       : Moves the nose to a new location
;     C:UPDATENODE     : Updates the nose to it's current location
;     C:SETNOSE        : Sets nos to it's current location
;     C:ERASENOSE      : Erases the nose
;     RFL:RAMPPUTXDATA : Adds extended data to entity
;     RFL:RAMPGETXDATA : Reads extended data from entity
;
(setq RFL:RAMPTAPERLABEL T)
(defun C:RAMPTAPERLABEL ()
 (if RFL:RAMPTAPERLABEL (setq RFL:RAMPTAPERLABEL nil) (setq RFL:RAMPTAPERLABEL T))
)
(setq RFL:RAMPLIST (list (cons "LANEOFFSET" 0.0)
                         (cons "RAMPTAPER" 20.0)
                         (cons "RAMPTAPERENTRANCE" 40.0)
                         (cons "RAMPTAPEREXIT" 20.0)
                         (cons "RAMPVERTICIES" 50)
                         (cons "WEAVEOFFSET" 8.5)
                         (cons "WEAVEOFFSETENTRANCESINGLE" 5.3)
                         (cons "WEAVEOFFSETENTRANCEDUAL" 7.9)
                         (cons "WEAVEOFFSETEXITSINGLE" 8.5)
                         (cons "WEAVEOFFSETEXITDUAL" 11.1)
                         (cons "GOREWIDTH" 5.5)
                         (cons "GOREWIDTHENTRANCESINGLE" 5.3)
                         (cons "GOREWIDTHENTRANCEDUAL" 7.9)
                         (cons "GOREWIDTHEXITSINGLE" 5.5)
                         (cons "GOREWIDTHEXITDUAL" 8.1)
                         (cons "TAPEROFFSET" 0.5)
                         (cons "TAPEROFFSETENTRANCE" 0.0)
                         (cons "TAPEROFFSETEXIT" 0.5)
                         (cons "INSIDEVERTICIES" 25)
                         (cons "NOSESTATION" 0.0)
                         (cons "NOSEOFFSET" 3.0)
                         (cons "NOSERADIUS" 1.1)
                         (cons "NOSERADIUSENTRANCE" 0.6)
                         (cons "NOSERADIUSEXIT" 1.1)
                         (cons "INSIDESHOULDER" 1.0)
                         (cons "INSIDESHOULDERSINGLE" 1.0)
                         (cons "INSIDESHOULDERDUAL" 2.0)
                         (cons "LANEWIDTH" 4.8)
                         (cons "LANEWIDTHSINGLE" 4.8)
                         (cons "LANEWIDTHDUAL" 7.4)
                         (cons "RETURNTAPER" 20.0)
                         (cons "RETURNOFFSET" 3.0)
                         (cons "RETURNVERTICIES" 10)
                         (cons "SINGLELANE" "1")
                         (cons "DUALLANE" "0")
                         (cons "UPCHAINAGE" "1")
                         (cons "DOWNCHAINAGE" "0")
                         (cons "RIGHTSIDE" "1")
                         (cons "LEFTSIDE" "0")
                         (cons "EXITTERMINAL" "1")
                         (cons "ENTRANCETERMINAL" "0")))
(defun C:RAMP (/ *error* ACCEPTRAMP ALSAVE ANGBASE ANGDIR C CANCEL CANCELRAMP CLAYER
                 CMDECHO D1 D2 DCL_ID DIMZIN ENTNOSE ENTNOSELIST FIXNUMBER
                 INITIATE ORTHOMODE OSMODE RERUN SETDUALLANE SETENTRANCE SETEXIT
                 SETSINGLELANE TEMPRAMPLIST)

 (command "._UNDO" "M")

 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq PLINETYPE (getvar "PLINETYPE"))
 (setvar "PLINETYPE" 2)
 (setq ALSAVE RFL:ALIGNLIST)

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CLAYER" CLAYER)
  (setvar "DIMZIN" DIMZIN)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "PLINETYPE" PLINETYPE)
  (setq RFL:ALIGNLIST ALSAVE)
  ;(setq *error* nil)
  (print msg)
 )

 (defun INITIATE (RFL:RAMPLIST)
  (start_image "IMAGE1")
  (slide_image 0 0 (- (dimx_tile "IMAGE1") 1) (- (dimy_tile "IMAGE1") 1) (strcat RFLALIGNSLBNAME "(Tapered Single Exit)"))
  (end_image)
  (set_tile "LANEOFFSET" (rtos (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))))
  (set_tile "RAMPTAPER" (rtos (cdr (assoc "RAMPTAPER" RFL:RAMPLIST))))
  (set_tile "RAMPVERTICIES" (itoa (cdr (assoc "RAMPVERTICIES" RFL:RAMPLIST))))
  (set_tile "WEAVEOFFSET" (rtos (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))))
  (set_tile "GOREWIDTH" (rtos (cdr (assoc "GOREWIDTH" RFL:RAMPLIST))))
  (set_tile "TAPEROFFSET" (rtos (cdr (assoc "TAPEROFFSET" RFL:RAMPLIST))))
  (set_tile "INSIDEVERTICIES" (itoa (cdr (assoc "INSIDEVERTICIES" RFL:RAMPLIST))))
  (set_tile "NOSESTATION" (rtos (cdr (assoc "NOSESTATION" RFL:RAMPLIST))))
  (set_tile "NOSEOFFSET" (rtos (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))))
  (set_tile "NOSERADIUS" (rtos (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))))
  (set_tile "INSIDESHOULDER" (rtos (cdr (assoc "INSIDESHOULDER" RFL:RAMPLIST))))
  (set_tile "LANEWIDTH" (rtos (cdr (assoc "LANEWIDTH" RFL:RAMPLIST))))
  (set_tile "RETURNTAPER" (rtos (cdr (assoc "RETURNTAPER" RFL:RAMPLIST))))
  (set_tile "RETURNOFFSET" (rtos (cdr (assoc "RETURNOFFSET" RFL:RAMPLIST))))
  (set_tile "RETURNVERTICIES" (itoa (cdr (assoc "RETURNVERTICIES" RFL:RAMPLIST))))
  (set_tile "SINGLELANE" (cdr (assoc "SINGLELANE" RFL:RAMPLIST)))
  (set_tile "DUALLANE" (cdr (assoc "DUALLANE" RFL:RAMPLIST)))
  (set_tile "UPCHAINAGE" (cdr (assoc "UPCHAINAGE" RFL:RAMPLIST)))
  (set_tile "DOWNCHAINAGE" (cdr (assoc "DOWNCHAINAGE" RFL:RAMPLIST)))
  (set_tile "RIGHTSIDE" (cdr (assoc "RIGHTSIDE" RFL:RAMPLIST)))
  (set_tile "LEFTSIDE" (cdr (assoc "LEFTSIDE" RFL:RAMPLIST)))
  (set_tile "EXITTERMINAL" (cdr (assoc "EXITTERMINAL" RFL:RAMPLIST)))
  (set_tile "ENTRANCETERMINAL" (cdr (assoc "ENTRANCETERMINAL" RFL:RAMPLIST)))
 )

 (defun CANCELRAMP ()
  (setq CANCEL 1)
  (done_dialog)
  (unload_dialog DCL_ID)
 )

 (defun ACCEPTRAMP ()
  (setq CANCEL 0)
  (setq RFL:RAMPLIST (list (cons "LANEOFFSET" (atof (get_tile "LANEOFFSET")))
                           (cons "RAMPTAPER" (atof (get_tile "RAMPTAPER")))
                           (cons "RAMPTAPERENTRANCE" (cdr (assoc "RAMPTAPERENTRANCE" RFL:RAMPLIST)))
                           (cons "RAMPTAPEREXIT" (cdr (assoc "RAMPTAPEREXIT" RFL:RAMPLIST)))
                           (cons "RAMPVERTICIES" (atoi (get_tile "RAMPVERTICIES")))
                           (cons "WEAVEOFFSET" (atof (get_tile "WEAVEOFFSET")))
                           (cons "WEAVEOFFSETENTRANCESINGLE" (cdr (assoc "WEAVEOFFSETENTRANCESINGLE" RFL:RAMPLIST)))
                           (cons "WEAVEOFFSETENTRANCEDUAL" (cdr (assoc "WEAVEOFFSETENTRANCEDUAL" RFL:RAMPLIST)))
                           (cons "WEAVEOFFSETEXITSINGLE" (cdr (assoc "WEAVEOFFSETEXITSINGLE" RFL:RAMPLIST)))
                           (cons "WEAVEOFFSETEXITDUAL" (cdr (assoc "WEAVEOFFSETEXITDUAL" RFL:RAMPLIST)))
                           (cons "GOREWIDTH" (atof (get_tile "GOREWIDTH")))
                           (cons "GOREWIDTHENTRANCESINGLE" (cdr (assoc "GOREWIDTHENTRANCESINGLE" RFL:RAMPLIST)))
                           (cons "GOREWIDTHENTRANCEDUAL" (cdr (assoc "GOREWIDTHENTRANCEDUAL" RFL:RAMPLIST)))
                           (cons "GOREWIDTHEXITSINGLE" (cdr (assoc "GOREWIDTHEXITSINGLE" RFL:RAMPLIST)))
                           (cons "GOREWIDTHEXITDUAL" (cdr (assoc "GOREWIDTHEXITDUAL" RFL:RAMPLIST)))
                           (cons "TAPEROFFSET" (atof (get_tile "TAPEROFFSET")))
                           (cons "TAPEROFFSETENTRANCE" (cdr (assoc "TAPEROFFSETENTRANCE" RFL:RAMPLIST)))
                           (cons "TAPEROFFSETEXIT" (cdr (assoc "TAPEROFFSETEXIT" RFL:RAMPLIST)))
                           (cons "INSIDEVERTICIES" (atoi (get_tile "INSIDEVERTICIES")))
                           (cons "NOSESTATION" (atof (get_tile "NOSESTATION")))
                           (cons "NOSEOFFSET" (atof (get_tile "NOSEOFFSET")))
                           (cons "NOSERADIUS" (atof (get_tile "NOSERADIUS")))
                           (cons "NOSERADIUSENTRANCE" (cdr (assoc "NOSERADIUSENTRANCE" RFL:RAMPLIST)))
                           (cons "NOSERADIUSEXIT" (cdr (assoc "NOSERADIUSEXIT" RFL:RAMPLIST)))
                           (cons "INSIDESHOULDER" (atof (get_tile "INSIDESHOULDER")))
                           (cons "INSIDESHOULDERSINGLE" (cdr (assoc "INSIDESHOULDERSINGLE" RFL:RAMPLIST)))
                           (cons "INSIDESHOULDERDUAL" (cdr (assoc "INSIDESHOULDERDUAL" RFL:RAMPLIST)))
                           (cons "LANEWIDTH" (atof (get_tile "LANEWIDTH")))
                           (cons "LANEWIDTHSINGLE" (cdr (assoc "LANEWIDTHSINGLE" RFL:RAMPLIST)))
                           (cons "LANEWIDTHDUAL" (cdr (assoc "LANEWIDTHDUAL" RFL:RAMPLIST)))
                           (cons "RETURNTAPER" (atof (get_tile "RETURNTAPER")))
                           (cons "RETURNOFFSET" (atof (get_tile "RETURNOFFSET")))
                           (cons "RETURNVERTICIES" (atoi (get_tile "RETURNVERTICIES")))
                           (cons "SINGLELANE" (get_tile "SINGLELANE"))
                           (cons "DUALLANE" (get_tile "DUALLANE"))
                           (cons "UPCHAINAGE" (get_tile "UPCHAINAGE"))
                           (cons "DOWNCHAINAGE" (get_tile "DOWNCHAINAGE"))
                           (cons "RIGHTSIDE" (get_tile "RIGHTSIDE"))
                           (cons "LEFTSIDE" (get_tile "LEFTSIDE"))
                           (cons "EXITTERMINAL" (get_tile "EXITTERMINAL"))
                           (cons "ENTRANCETERMINAL" (get_tile "ENTRANCETERMINAL"))))
  (done_dialog)
  (unload_dialog DCL_ID)
 )

 (defun FIXNUMBER (TYPE TILE)
  (if (= TYPE 1)
   (set_tile TILE (rtos (atof (get_tile TILE))))
   (set_tile TILE (itoa (atoi (get_tile TILE))))
  )
 )

 (defun SETSINGLELANE ()
  (set_tile "LANEWIDTH" (rtos (cdr (assoc "LANEWIDTHSINGLE" RFL:RAMPLIST))))
  (set_tile "INSIDESHOULDER" (rtos (cdr (assoc "INSIDESHOULDERSINGLE" RFL:RAMPLIST))))
  (if (= "1" (get_tile "EXITTERMINAL"))
   (SETEXIT)
   (SETENTRANCE)
  )
 )

 (defun SETDUALLANE ()
  (set_tile "LANEWIDTH" (rtos (cdr (assoc "LANEWIDTHDUAL" RFL:RAMPLIST))))
  (set_tile "INSIDESHOULDER" (rtos (cdr (assoc "INSIDESHOULDERDUAL" RFL:RAMPLIST))))
  (if (= "1" (get_tile "EXITTERMINAL"))
   (SETEXIT)
   (SETENTRANCE)
  )
 )

 (defun SETEXIT ()
  (set_tile "RAMPTAPER" (rtos (cdr (assoc "RAMPTAPEREXIT" RFL:RAMPLIST))))
  (set_tile "NOSERADIUS" (rtos (cdr (assoc "NOSERADIUSEXIT" RFL:RAMPLIST))))
  (set_tile "TAPEROFFSET" (rtos (cdr (assoc "TAPEROFFSETEXIT" RFL:RAMPLIST))))
  (if (= "1" (get_tile "SINGLELANE"))
   (progn
    (set_tile "GOREWIDTH" (rtos (cdr (assoc "GOREWIDTHEXITSINGLE" RFL:RAMPLIST))))
    (set_tile "WEAVEOFFSET" (rtos (cdr (assoc "WEAVEOFFSETEXITSINGLE" RFL:RAMPLIST))))
   )
   (progn
    (set_tile "GOREWIDTH" (rtos (cdr (assoc "GOREWIDTHEXITDUAL" RFL:RAMPLIST))))
    (set_tile "WEAVEOFFSET" (rtos (cdr (assoc "WEAVEOFFSETEXITDUAL" RFL:RAMPLIST))))
   )
  )
 )

 (defun SETENTRANCE ()
  (set_tile "RAMPTAPER" (rtos (cdr (assoc "RAMPTAPERENTRANCE" RFL:RAMPLIST))))
  (set_tile "NOSERADIUS" (rtos (cdr (assoc "NOSERADIUSENTRANCE" RFL:RAMPLIST))))
  (set_tile "TAPEROFFSET" (rtos (cdr (assoc "TAPEROFFSETENTRANCE" RFL:RAMPLIST))))
  (if (= "1" (get_tile "SINGLELANE"))
   (progn
    (set_tile "GOREWIDTH" (rtos (cdr (assoc "GOREWIDTHENTRANCESINGLE" RFL:RAMPLIST))))
    (set_tile "WEAVEOFFSET" (rtos (cdr (assoc "WEAVEOFFSETENTRANCESINGLE" RFL:RAMPLIST))))
   )
   (progn
    (set_tile "GOREWIDTH" (rtos (cdr (assoc "GOREWIDTHENTRANCEDUAL" RFL:RAMPLIST))))
    (set_tile "WEAVEOFFSET" (rtos (cdr (assoc "WEAVEOFFSETENTRANCEDUAL" RFL:RAMPLIST))))
   )
  )
 )

 (defun PICK ()
  (setq RERUN 1)
  (setq TEMPRAMPLIST RFL:RAMPLIST)
  (ACCEPTRAMP)
  (setq CANCEL "PICK")
 )

 (if (or (= nil RFL:ALIGNLIST) (= nil RFL:STAOFF))
  (alert "\n!!!!!  Alignment and/or alignment utilities not loaded !!!!!")
  (progn
   (setq RERUN 1)
   (setq PICKSTA nil)
   (setq TEMPRAMPLIST RFL:RAMPLIST)
   (while (= RERUN 1)
    (setq RERUN 0)


    (if (= RAMPDCLNAME nil)
     (progn
      (setq RAMPDCLNAME (vl-filename-mktemp "rfl.dcl"))
      (RFL:MAKEDCL RAMPDCLNAME "RAMP")
     )
     (if (= nil (findfile RAMPDCLNAME))
      (progn
       (setq RAMPDCLNAME (vl-filename-mktemp "rfl.dcl"))
       (RFL:MAKEDCL RAMPDCLNAME "RAMP")
      )
     )
    )
    (setq RFLALIGNSLBNAME "rflAlign.slb")
    (if (= nil (findfile RFLALIGNSLBNAME))
     (progn
      (setq RFLALIGNSLBNAME (vl-filename-mktemp "rfl.slb"))
      (RFL:MAKERFLSLB RFLALIGNSLBNAME)
     )
    )
    (setq DCL_ID (load_dialog RAMPDCLNAME))
    (if (not (new_dialog "RAMP" DCL_ID)) (exit))

    (INITIATE RFL:RAMPLIST)

    (if (/= nil PICKSTA)
     (progn
      (set_tile "NOSESTATION" (rtos PICKSTA))
      (setq RFL:RAMPLIST TEMPRAMPLIST)
      (setq PICKSTA nil)
     )
    )

    (action_tile "LANEOFFSET" "(FIXNUMBER 1 \"LANEOFFSET\")")
    (action_tile "RAMPTAPER" "(FIXNUMBER 1 \"RAMPTAPER\")")
    (action_tile "RAMPVERTICIES" "(FIXNUMBER 2 \"RAMPVERTICIES\")")
    (action_tile "WEAVEOFFSET" "(FIXNUMBER 1 \"WEAVEOFFSET\")")
    (action_tile "GOREWIDTH" "(FIXNUMBER 1 \"GOREWIDTH\")")
    (action_tile "TAPEROFFSET" "(FIXNUMBER 1 \"TAPEROFFSET\")")
    (action_tile "INSIDEVERTICIES" "(FIXNUMBER 2 \"INSIDEVERTICIES\")")
    (action_tile "NOSESTATION" "(FIXNUMBER 1 \"NOSESTATION\")")
    (action_tile "NOSERADIUS" "(FIXNUMBER 1 \"NOSERADIUS\")")
    (action_tile "INSIDESHOULDER" "(FIXNUMBER 1 \"INSIDESHOULDER\")")
    (action_tile "LANEWIDTH" "(FIXNUMBER 1 \"LANEWIDTH\")")
    (action_tile "RETURNTAPER" "(FIXNUMBER 1 \"RETURNTAPER\")")
    (action_tile "RETURNOFFSET" "(FIXNUMBER 1 \"RETURNOFFSET\")")
    (action_tile "RETURNVERTICIES" "(FIXNUMBER 2 \"RETURNVERTICIES\")")
    (action_tile "SINGLELANE" "(SETSINGLELANE)")
    (action_tile "DUALLANE" "(SETDUALLANE)")
    (action_tile "EXITTERMINAL" "(SETEXIT)")
    (action_tile "ENTRANCETERMINAL" "(SETENTRANCE)")
    (action_tile "PICK" "(PICK)")
    (action_tile "OK" "(ACCEPTRAMP)")
    (action_tile "CANCEL" "(CANCELRAMP)")

    (start_dialog)

    (if (= CANCEL "PICK")
     (setq PICKSTA (car (RFL:STAOFF (getpoint "\nPick point :"))))
    )
   )

   (if (= CANCEL 0)
    (progn
     (vl-load-com)
     (regapp "RFLTOOLS_XENT")
     (if (= "1" (cdr (assoc "UPCHAINAGE" RFL:RAMPLIST)))
      (setq D1 1.0)
      (setq D1 -1.0)
     )
     (if (= "1" (cdr (assoc "EXITTERMINAL" RFL:RAMPLIST)))
      (setq D2 1.0)
      (setq D2 -1.0)
     )
     (if (= "1" (cdr (assoc "LEFTSIDE" RFL:RAMPLIST)))
      (setq D1 (* D1 -1.0) D2 (* D2 -1.0))
     )
     (entmake)
     (entmake (list (cons 0 "CIRCLE")
                    (append (list 10) (RFL:XY (list (cdr (assoc "NOSESTATION" RFL:RAMPLIST))
                                                    (* D1
                                                       (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                                          (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
                                                          (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                                                       )
                                                    )
                                              )
                                      )
                    )
                    (cons 40 (cdr (assoc "NOSERADIUS" RFL:RAMPLIST)))
              )
     )
;     (command "._CIRCLE"
;              (RFL:XY (list (cdr (assoc "NOSESTATION" RFL:RAMPLIST))
;                            (* D1
;                               (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
;                                  (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
;                                  (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
;                               )
;                            )
;                      )
;              )
;              (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
;     )
     (setq ENTNOSE (entlast))
     (RFL:RAMPPUTXDATA ENTNOSE nil)
     (RFL:RAMPDRAW ENTNOSE 0)
    )
   )
  )
 )


 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CLAYER" CLAYER)
 (setvar "DIMZIN" DIMZIN)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "PLINETYPE" PLINETYPE)
 (setq RFL:ALIGNLIST ALSAVE)
 nil
)
(defun RFL:RAMPDRAW (ENTNOSE MODE / ALSAVE ANG ANG2 ANGBASE ANGDIR C CMDECHO D1 D2 DIMZIN DOFFSET DSTA ENTDELSET ENTLISTNEW ENTNOSELIST
                                    ENTNOSEP ENTSET NOSEALIGNRADIUS NOSEOFFSET NOSERADIUS NOSESTATION OFFSET OFFSET1 OFFSET2
                                    ORTHOMODE OSMODE RLSAVE P P1 P2 PL1 PL2
                                    PICK PICKSTA PLINETYPE RAMPENTLIST RLSAVE STA STA1 STA2)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq DIMZIN (getvar "DIMZIN"))
 (setvar "DIMZIN" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq PLINETYPE (getvar "PLINETYPE"))
 (setvar "PLINETYPE" 2)
 (setq ALSAVE RFL:ALIGNLIST)
 (setq RLSAVE RFL:RAMPLIST)

 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CLAYER" CLAYER)
  (setvar "DIMZIN" DIMZIN)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "PLINETYPE" PLINETYPE)
  (setq RFL:ALIGNLIST ALSAVE)
  (setq RFL:RAMPLIST RLSAVE)
  ;(setq *error* nil)
  (print msg)
 )
 
 (defun GETBIT (N B)
  (while (> B 0)
   (setq N (/ N 2))
   (setq B (- B 1))
  )
  (rem N 2)
 )

 (setq ALSAVE RFL:ALIGNLIST)
 (setq RFL:ALIGNLIST (RFL:RAMPGETALIGN ENTNOSE))
 (setq ENTNOSELIST (entget ENTNOSE))
 (setq NOSESTATION (RFL:STAOFF (cdr (assoc 10 ENTNOSELIST))))
 (setq NOSERADIUS (cdr (assoc 40 ENTNOSELIST)))
 (if (= nil NOSESTATION)
  (princ "!!! NOSE NOT ON ALIGNMENT !!!")
  (progn
   (setq NOSEOFFSET (cadr NOSESTATION))
   (setq NOSESTATION (car NOSESTATION))
   (setq NOSEALIGNRADIUS (RFL:GETRADIUS NOSESTATION))
   (setq RLSAVE RFL:RAMPLIST)
   (setq RFL:RAMPLIST (RFL:RAMPGETRAMP ENTNOSE))
   (if (= nil RFL:RAMPLIST)
    (princ "\n*** NO NOSE DATA FOUND ***")
    (progn
     (setq ENTSET (ssadd))
     (if (= 1 (GETBIT MODE 0))
      (progn
       (setq RFL:RAMPLIST (subst (cons "NOSESTATION" NOSESTATION) (assoc "NOSESTATION" RFL:RAMPLIST) RFL:RAMPLIST))
      )
     )
     (if (= 1 (GETBIT MODE 1))
      (progn
      )
     )
     (if (= 1 (GETBIT MODE 2))
      (progn
       (setq ENTDELSET (RFL:RAMPGETENT ENTNOSE))
       (setq C 0)
       (while (< C (sslength ENTDELSET))
        (entdel (ssname ENTDELSET C))
        (setq C (+ C 1))
       )
;       (command "._ERASE" (RFL:RAMPGETENT ENTNOSE) "")
      )
     )
     (if (= "1" (cdr (assoc "UPCHAINAGE" RFL:RAMPLIST)))
      (setq D1 1.0)
      (setq D1 -1.0)
     )
     (if (= "1" (cdr (assoc "EXITTERMINAL" RFL:RAMPLIST)))
      (setq D2 1.0)
      (setq D2 -1.0)
     )
     (if (= "1" (cdr (assoc "LEFTSIDE" RFL:RAMPLIST)))
      (setq D1 (* D1 -1.0) D2 (* D2 -1.0))
     )

     (setq ENTNOSEP (RFL:XY (list (cdr (assoc "NOSESTATION" RFL:RAMPLIST))
                                  (* D1
                                     (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                        (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
                                        (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                                     )
                                  )
                            )
                    )
     )
     (entmod (subst (list 10 (car ENTNOSEP) (cadr ENTNOSEP) 0.0) (assoc 10 (entget ENTNOSE)) (entget ENTNOSE)))

     (setq ANG (atan (/ 1.0 (cdr (assoc "RAMPTAPER" RFL:RAMPLIST)))))
     (setq STA2 (+ (cdr (assoc "NOSESTATION" RFL:RAMPLIST))
                   (* (+ (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                         (cdr (assoc "INSIDESHOULDER" RFL:RAMPLIST))
                         (cdr (assoc "LANEWIDTH" RFL:RAMPLIST))
                      )
                      -1.0
                      D1
                      D2
                      (sin ANG)
                   )
                )
     )
     (setq OFFSET2 (+ (* D1
                         (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                            (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
                            (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                         )
                            )
                      (* (+ (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                            (cdr (assoc "INSIDESHOULDER" RFL:RAMPLIST))
                            (cdr (assoc "LANEWIDTH" RFL:RAMPLIST))
                         )
                         D1
                         (cos ANG)
                      )
                   )
     )
     (setq OFFSET1 (* D1
                      (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                   )
     )
     (setq STA1 (+ STA2
                   (* -1.0
                      D1
                      D2
                      (abs (- OFFSET2 OFFSET1))
                      (cdr (assoc "RAMPTAPER" RFL:RAMPLIST))
                   )
                )
     )
     (if (or (= nil (RFL:XY (list STA1 0.0)))
             (= nil (RFL:XY (list STA2 0.0)))
             (= nil (RFL:XY (list (cdr (assoc "NOSESTATION" RFL:RAMPLIST)) 0.0)))
         )
      (progn
;       (alert "!!!!!  Point not on alignment  !!!!!")
      )
      (progn
       (setq PL1 (RFL:XY (list STA2 OFFSET2)))
       (setq STA STA1)
       (setq OFFSET OFFSET1)
       (setq DSTA (/ (- STA2 STA1) (cdr (assoc "RAMPVERTICIES" RFL:RAMPLIST))))
       (setq DOFFSET (/ (- OFFSET2 OFFSET1) (cdr (assoc "RAMPVERTICIES" RFL:RAMPLIST))))
       (setq C 0)
;       (setq ENTLISTNEW (list (cons 0 "LWPOLYLINE")))
;       (setq ENTLISTNEW (append ENTLISTNEW (list (cons 90 (+ (cdr (assoc "RAMPVERTICIES" RFL:RAMPLIST)) 1)))))
;       (while (<= C (cdr (assoc "RAMPVERTICIES" RFL:RAMPLIST)))
;        (setq ENTLISTNEW (append ENTLISTNEW (list (append (list 10) (RFL:XY (list (+ STA1 (* C DSTA))
;                                                                                  (+ OFFSET1 (* C DOFFSET))))))))
;        (setq C (+ C 1))
;       )
;(setq xxx ENTLISTNEW)
;(exit)
;       (entmake)
;       (entmake ENTLISTNEW)
       (command "._PLINE")
       (while (<= C (cdr (assoc "RAMPVERTICIES" RFL:RAMPLIST)))
        (if (setq P (RFL:XY (list (+ STA1 (* C DSTA))
                                  (+ OFFSET1 (* C DOFFSET)))))
         (command P)
        )
        (setq C (+ C 1))
       )
       (command "")
       (ssadd (entlast) ENTSET)
       (setq STA (+ STA1
                    (* (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))
                       (cdr (assoc "RAMPTAPER" RFL:RAMPLIST))
                       D1
                       D2
                    )
                 )
       )
       (command "._LINE"
                (RFL:XY (list STA
                              (* D1 (+ (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))
                                       (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                    )
                              )
                        )
                )
                (RFL:XY (list STA
                              (* D1 (+ 20.0
                                       (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))
                                       (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                    )
                              )
                        )
                )
                ""
       )
       (ssadd (entlast) ENTSET)
       (setvar "DIMZIN" 8)
       (if (= (cdr (assoc 40 (tblsearch "STYLE" (getvar "TEXTSTYLE")))) 0.0)
        (command "._TEXT"
                 "ML"
                 (RFL:XY (list STA
                               (* D1 (+ 20.0
                                        (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))
                                        (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                     )
                               )
                         )
                 )
                 5.0
                 (RFL:XY (list STA
                               (* D1 (+ 50.0
                                        (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))
                                        (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                     )
                               )
                         )
                 )
                 (if RFL:RAMPTAPERLABEL
                  (strcat "Weave (" (rtos (cdr (assoc "RAMPTAPER" RFL:RAMPLIST))) ":1 TAPER)")
                  (strcat "Weave: " (RFL:STATXT STA))
                 )
                 ;""
        )
        (command "._TEXT"
                 "ML"
                 (RFL:XY (list STA
                               (* D1 (+ 20.0
                                        (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))
                                        (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                     )
                               )
                         )
                 )
                 (RFL:XY (list STA
                               (* D1 (+ 50.0
                                        (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST))
                                        (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                     )
                               )
                         )
                 )
                 (if RFL:RAMPTAPERLABEL
                  (strcat "Weave (" (rtos (cdr (assoc "RAMPTAPER" RFL:RAMPLIST))) ":1 TAPER)")
                  (strcat "Weave: " (RFL:STATXT STA))
                 )
                 ;""
        )
       )
       (ssadd (entlast) ENTSET)
       (setvar "DIMZIN" 0)
       (setq STA1 (+ STA1
                     (* (+ (cdr (assoc "TAPEROFFSET" RFL:RAMPLIST))
                           (cdr (assoc "GOREWIDTH" RFL:RAMPLIST))
                        )
                        (cdr (assoc "RAMPTAPER" RFL:RAMPLIST))
                        D1
                        D2
                     )
                  )
       )
       (setq OFFSET1 (* D1
                        (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                           (cdr (assoc "TAPEROFFSET" RFL:RAMPLIST))
                        )
                     )
       )
       (setq STA2 (+ (cdr (assoc "NOSESTATION" RFL:RAMPLIST))
                     (* (+ (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                           (cdr (assoc "INSIDESHOULDER" RFL:RAMPLIST))
                        )
                        -1.0
                        D1
                        D2
                        (sin ANG)
                     )
                  )
       )
       (setq OFFSET2 (+ (* D1
                           (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                              (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
                              (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                           )
                        )
                        (* (+ (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                              (cdr (assoc "INSIDESHOULDER" RFL:RAMPLIST))
                           )
                           D1
                           (cos ANG)
                        )
                     )
       )
       (setq STA STA1)
       (setq OFFSET OFFSET1)
       (setq DSTA (/ (- STA2 STA1) (cdr (assoc "INSIDEVERTICIES" RFL:RAMPLIST))))
       (setq DOFFSET (/ (- OFFSET2 OFFSET1) (cdr (assoc "INSIDEVERTICIES" RFL:RAMPLIST))))
       (setq C 0)
       (command "._PLINE")
       (if (> (cdr (assoc "TAPEROFFSET" RFL:RAMPLIST)) 0.0)
        (if (setq P (RFL:XY (list STA1
                                  (* D1 (cdr (assoc "LANEOFFSET" RFL:RAMPLIST)))
                            )
                    )
            )
         (command P)
        )
       )
       (while (<= C (cdr (assoc "INSIDEVERTICIES" RFL:RAMPLIST)))
        (if (setq P (RFL:XY (list (+ STA1 (* C DSTA))
                                  (+ OFFSET1 (* C DOFFSET)))))
         (command P)
        )
        (setq C (+ C 1))
       )
       (command "")
       (ssadd (entlast) ENTSET)
       (setq PL2 (RFL:XY (list (cdr (assoc "NOSESTATION" RFL:RAMPLIST))
                               (* D1
                                  (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                                     (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
                                     (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                                  )
                               )
                         )
                 )
       )
       (setq ANG2 (+ (angle PL1 PL2)
                     (* D2
                        (/ pi 2.0)
                     )
                  )
       )
       (setq PL2 (list (+ (car PL1)
                          (* 50.0
                             (cos ANG2)
                          )
                       )
                       (+ (cadr PL1)
                          (* 50.0
                             (sin ANG2)
                          )
                       )
                 )
       )
       (command "._LINE" PL1 PL2 "")
       (ssadd (entlast) ENTSET)
       (setvar "DIMZIN" 8)
       (if (= (cdr (assoc 40 (tblsearch "STYLE" (getvar "TEXTSTYLE")))) 0.0)
        (command "._TEXT"
                 "MR"
                 PL2
                 5.0
                 PL1
                 (strcat "R=" (rtos (abs NOSEALIGNRADIUS)))
                 ;""
        )
        (command "._TEXT"
                 "MR"
                 PL2
                 PL1
                 (strcat "R=" (rtos (abs NOSEALIGNRADIUS)))
                 ;""
        )
       )
       (ssadd (entlast) ENTSET)
       (setvar "DIMZIN" 0)
      )
     )      
     (if (> (cdr (assoc "RETURNOFFSET" RFL:RAMPLIST))
            (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
         )
      (alert "!!!!!  Return offset greater than nose offset  !!!!!")
      (if (/= (cdr (assoc "RETURNOFFSET" RFL:RAMPLIST))
              (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
          )
       (progn
        (setq ANG (atan (/ 1.0 (cdr (assoc "RETURNTAPER" RFL:RAMPLIST)))))
        (setq STA2 (+ (cdr (assoc "NOSESTATION" RFL:RAMPLIST))
                      (* (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                         -1.0
                         D1
                         D2
                         (sin ANG)
                      )
                   )
        )
        (setq OFFSET2 (- (* D1
                            (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                               (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST))
                               (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                            )
                         )
                         (* (cdr (assoc "NOSERADIUS" RFL:RAMPLIST))
                            D1
                            (cos ANG)
                         )
                      )
        )
        (setq OFFSET1 (* D1
                         (+ (cdr (assoc "LANEOFFSET" RFL:RAMPLIST))
                            (cdr (assoc "RETURNOFFSET" RFL:RAMPLIST))
                         )
                      )
        )
        (setq STA1 (+ STA2
                      (* D1
                         D2
                         (abs (- OFFSET2 OFFSET1))
                         (cdr (assoc "RETURNTAPER" RFL:RAMPLIST))
                      )
                   )
        )
        (if (or (= nil (RFL:XY (list STA1 0.0)))
                (= nil (RFL:XY (list STA2 0.0)))
            )
         (alert "!!!!!  Point not on alignment  !!!!!")
         (progn
          (setq STA STA1)
          (setq OFFSET OFFSET1)
          (setq DSTA (/ (- STA2 STA1) (cdr (assoc "RETURNVERTICIES" RFL:RAMPLIST))))
          (setq DOFFSET (/ (- OFFSET2 OFFSET1) (cdr (assoc "RETURNVERTICIES" RFL:RAMPLIST))))
          (setq C 0)
          (command "._PLINE")
          (while (<= C (cdr (assoc "RETURNVERTICIES" RFL:RAMPLIST)))
           (if (setq P (RFL:XY (list (+ STA1 (* C DSTA))
                                     (+ OFFSET1 (* C DOFFSET)))))
            (command P)
           )
           (setq C (+ C 1))
          )
          (command "")
          (ssadd (entlast) ENTSET)
         )
        )
       )
      )
     )
     (RFL:RAMPPUTXDATA ENTNOSE ENTSET)
    )
   )
  )
 )
 
 (setq RFL:RAMPLIST ALSAVE)
 
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CLAYER" CLAYER)
 (setvar "DIMZIN" DIMZIN)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "PLINETYPE" PLINETYPE)
 (setq RFL:ALIGNLIST ALSAVE)
 (setq RFL:RAMPLIST RLSAVE)
 nil
)
(defun RFL:RAMPPUTXDATA (ENT ENTSET / ALIGNDATALIST C CMIN CMAX ENTLIST ENTDATALIST MAXNODES RAMPDATALIST STA)
 (setq MAXNODES 100)
 (vl-load-com)
 (regapp "RFLTOOLS_XENT")
 (setq RAMPDATALIST (list (cons 1000 "RFLTOOLS_RAMP_NOSE")
                          (cons 1040 (cdr (assoc "LANEOFFSET" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "RAMPTAPER" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "RAMPTAPERENTRANCE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "RAMPTAPEREXIT" RFL:RAMPLIST)))
                          (cons 1070 (cdr (assoc "RAMPVERTICIES" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "WEAVEOFFSET" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "WEAVEOFFSETENTRANCESINGLE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "WEAVEOFFSETENTRANCEDUAL" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "WEAVEOFFSETEXITSINGLE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "WEAVEOFFSETEXITDUAL" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "GOREWIDTH" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "GOREWIDTHENTRANCESINGLE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "GOREWIDTHENTRANCEDUAL" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "GOREWIDTHEXITSINGLE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "GOREWIDTHEXITDUAL" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "TAPEROFFSET" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "TAPEROFFSETENTRANCE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "TAPEROFFSETEXIT" RFL:RAMPLIST)))
                          (cons 1070 (cdr (assoc "INSIDEVERTICIES" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "NOSESTATION" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "NOSEOFFSET" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "NOSERADIUS" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "NOSERADIUSENTRANCE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "NOSERADIUSEXIT" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "INSIDESHOULDER" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "INSIDESHOULDERSINGLE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "INSIDESHOULDERDUAL" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "LANEWIDTH" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "LANEWIDTHSINGLE" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "LANEWIDTHDUAL" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "RETURNTAPER" RFL:RAMPLIST)))
                          (cons 1040 (cdr (assoc "RETURNOFFSET" RFL:RAMPLIST)))
                          (cons 1070 (cdr (assoc "RETURNVERTICIES" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "SINGLELANE" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "DUALLANE" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "UPCHAINAGE" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "DOWNCHAINAGE" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "RIGHTSIDE" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "LEFTSIDE" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "EXITTERMINAL" RFL:RAMPLIST)))
                          (cons 1000 (cdr (assoc "ENTRANCETERMINAL" RFL:RAMPLIST)))
                    )
 )
 (setq STA (cdr (assoc "NOSESTATION" RFL:RAMPLIST)))
 (if (> MAXNODES (length RFL:ALIGNLIST))
  (progn
   (setq CMIN 0)
   (setq CMAX (length RFL:ALIGNLIST))
  )
  (progn
   (setq C 0)
   (while (> STA (car (nth C RFL:ALIGNLIST)))
    (setq C (+ C 1))
   )
   (setq CMIN (max (- C (/ MAXNODES 2)) 0))
   (setq CMAX (min (+ C (/ MAXNODES 2)) (length RFL:ALIGNLIST)))
   (if (= CMIN 0)
    (setq CMAX (+ CMIN MAXNODES))
    (if (= CMAX (length RFL:ALIGNLIST))
     (setq CMIN (- CMAX MAXNODES))
    )
   )
  )
 )
 (setq ALIGNDATALIST (list (cons 1000 "#RFL HORIZONTAL ALIGNMENT FILE")))
 (setq C CMIN)
 (while (< C CMAX)
  (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 0 (nth C RFL:ALIGNLIST))))))
  (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 0 (nth 1 (nth C RFL:ALIGNLIST)))))))
  (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 1 (nth 1 (nth C RFL:ALIGNLIST)))))))
  (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 0 (nth 2 (nth C RFL:ALIGNLIST)))))))
  (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 1 (nth 2 (nth C RFL:ALIGNLIST)))))))
  (if (listp (nth 3 (nth C RFL:ALIGNLIST)))
   (progn
    (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1000 "SPIRAL"))))
	(setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 0 (nth 0 (nth 3 (nth C RFL:ALIGNLIST))))))))
	(setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 1 (nth 0 (nth 3 (nth C RFL:ALIGNLIST))))))))
	(setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 0 (nth 1 (nth 3 (nth C RFL:ALIGNLIST))))))))
	(setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 1 (nth 1 (nth 3 (nth C RFL:ALIGNLIST))))))))
	(setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 0 (nth 2 (nth 3 (nth C RFL:ALIGNLIST))))))))
	(setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 1 (nth 2 (nth 3 (nth C RFL:ALIGNLIST))))))))
	(setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 3 (nth 3 (nth C RFL:ALIGNLIST)))))))
   )
   (progn
    (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1040 (nth 3 (nth C RFL:ALIGNLIST))))))
   )
  )
  (setq C (+ C 1))
 )
 (setq ALIGNDATALIST (append ALIGNDATALIST (list (cons 1000 "#END DEFINITION"))))
 (setq ENTDATALIST (list (cons 1000 "RFLTOOLS_RAMP_ENTITIES")))
 (if (/= nil ENTSET)
  (progn
   (setq C 0)
   (while (< C (sslength ENTSET))
    (setq ENTDATALIST (append ENTDATALIST (list (cons 1005 (cdr (assoc 5 (entget (ssname ENTSET C))))))))
    (setq C (+ C 1))
   )
  )
 )
 (setq ENTLIST (append (entget ENT)
                       (list
                             (list -3
                                   (append (list "RFLTOOLS_XENT")
                                           RAMPDATALIST
                                           ALIGNDATALIST
                                           ENTDATALIST
                                   )
                             )
                       )
               )
 )
 (entmod ENTLIST)
)
(defun RFL:RAMPGETENT (ENT / ENT2 ENTLIST ENTSET NODE)
 (setq ENTSET (ssadd))
 (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT")))))
 (foreach NODE ENTLIST
  (progn
   (if (= 1005 (car NODE))
    (if (/= nil (setq ENT2 (handent (cdr NODE))))
     (ssadd ENT2 ENTSET)
    )
   )
  )
 )
 (setq ENTSET ENTSET)
)
(defun RFL:RAMPGETRAMP (ENT / ENTLIST ENTSET RFL:RAMPLIST)
 (setq RFL:RAMPLIST nil)
 (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT")))))
 (if (/= (cdar ENTLIST) "RFLTOOLS_RAMP_NOSE")
  (princ "\n*** NO NOSE DATA FOUND ***")
  (progn
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "LANEOFFSET" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RAMPTAPER" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RAMPTAPERENTRANCE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RAMPTAPEREXIT" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RAMPVERTICIES" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "WEAVEOFFSET" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "WEAVEOFFSETENTRANCESINGLE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "WEAVEOFFSETENTRANCEDUAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "WEAVEOFFSETEXITSINGLE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "WEAVEOFFSETEXITDUAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "GOREWIDTH" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "GOREWIDTHENTRANCESINGLE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "GOREWIDTHENTRANCEDUAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "GOREWIDTHEXITSINGLE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "GOREWIDTHEXITDUAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "TAPEROFFSET" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "TAPEROFFSETENTRANCE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "TAPEROFFSETEXIT" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "INSIDEVERTICIES" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "NOSESTATION" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "NOSEOFFSET" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "NOSERADIUS" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "NOSERADIUSENTRANCE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "NOSERADIUSEXIT" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "INSIDESHOULDER" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "INSIDESHOULDERSINGLE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "INSIDESHOULDERDUAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "LANEWIDTH" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "LANEWIDTHSINGLE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "LANEWIDTHDUAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RETURNTAPER" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RETURNOFFSET" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RETURNVERTICIES" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "SINGLELANE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "DUALLANE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "UPCHAINAGE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "DOWNCHAINAGE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "RIGHTSIDE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "LEFTSIDE" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "EXITTERMINAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RFL:RAMPLIST (append RFL:RAMPLIST (list (cons "ENTRANCETERMINAL" (cdar ENTLIST)))))
   (setq ENTLIST (cdr ENTLIST))
   (setq RAMPENTLIST nil)
   (while (/= ENTLIST nil)
    (setq RAMPENTLIST (append RAMPENTLIST (list (cdar ENTLIST))))
    (setq ENTLIST (cdr ENTLIST))
   )
  )
 )
 RFL:RAMPLIST
)
(defun RFL:RAMPGETALIGN (ENT / RFL:ALIGNLIST BULGE ENTLIST LO P1X P1Y P2X P2Y PLTX PLTY PLTSTX PLTSTY PSTX PSTY STA)
 (setq RFL:ALIGNLIST nil)
 (setq ENTLIST (cdadr (assoc -3 (entget ENT (list "RFLTOOLS_XENT")))))
 (while (and (/= ENTLIST nil) (/= (cdar ENTLIST) "#RFL HORIZONTAL ALIGNMENT FILE"))
  (setq ENTLIST (cdr ENTLIST))
 )
 (setq ENTLIST (cdr ENTLIST))
 (while (and (/= ENTLIST nil) (/= (cdar ENTLIST) "#END DEFINITION"))
  (setq STA (cdar ENTLIST))
  (setq ENTLIST (cdr ENTLIST))
  (setq P1X (cdar ENTLIST))
  (setq ENTLIST (cdr ENTLIST))
  (setq P1Y (cdar ENTLIST))
  (setq ENTLIST (cdr ENTLIST))
  (setq P2X (cdar ENTLIST))
  (setq ENTLIST (cdr ENTLIST))
  (setq P2Y (cdar ENTLIST))
  (setq ENTLIST (cdr ENTLIST))
  (if (= (cdar ENTLIST) "SPIRAL")
   (progn
    (setq ENTLIST (cdr ENTLIST))
    (setq PLTX (cdar ENTLIST))
    (setq ENTLIST (cdr ENTLIST))
    (setq PLTY (cdar ENTLIST))
    (setq ENTLIST (cdr ENTLIST))
    (setq PLTSTX (cdar ENTLIST))
    (setq ENTLIST (cdr ENTLIST))
    (setq PLTSTY (cdar ENTLIST))
    (setq ENTLIST (cdr ENTLIST))
    (setq PSTX (cdar ENTLIST))
    (setq ENTLIST (cdr ENTLIST))
    (setq PSTY (cdar ENTLIST))
    (setq ENTLIST (cdr ENTLIST))
    (setq LO (cdar ENTLIST))
    (setq BULGE (list (list PLTX PLTY) (list PLTSTX PLTSTY) (list PSTX PSTY) LO))
   )
   (progn
    (setq BULGE (cdar ENTLIST))
   )
  )
  (setq ENTLIST (cdr ENTLIST))
  (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list STA (list P1X P1Y) (list P2X P2Y) BULGE))))
 )
 RFL:ALIGNLIST
)
(defun C:MOVENOSE (/ *error* ALSAVE ENTNOSE ENTNOSELIST ENTSET GRCODE P P1 RLSAVE REP)
 (setq RLSAVE RFL:RAMPLIST)
 (setq ALSAVE RFL:ALIGNLIST)

 (defun *error* (msg)
  (setq RFL:ALIGNLIST ALSAVE)
  (setq RFL:RAMPLIST RLSAVE)
  ;(setq *error* nil)
  (print msg)
 )

 (setq ENTNOSE (car (entsel "\nSelect Nose : ")))
 (if (= nil (RFL:RAMPGETRAMP ENTNOSE))
  (princ "\n*** Entity does not contain RAMP information ***")
  (progn
   (setq ENTNOSELIST (entget ENTNOSE))
   (setq RFL:ALIGNLIST (RFL:RAMPGETALIGN ENTNOSE))
   (setq REP "")
   (while (or (= (car (setq GRCODE (grread t 15 0))) 5) (= (car GRCODE) 2))
    (cond ((= (car GRCODE) 2)
           (progn
            (princ (chr (cadr GRCODE)))
           )
          )
          ((= (car GRCODE) 5)
           (progn
            (setq P (cadr GRCODE))
            (setq P1 (RFL:STAOFF P))
            (if (/= nil P1)
             (progn
              (setq P1 (RFL:XY (list (car P1) 0.0)))
;              (grdraw P1 P -1)
              (setq ENTNOSELIST (subst (append (list 10) P1) (assoc 10 ENTNOSELIST) ENTNOSELIST))
              (entmod ENTNOSELIST)
              (entupd ENTNOSE)
              (RFL:RAMPDRAW ENTNOSE 7)
             )
            )
           )
          )
    )
   )
  )
 )
 (setq RFL:RAMPLIST RLSAVE)
 (setq RFL:ALIGNLIST ALSAVE)
 nil
)
(defun C:UPDATENOSE (/ ALSAVE ENTNOSE RLSAVE)
 (command "._UNDO" "M")
 (setq RLSAVE RFL:RAMPLIST)
 (setq ALSAVE RFL:ALIGNLIST)
 (setq ENTNOSE (car (entsel "\nSelect Nose : ")))
 (if (= nil (RFL:RAMPGETRAMP ENTNOSE))
  (princ "\n*** Entity does not contain RAMP information ***")
  (progn
   (RFL:RAMPDRAW ENTNOSE 7)
  )
 )
 (setq RFL:RAMPLIST RLSAVE)
 (setq RFL:ALIGNLIST ALSAVE)
 nil
)
(defun C:SETNOSE (/ ENTNOSE)
 (setq ENTNOSE (car (entsel "\nSelect Nose : ")))
 (if (= nil (RFL:RAMPGETRAMP ENTNOSE))
  (princ "\n*** Entity does not contain RAMP information ***")
  (progn
   (setq RFL:ALIGNLIST (RFL:RAMPGETALIGN ENTNOSE))
   (setq RFL:RAMPLIST (RFL:RAMPGETRAMP ENTNOSE))
   nil
  )
 )
)
(defun C:ERASENOSE (/ ENTNOSE RAMPENTSET)
 (command "._UNDO" "M")
 (setq ENTNOSE (car (entsel "\nSelect Nose : ")))
 (if (= nil (RFL:RAMPGETRAMP ENTNOSE))
  (princ "\n*** Entity does not contain RAMP information ***")
  (progn
   (setq RAMPENTSET (RFL:RAMPGETENT ENTNOSE))
   (ssadd ENTNOSE RAMPENTSET)
   (command "._ERASE" RAMPENTSET "")
   nil
  )
 )
);
;
;     Program written by Robert Livingston, 2018-06-12
;
;     C:REVSUPER swaps left/right values on superelevation blocks
;
;
(defun C:REVSUPER (/ ENT ENT2 ENTLIST SUPERLEFT SUPERRIGHT TMP)
 (while (setq ENT (car (entsel "\nSelect superelevation block : ")))
  (setq ENTLIST (entget ENT))
  (if (and (= (strcase (cdr (assoc 2 ENTLIST))) "SUPER")
           (= (cdr (assoc 66 ENTLIST)) 1)
      )
   (progn
    (setq ENT2 (entnext ENT))
    (setq ENTLIST (entget ENT2))
    (setq SUPERLEFT nil)
    (setq SUPERRIGHT nil)
    (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
     (if (= (strcase (cdr (assoc 2 ENTLIST))) "LEFT")
      (setq SUPERLEFT (cdr (assoc 1 ENTLIST)))
     )
     (if (= (strcase (cdr (assoc 2 ENTLIST))) "RIGHT")
      (setq SUPERRIGHT (cdr (assoc 1 ENTLIST)))
     )
     (setq ENT2 (entnext ENT2))
     (setq ENTLIST (entget ENT2))
    )
    (if (and SUPERLEFT SUPERRIGHT)
     (progn
      (setq ENT2 (entnext ENT))
      (setq ENTLIST (entget ENT2))
      (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
       (if (= (strcase (cdr (assoc 2 ENTLIST))) "LEFT")
        (progn
         (setq ENTLIST (subst (cons 1 SUPERRIGHT) (assoc 1 ENTLIST) ENTLIST))
         (entmod ENTLIST)
         (entupd ENT2)
         (entupd ENT)
        )
       )
       (if (= (strcase (cdr (assoc 2 ENTLIST))) "RIGHT")
        (progn
         (setq ENTLIST (subst (cons 1 SUPERLEFT) (assoc 1 ENTLIST) ENTLIST))
         (entmod ENTLIST)
         (entupd ENT2)
         (entupd ENT)
        )
       )
       (setq ENT2 (entnext ENT2))
       (setq ENTLIST (entget ENT2))
      )
     )
    )
   )
  )
 )
 T
);
;
;     Program written by Robert LIvingston, 02/02/28
;
;     ROTATE2ALIGN changes the rotation of selected block entities to match the current alignment
;
;
(defun C:ROTATE2ALIGN (/ *error* ANGBASE ANGDIR ANG C CMDECHO DIRECTION ENT ENTLIST ENTSET OSMODE P STA)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (princ msg)
  ;(setq *error* nil)
 )

 (command "._UNDO" "M")
 (command "._UCS" "W")

 (initget "Forward Reverse")
 (setq DIRECTION (getkword "\n<Forward> or Reverse ? ")) 
 (if (= DIRECTION nil) (setq DIRECTION "Forward"))
 (setq ENTSET (ssget))
 (setq C 0)
 (while (< C (sslength ENTSET))
  (setq ENT (ssname ENTSET C))
  (setq ENTLIST (entget ENT))
  (if (= (cdr (assoc 0 ENTLIST)) "INSERT")
   (progn
    (setq P (cdr (assoc 10 ENTLIST)))
    (setq STA (RFL:STAOFF P))
    (if (/= STA nil)
     (progn
      (setq ANG (angle (RFL:XY (list (nth 0 STA) (nth 1 STA))) (RFL:XY (list (nth 0 STA) (+ (nth 1 STA) 100.0)))))
      (if (= DIRECTION "Reverse")
       (setq ANG (- ANG (/ pi 2.0)))
       (setq ANG (+ ANG (/ pi 2.0)))
      )
      (command "._ROTATE" ENT "" P (* (/ 180.0 pi) (- ANG (cdr (assoc 50 ENTLIST)))))
     )
    )
   )
  )
  (setq C (+ C 1))
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
);
;
;     Program written by Robert Livingston, 2001/01/02
;
;     STEXT is a utility for "sliding" text along it's axis
;
;
(defun C:STEXT (/ *error* CMDECHO ENT ENTLIST ORTHOMODE SNAPANG)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 1)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 1)
 (setq SNAPANG (getvar "SNAPANG"))

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "CMDECHO" CMDECHO)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "SNAPANG" SNAPANG)
  (princ msg)
  ;(setq *error* nil)
 )

 (command "._UCS" "W")

 (setq ENT (car (entsel "\nSelect text :")))
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (or (= (cdr (assoc 0 ENTLIST)) "TEXT") (= (cdr (assoc 0 ENTLIST)) "MTEXT"))
    (progn
     (setq P nil)
     (if (and (= (cdr (assoc 0 ENTLIST)) "TEXT")
              (or (/= (cdr (assoc 72 ENTLIST)) 0)
                  (/= (cdr (assoc 73 ENTLIST)) 0)
              )
         )
      (setq P (cdr (assoc 11 ENTLIST)))
     )
     (if (= nil P)
      (setq P (cdr (assoc 10 ENTLIST)))
     )
     (setvar "SNAPANG" (cdr (assoc 50 ENTLIST)))
     (command "._MOVE" ENT "" "_NON" P "_NON" "\\")
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "SNAPANG" SNAPANG)
)
(defun C:STEXTM (/ *error* CMDECHO ENT ENTLIST ENTSET ORTHOMODE SNAPANG)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 1)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 1)
 (setq SNAPANG (getvar "SNAPANG"))

 (defun *error* (msg)
  (command "._UCS" "P")
  (setvar "CMDECHO" CMDECHO)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "SNAPANG" SNAPANG)
  (princ msg)
  ;(setq *error* nil)
 )

 (command "._UCS" "W")

 (setq ENT (car (entsel "\nSelect text :")))
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (or (= (cdr (assoc 0 ENTLIST)) "TEXT") (= (cdr (assoc 0 ENTLIST)) "MTEXT"))
    (progn
     (setq P nil)
     (if (and (= (cdr (assoc 0 ENTLIST)) "TEXT")
              (or (/= (cdr (assoc 72 ENTLIST)) 0)
                  (/= (cdr (assoc 73 ENTLIST)) 0)
              )
         )
      (setq P (cdr (assoc 11 ENTLIST)))
     )
     (if (= nil P)
      (setq P (cdr (assoc 10 ENTLIST)))
     )
     (setvar "SNAPANG" (cdr (assoc 50 ENTLIST)))
     (setq ENTSET (ssadd ENT))
     (while (/= (setq ENT (car (entsel "\nSelect entity :"))) nil)
      (ssadd ENT ENTSET)
     )
     (command "._MOVE" ENTSET "" "_NON" P "_NON" "\\")
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "CMDECHO" CMDECHO)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "SNAPANG" SNAPANG)
);
;
;   Program written by Robert Livingston, 2000/08/01
;
;   C:TPROF is a utility for drawing drawing one alignments profile onto another
;
;
(defun C:TPROF (/ ALIGNLISTFROM ALIGNLISTTO CMDECHO INC P PROFDEFTO PVILISTFROM STA STAFROM STATO Z)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (command "._UNDO" "M")

 (princ "\nSelect 'FROM' alignment :\n")
 (C:RALIGN)
 (if (/= RFL:ALIGNLIST nil)
  (progn
   (setq ALIGNLISTFROM RFL:ALIGNLIST)
   (princ "\nSelect 'FROM' profile :\n")
   (C:RPROF)
   (if (/= RFL:PVILIST nil)
    (progn
     (setq PVILISTFROM RFL:PVILIST)
     (princ "\nSelect 'TO' alignment :\n")
     (C:RALIGN)
     (if (/= RFL:ALIGNLIST nil)
      (progn
       (setq ALIGNLISTTO RFL:ALIGNLIST)
       (princ "\nSelect 'TO' profile :\n")
       (RFL:PROFDEF)
       (if (/= RFL:PROFDEFLIST nil)
        (progn
         (setq PROFDEFTO RFL:PROFDEFLIST)
         (setq STAFROM (getreal "\nEnter start station ('FROM' alignment, <return> for alignment start) :"))
         (if (= STAFROM nil)
          (setq STAFROM (max (car (car ALIGNLISTFROM)) (car (car PVILISTFROM))))
         )
         (setq STATO (getreal "\nEnter end station ('FROM' alignment, <return> for alignment end) :"))
         (if (= STATO nil)
          (progn
           (setq RFL:ALIGNLIST ALIGNLISTFROM)
           (setq STATO (min (+ (car (car ALIGNLISTFROM)) (RFL:GETALIGNLENGTH)) (car (last PVILISTFROM))))
          )
         )
         (setq INC (getreal "\nEnter incrament :"))
         (setq STA STAFROM)
         (command "._PLINE")
         (while (<= STA STATO)
          (setq RFL:ALIGNLIST ALIGNLISTFROM)
          (setq P (RFL:XY (list STA 0.0)))
          (if (/= P nil)
           (progn
            (setq RFL:PVILIST PVILISTFROM)
            (setq Z (RFL:ELEVATION STA))
            (if (/= Z nil)
             (progn
              (setq RFL:ALIGNLIST ALIGNLISTTO)
              (setq P (RFL:STAOFF P))
              (if (/= P nil)
               (progn
                (setq RFL:PROFDEFLIST PROFDEFTO)
                (command "_NON" (RFL:PROFPOINT (nth 0 P) Z))
               )
              )
             )
            )
           )
          )
          (setq STA (+ STA INC))
         )
         (command "")
        )
       )
      )
     )
    )
   )
  )
 )
 (setvar "CMDECHO" CMDECHO)
);
;
;   Program written by Robert Livingston, 2009/05/20
;
;   C:TPROFB is a utility for drawing drawing one alignments profile onto another
;
;
(defun C:TPROFB (/ ALIGNLISTFROM ALIGNLISTTO ENT CMDECHO INC P PROFDEFTO PVILISTFROM STA STAFROM STATO Z)
;(defun C:TPROF ()
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (command "._UNDO" "M")

 (princ "\nSelect 'FROM' alignment block :\n")
 (setq ENT (car (entsel)))
 (RFL:RALIGNB ENT)
 (if (/= RFL:ALIGNLIST nil)
  (progn
   (setq ALIGNLISTFROM RFL:ALIGNLIST)
   (RFL:RPROFB ENT)
   (if (/= RFL:PVILIST nil)
    (progn
     (setq PVILISTFROM RFL:PVILIST)
     (princ "\nSelect 'TO' alignment block :\n")
     (setq ENT (car (entsel)))
     (RFL:RALIGNB ENT)
     (if (/= RFL:ALIGNLIST nil)
      (progn
       (setq ALIGNLISTTO RFL:ALIGNLIST)
       (princ "\nSelect 'TO' profile :\n")
       (RFL:PROFDEF)
       (if (/= RFL:PROFDEFLIST nil)
        (progn
         (setq PROFDEFTO RFL:PROFDEFLIST)
         (setq STAFROM (getreal "\nEnter start station ('FROM' alignment, <return> for alignment start) :"))
         (if (= STAFROM nil)
          (setq STAFROM (max (car (car ALIGNLISTFROM)) (car (car PVILISTFROM))))
         )
         (setq STATO (getreal "\nEnter end station ('FROM' alignment, <return> for alignment end) :"))
         (if (= STATO nil)
          (progn
           (setq RFL:ALIGNLIST ALIGNLISTFROM)
           (setq STATO (min (+ (car (car ALIGNLISTFROM)) (RFL:GETALIGNLENGTH)) (car (last PVILISTFROM))))
          )
         )
         (setq INC (getreal "\nEnter incrament :"))
         (setq STA STAFROM)
         (command "._PLINE")
         (while (<= STA STATO)
          (setq RFL:ALIGNLIST ALIGNLISTFROM)
          (setq P (RFL:XY (list STA 0.0)))
          (if (/= P nil)
           (progn
            (setq RFL:PVILIST PVILISTFROM)
            (setq Z (RFL:ELEVATION STA))
            (if (/= Z nil)
             (progn
              (setq RFL:ALIGNLIST ALIGNLISTTO)
              (setq P (RFL:STAOFF P))
              (if (/= P nil)
               (progn
                (setq RFL:PROFDEFLIST PROFDEFTO)
                (command "_NON" (RFL:PROFPOINT (nth 0 P) Z))
               )
              )
             )
            )
           )
          )
          (setq STA (+ STA INC))
         )
         (command "")
        )
       )
      )
     )
    )
   )
  )
 )
 (setvar "CMDECHO" CMDECHO)
);
;
;   Program written by Robert Livingston, 2009/05/20
;
;   C:TPROFB is a utility for drawing drawing one alignments profile onto another
;          Modified to TPROFBN 2012/06/13 to work with nested RAB blocks
;
;
(defun C:TPROFBN (/ ALIGNLISTFROM ALIGNLISTTO ENT CMDECHO INC P PROFDEFTO PVILISTFROM STA STAFROM STATO Z)
;(defun C:TPROFN ()
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (command "._UNDO" "M")

 (setq ENT (car (nentsel "\nSelect 'FROM' nested alignment block :\n")))
 (setq ENT (cdr (assoc 330 (entget ENT))))
 (RFL:RALIGNBN ENT)
 (if (/= RFL:ALIGNLIST nil)
  (progn
   (setq ALIGNLISTFROM RFL:ALIGNLIST)
   (RFL:RPROFBN ENT)
   (if (/= RFL:PVILIST nil)
    (progn
     (setq PVILISTFROM RFL:PVILIST)
     (setq ENT (car (nentsel "\nSelect 'TO' nested alignment block :\n")))
     (setq ENT (cdr (assoc 330 (entget ENT))))
     (RFL:RALIGNB ENT)
     (if (/= RFL:ALIGNLIST nil)
      (progn
       (setq ALIGNLISTTO RFL:ALIGNLIST)
       (princ "\nSelect 'TO' profile :\n")
       (RFL:PROFDEF)
       (if (/= RFL:PROFDEFLIST nil)
        (progn
         (setq PROFDEFTO RFL:PROFDEFLIST)
         (setq STAFROM (getreal "\nEnter start station ('FROM' alignment, <return> for alignment start) :"))
         (if (= STAFROM nil)
          (setq STAFROM (max (car (car ALIGNLISTFROM)) (car (car PVILISTFROM))))
         )
         (setq STATO (getreal "\nEnter end station ('FROM' alignment, <return> for alignment end) :"))
         (if (= STATO nil)
          (progn
           (setq RFL:ALIGNLIST ALIGNLISTFROM)
           (setq STATO (min (+ (car (car ALIGNLISTFROM)) (RFL:GETALIGNLENGTH)) (car (last PVILISTFROM))))
          )
         )
         (setq INC (getreal "\nEnter incrament :"))
         (setq STA STAFROM)
         (command "._PLINE")
         (while (<= STA STATO)
          (setq RFL:ALIGNLIST ALIGNLISTFROM)
          (setq P (RFL:XY (list STA 0.0)))
          (if (/= P nil)
           (progn
            (setq RFL:PVILIST PVILISTFROM)
            (setq Z (RFL:ELEVATION STA))
            (if (/= Z nil)
             (progn
              (setq RFL:ALIGNLIST ALIGNLISTTO)
              (setq P (RFL:STAOFF P))
              (if (/= P nil)
               (progn
                (setq RFL:PROFDEFLIST PROFDEFTO)
                (command "_NON" (RFL:PROFPOINT (nth 0 P) Z))
               )
              )
             )
            )
           )
          )
          (setq STA (+ STA INC))
         )
         (command "")
        )
       )
      )
     )
    )
   )
  )
 )
 (setvar "CMDECHO" CMDECHO)
);
;
;     Program written by Robert Livingston, 0/12/18
;
;     VC2TAN draws a line tangent to two vertical curves
;
(defun C:VC2TAN (/ A1 A2 B1 B2 C1 C2 ENT ENTLIST F G GA GB G1 G2 P P1 P2 P3 SIGN V VA VB X XA XB X1 X2 Y YA YB Y1 Y2 TMP)

 (defun SIGN (X)
  (if (< X 0.0)
   (eval -1)
   (eval 1)
  )
 )

 (defun F (X Y / SA SB SC X1A X1B Y1A Y1B)
  (setq SA A2)
  (setq SB (* -2.0 A2 X))
  (setq SC (- Y C2 (* B2 X)))
  (setq X1A (/ (+ (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
  (setq Y1A (+ (* A2 X1A X1A) (* B2 X1A) C2))
  (setq X1B (/ (- (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
  (setq Y1B (+ (* A2 X1B X1B) (* B2 X1B) C2))
  (if (> X1A X1B)
   (list X1A Y1A)
   (list X1B Y1B)
  )
 )

 (setq ENT (car (entsel "\nSelect 'from' vertical curve :")))
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (progn
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P2 (cdr (assoc 10 ENTLIST)))
     (if (/= nil P2)
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P3 (cdr (assoc 10 ENTLIST)))
       (if (/= nil P3)
        (progn
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
         (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
          (setq P2 P3)
          (setq P3 (cdr (assoc 10 ENTLIST)))
          (setq ENT (entnext ENT))
          (setq ENTLIST (entget ENT))
         )
        )
       )
      )
     )
     (if (and (/= nil P1) (/= nil P2) (/= nil P3))
      (progn
       (setq X1 (nth 0 P1))
       (setq Y1 (nth 1 P1))
       (setq X2 (nth 0 P2))
       (setq Y2 (nth 1 P2))
       (setq X3 (nth 0 P3))
       (setq Y3 (nth 1 P3))
       (setq XA (min X1 X3))
       (setq XB (max X1 X3))
       (setq G1 (/ (- Y2 Y1) (- X2 X1)))
       (setq G2 (/ (- Y3 Y2) (- X3 X2)))
       (setq A1 (/ (- G2 G1) (- X3 X1) 2.0))
       (setq B1 (/ (- G2 (* G1 (/ X3 X1))) (- 1.0 (/ X3 X1))))
       (setq C1 (- Y1 (+ (* A1 X1 X1) (* B1 X1))))
       (setq ENT (car (entsel "\nSelect 'to' vertical curve :")))
       (if (/= nil ENT)
        (progn
         (setq ENTLIST (entget ENT))
         (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
          (progn
           (setq ENT (entnext ENT))
           (setq ENTLIST (entget ENT))
           (setq P1 (cdr (assoc 10 ENTLIST)))
           (setq ENT (entnext ENT))
           (setq ENTLIST (entget ENT))
           (setq P2 (cdr (assoc 10 ENTLIST)))
           (if (/= nil P2)
            (progn
             (setq ENT (entnext ENT))
             (setq ENTLIST (entget ENT))
             (setq P3 (cdr (assoc 10 ENTLIST)))
             (if (/= nil P3)
              (progn
               (setq ENT (entnext ENT))
               (setq ENTLIST (entget ENT))
               (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
                (setq P2 P3)
                (setq P3 (cdr (assoc 10 ENTLIST)))
                (setq ENT (entnext ENT))
                (setq ENTLIST (entget ENT))
               )
              )
             )
            )
           )
           (if (and (/= nil P1) (/= nil P2) (/= nil P3))
            (progn
             (setq X1 (nth 0 P1))
             (setq Y1 (nth 1 P1))
             (setq X2 (nth 0 P2))
             (setq Y2 (nth 1 P2))
             (setq X3 (nth 0 P3))
             (setq Y3 (nth 1 P3))
             (setq G1 (/ (- Y2 Y1) (- X2 X1)))
             (setq G2 (/ (- Y3 Y2) (- X3 X2)))
             (setq A2 (/ (- G2 G1) (- X3 X1) 2.0))
             (setq B2 (/ (- G2 (* G1 (/ X3 X1))) (- 1.0 (/ X3 X1))))
             (setq C2 (- Y1 (+ (* A2 X1 X1) (* B2 X1))))
             (setq YA (+ (* A1 XA XA) (* B1 XA) C1))
             (setq GA (+ (* 2.0 A1 XA) B1))
             (setq VA (F XA YA))
             (setq VA (- GA (/ (- (nth 1 VA) YA) (- (nth 0 VA) XA))))
             (setq TMP (/ (- XB XA) 25.0))
             (setq X (+ XB TMP))
             (setq XB (+ XA TMP))
             (setq YB (+ (* A1 XB XB) (* B1 XB) C1))
             (setq GB (+ (* 2.0 A1 XB) B1))
             (setq VB (F XB YB))
             (setq VB (- GB (/ (- (nth 1 VB) YB) (- (nth 0 VB) XB))))
             (while (and (= (SIGN VA) (SIGN VB)) (< XB X))
              (setq XA XB)
              (setq YA YB)
              (setq GA GB)
              (setq VA VB)
              (setq XB (+ XB TMP))
              (setq YB (+ (* A1 XB XB) (* B1 XB) C1))
              (setq GB (+ (* 2.0 A1 XB) B1))
              (setq VB (F XB YB))
              (setq VB (- GB (/ (- (nth 1 VB) YB) (- (nth 0 VB) XB))))
             )
             (setq X (/ (+ XA XB) 2.0))
             (setq Y (+ (* A1 X X) (* B1 X) C1))
             (setq G (+ (* 2.0 A1 X) B1))
             (setq V (F X Y))
             (setq V (- G (/ (- (nth 1 V) Y) (- (nth 0 V) X))))
             (if (= (SIGN VA) (SIGN VB))
              (princ "\n*** No solution found ***")
              (progn
               (setq TMP 0)
               (while (and (/= XA XB) (< TMP 1000))
                (if (< (* (SIGN V) (SIGN VB)) 0.0)
                 (progn
                  (setq XA X)
                  (setq YA Y)
                  (setq VA V)
                 )
                 (progn
                  (setq XB X)
                  (setq YB Y)
                  (setq VB V)
                 )
                )
                (setq X (/ (+ XA XB) 2.0))
                (setq Y (+ (* A1 X X) (* B1 X) C1))
                (setq G (+ (* 2.0 A1 X) B1))
                (setq V (F X Y))
                (setq V (- G (/ (- (nth 1 V) Y) (- (nth 0 V) X))))
                (setq TMP (+ TMP 1))
               )
               (command "._LINE" "_NON" (list X Y) "_NON" (F X Y) "")
              )
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
);
;
;   Program written by Robert Livingston, 00/09/18
;
;   VC3P is a utility for drawing vertical curves through 3 points
;
;
(defun C:VC3P (/ A B CMDECHO ENT1 ENT2 G1 G2 L OSMODE P1 P2 P3 P1 VCURVE VEXAG X1 X2 Y1 Y2 TMP Z1 Z2 Z3)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))

 (defun VCURVE (ENT1 ENT2 VEXAG L / ATTREQ ENT ENTLIST G1 G2 K P P1 P2 P3 P4 SPLINETYPE SPLINESEGS TMP)
  (setq ATTREQ (getvar "ATTREQ"))
  (setvar "ATTREQ" 1)
  (setq SPLINETYPE (getvar "SPLINETYPE"))
  (setvar "SPLINETYPE" 5)
  (setq SPLINESEGS (getvar "SPLINESEGS"))
  (setvar "SPLINESEGS" 65)

  (setq ENTLIST (entget ENT1))
  (setq P1 (cdr (assoc 10 ENTLIST)))
  (setq P2 (cdr (assoc 11 ENTLIST)))
  (setq ENTLIST (entget ENT2))
  (setq P3 (cdr (assoc 10 ENTLIST)))
  (setq P4 (cdr (assoc 11 ENTLIST)))
  (setq P (inters P1 P2 P3 P4 nil))
  (if (/= nil P)
   (progn
    (if (> (distance P2 P) (distance P1 P))
     (setq P1 P2)
    )
    (if (> (distance P3 P) (distance P4 P))
     (setq P4 P3)
    )
    (setq G1 (/ (- (nth 1 P) (nth 1 P1))
                (- (nth 0 P) (nth 0 P1))
                VEXAG
             )
    )
    (setq G2 (/ (- (nth 1 P4) (nth 1 P))
                (- (nth 0 P4) (nth 0 P))
                VEXAG
             )
    )
    (setq K (abs (/ L (- G2 G1) 100.0)))
    (setvar "ATTREQ" 0)
    (if (= nil (tblsearch "BLOCK" "PVI2")) (MAKEENT "PVI2"))
    (command "._INSERT"
             "PVI2"
             P
             25.4
             25.4
             0.0
    )
    (setq ENT (entlast))
    (setq ENTLIST (entget ENT))
    (if (= (cdr (assoc 66 ENTLIST)) 1)
     (progn
      (setq ENT (entnext ENT))
      (setq ENTLIST (entget ENT))
      (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
       (if (= (cdr (assoc 2 ENTLIST)) "LENGTH")
        (progn
         (setq ENTLIST (subst (cons 1 (rtos L 2 8)) (assoc 1 ENTLIST) ENTLIST))
         (entmod ENTLIST)
         (entupd ENT)
        )
       )
       (if (= (cdr (assoc 2 ENTLIST)) "K")
        (progn
         (setq ENTLIST (subst (cons 1 (rtos K 2 8)) (assoc 1 ENTLIST) ENTLIST))
         (entmod ENTLIST)
         (entupd ENT)
        )
       )
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
      )
     )
    )
    (setvar "ATTREQ" 1)
    (setq P2 (list (- (nth 0 P) (/ L 2.0))
                   (- (nth 1 P) (* (/ L 2.0) G1 VEXAG))
             )
    )
    (setq P3 (list (+ (nth 0 P) (/ L 2.0))
                   (+ (nth 1 P) (* (/ L 2.0) G2 VEXAG))
             )
    )
    (command "._PLINE" P2 P P3 "")
    (setq ENT (entlast))
    (command "._PEDIT" ENT "S" "")
   )
  )
  (setvar "ATTREQ" ATTREQ)
  (setvar "SPLINETYPE" SPLINETYPE)
  (setvar "SPLINESEGS" SPLINESEGS)
 )

 (setq VEXAG (getreal "Vertical exageration <10.000> :"))
 (if (= nil VEXAG) (setq VEXAG 10.0))
 (setq P1 (getpoint "\nFirst point :"))
 (setq P2 (getpoint "\nSecond point :"))
 (setq P3 nil K nil)
 (while (or (= P3 nil) (= K nil))
  (if (= P3 nil)
   (progn
    (setq P3 (getpoint "\nThird point (<Return> to enter K) :"))
    (if (= P3 nil)
     (setq P3 1)
     (setq K 1)
    )
   )
   (progn
    (setq K (getreal "\nK (<Return> to enter third point) :"))
    (if (= K nil)
     (setq P3 nil)
     (progn
      (setq L (/ (- (nth 0 P2) (nth 0 P1)) 2.0))
      (setq Z1 (/ (nth 1 P1) VEXAG))
      (setq Z3 (/ (nth 1 P2) VEXAG))
      (setq Z2 (* (/ (+ Z1 Z3 (/ (* L L) (* 100.0 K))) 2.0) VEXAG))
      (setq P3 (list (+ (nth 0 P1) L) Z2 0.0))
     )
    )
   )
  )
 )
 (setvar "OSMODE" 0)
 (if (< (nth 0 P2) (nth 0 P1))
  (progn
   (setq TMP P1)
   (setq P1 P2)
   (setq P2 TMP)
  )
 )
 (if (< (nth 0 P3) (nth 0 P1))
  (progn
   (setq TMP P1)
   (setq P1 P3)
   (setq P3 TMP)
  )
 )
 (if (< (nth 0 P3) (nth 0 P2))
  (progn
   (setq TMP P2)
   (setq P2 P3)
   (setq P3 TMP)
  )
 )
 (setq X1 (- (nth 0 P2) (nth 0 P1)))
 (setq Y1 (/ (- (nth 1 P2) (nth 1 P1)) VEXAG))
 (setq X2 (- (nth 0 P3) (nth 0 P1)))
 (setq Y2 (/ (- (nth 1 P3) (nth 1 P1)) VEXAG))

 (setq A (/ (- (/ Y2 X2)
               (/ Y1 X1)
            )
            (- X2 X1)
         )
 )
 (setq B (/ (- (/ Y2 (* X2 X2))
               (/ Y1 (* X1 X1))
            )
            (- (/ 1.0 X2)
               (/ 1.0 X1)
            )
         )
 )

 (setq G1 (* B 100.0))
 (setq G2 (* (+ (* 2.0 A X2) B) 100.0))

 (setq TMP nil)
 (setq TMP (getreal (strcat "G1 = " (rtos G1) ", desired (<return> to accept) : ")))
 (if (/= TMP nil)
  (setq G1 TMP)
 )
 (setq TMP nil)
 (setq TMP (getreal (strcat "G2 = " (rtos G2) ", desired (<return> to accept) : ")))
 (if (/= TMP nil)
  (setq G2 TMP)
 )

 (setq X1 (/ (- (/ G1 100.0)
                B
             )
             (* 2.0 A)
          )
 )
 (setq Y1 (+ (* A X1 X1)
             (* B X1)
          )
 )
 (setq X2 (/ (- (/ G2 100.0)
                B
             )
             (* 2.0 A)
          )
 )
 (setq Y2 (+ (* A X2 X2)
             (* B X2)
          )
 )
 (setq P2 (list (+ (nth 0 P1) X2)
                (+ (nth 1 P1)
                   (* VEXAG Y2)
                )
          )
 )
 (setq P1 (list (+ (nth 0 P1) X1)
                (+ (nth 1 P1)
                   (* VEXAG Y1)
                )
          )
 )
 (setq P3 (list (+ (nth 0 P1)
                   (/ (- (nth 0 P2) (nth 0 P1))
                      2.0
                   )
                )
                (+ (nth 1 P1)
                   (* (/ (- (nth 0 P2) (nth 0 P1))
                         2.0
                      )
                      (/ G1 100.0)
                      VEXAG
                   )
                )
          )
 )
 (command "._LINE" P1 P3 "")
 (setq ENT1 (entlast))
 (command "._LINE" P3 P2 "")
 (setq ENT2 (entlast))
 (VCURVE ENT1 ENT2 VEXAG (- X2 X1))

 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 2009-11-25
;
;     VCDTAN is a routine for drawing tangents off of vertical curves.
;
;
(defun C:VCDTAN (/ A B C D ENT ENTLIST G1 G2 ORTHOMODE OSMODE P P1 P2 P3 ROUNDSLOPE S SA SB SC X X0A X0B X1 X2 X3 XB Y Y0A Y0B Y1 Y2 Y3 YB TMP VEXAG)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (command "._UNDO" "M")
 (if (= nil VCURVEVEXAG) (setq VCURVEVEXAG 10.0))
 (setq VEXAG (getdist (strcat "\nVertical exaggeration <" (rtos VCURVEVEXAG) "> : ")))
 (if (= nil VEXAG)
  (setq VEXAG VCURVEVEXAG)
  (setq VCURVEVEXAG VEXAG)
 )
 (if (= nil VCURVETANROUND) (setq VCURVETANROUND 0.1))
 (setq ROUNDSLOPE (getdist (strcat "\nRound slope to nearest <" (rtos VCURVETANROUND) "> : ")))
 (if (= nil ROUNDSLOPE)
  (setq ROUNDSLOPE VCURVETANROUND)
  (setq VCURVETANROUND ROUNDSLOPE)
 )
 (setq ROUNDSLOPE (* ROUNDSLOPE VEXAG 0.01))
 (setq ENT (car (entsel "\nSelect vertical curve : ")))
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (progn
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P2 (cdr (assoc 10 ENTLIST)))
     (if (/= nil P2)
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P3 (cdr (assoc 10 ENTLIST)))
       (if (/= nil P3)
        (progn
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
         (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
          (setq P2 P3)
          (setq P3 (cdr (assoc 10 ENTLIST)))
          (setq ENT (entnext ENT))
          (setq ENTLIST (entget ENT))
         )
        )
       )
      )
     )
     (if (and (/= nil P1) (/= nil P2) (/= nil P3))
      (progn
       (setq X1 (nth 0 P1))
       (setq Y1 (nth 1 P1))
       (setq X2 (nth 0 P2))
       (setq Y2 (nth 1 P2))
       (setq X3 (nth 0 P3))
       (setq Y3 (nth 1 P3))
       (setq G1 (/ (- Y2 Y1) (- X2 X1)))
       (setq G2 (/ (- Y3 Y2) (- X3 X2)))
       (setq A (/ (- G2 G1) (- X3 X1) 2.0))
       (setq B (/ (- G2 (* G1 (/ X3 X1))) (- 1.0 (/ X3 X1))))
       (setq C (- Y1 (+ (* A X1 X1) (* B X1))))
       (while (= (car (setq TMP (grread nil 1))) 5)
        (setq X (caadr TMP))
        (setq Y (cadadr TMP))
        (command "._REDRAW")
        (setq SA A)
        (setq SB (* -2.0 A X))
        (setq SC (- Y C (* B X)))
        (if (> (- (* SB SB) (* 4.0 SA SC)) 0.0)
         (progn
          (setq X0A (/ (+ (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
          (setq Y0A (+ (* A X0A X0A) (* B X0A) C))
          (setq X0B (/ (- (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
          (setq Y0B (+ (* A X0B X0B) (* B X0B) C))
          (if (> X0A X0B)
           (progn
            (setq TMP X0A)
            (setq X0A X0B)
            (setq X0B TMP)
            (setq TMP Y0A)
            (setq Y0A Y0B)
            (setq Y0B TMP)
           )
          )
          (if (< (nth 0 P2) X)
           (progn
            (setq XB X0A YB Y0A)
           )
           (progn
            (setq XB X0B YB Y0B)
           )
          )
          (setq D (distance (list XB YB) (list X Y)))
          (setq S (/ (- Y YB) (- X XB)))
          (if (> S 0.0) (setq TMP 1.0) (setq TMP -1.0))
          (setq S (abs S))
          (setq S (* TMP (* (float (fix (+ 0.5 (/ S ROUNDSLOPE)))) ROUNDSLOPE)))
          (setq XB (/ (- S B) (* 2.0 A)))
          (setq YB (+ (* A XB XB) (* B XB) C))
          (if (< (nth 0 P2) X)
           (progn
            (setq X (+ XB (* D (cos (atan S)))))
            (setq Y (+ YB (* D (sin (atan S)))))
           )
           (progn
            (setq X (- XB (* D (cos (atan S)))))
            (setq Y (- YB (* D (sin (atan S)))))
           )
          )
          (grdraw (list XB YB) (list X Y) 7)
         )
        )
       )
       (command "._REDRAW")
       (if (> (- (* SB SB) (* 4.0 SA SC)) 0.0)
        (command "._LINE" (list XB YB) (list X Y) "")
        (princ "\nBad Point!")
       )
      )
     )
    )
   )
  )
 )
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
);
;
;     Program written by Robert Livingston, 02/05/08
;
;     VCPTAN draws a tangent at the specified point on a vertical curve
;
(defun C:VCPTAN (/ *error* ANGBASE ANGDIR A B C CMDECHO ENT ENTLIST G G1 G2 L OSMODE P P1 P2 P3 S X X1 X2 X3 Y Y1 Y2 Y3)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  ;(setq *error* nil)
  (print msg)
 )

 (command "._UCS" "W")

 (command "._UNDO" "M")

 (setq ENT (car (entsel "\nSelect vertical curve :")))
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (/= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (princ "\n*** Entity not a polyline ***")
    (progn
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P2 (cdr (assoc 10 ENTLIST)))
     (if (/= nil P2)
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P3 (cdr (assoc 10 ENTLIST)))
       (if (/= nil P3)
        (progn
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
         (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
          (setq P2 P3)
          (setq P3 (cdr (assoc 10 ENTLIST)))
          (setq ENT (entnext ENT))
          (setq ENTLIST (entget ENT))
         )
        )
       )
      )
     )
     (if (and (/= nil P1) (/= nil P2) (/= nil P3))
      (progn
       (setq VEXAG (getreal (strcat "\nEnter vertical exageration (" (rtos 10.0) ") : ")))
       (if (= nil VEXAG) (setq VEXAG 10.0))
       (setq X1 (nth 0 P1))
       (setq Y1 (/ (nth 1 P1) VEXAG))
       (setq X2 (nth 0 P2))
       (setq Y2 (/ (nth 1 P2) VEXAG))
       (setq X3 (nth 0 P3))
       (setq Y3 (/ (nth 1 P3) VEXAG))
       (setq G1 (/ (- Y2 Y1) (- X2 X1)))
       (setq G2 (/ (- Y3 Y2) (- X3 X2)))
       (setq P (getpoint (strcat "\nG1 = " (rtos (* G1 100.0)) ", G2 = " (rtos (* G2 100.0)) ", enter point : ")))
       (if (/= P nil)
        (progn
         (setq A (/ (- G2 G1) (- X3 X1) 2.0))
         (setq B (/ (- G2 (* G1 (/ X3 X1))) (- 1.0 (/ X3 X1))))
         (setq C (- Y1 (+ (* A X1 X1) (* B X1))))
         (setq X (nth 0 P))
         (setq Y (+ (* A X X) (* B X) C))
         (setq G (+ (* 2.0 A X) B))
         (setq L (getdist (strcat "\nEnter length (" (rtos (abs (- X3 X1))) ") : ")))
         (if (= nil L) (setq L (abs (- X3 X1))))
         (setq P1 (list (- X (/ L 2.0))
                        (* (- Y (* (/ L 2.0) G)) VEXAG)))
         (setq P2 (list (+ X (/ L 2.0))
                        (* (+ Y (* (/ L 2.0) G)) VEXAG)))
         (command "._LINE" P1 P2 "")
        )
       )
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 02/05/08
;
;     VCSTAN draws a tangent at the specified slope on a vertical curve
;
(defun C:VCSTAN (/ *error* ANGBASE ANGDIR A B C CMDECHO ENT ENTLIST G G1 G2 L OSMODE P P1 P2 P3 S X X1 X2 X3 Y Y1 Y2 Y3)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (defun *error* (msg)
  (if (>= (atof (getvar "ACADVER")) 18.2)
   (command-s "._UCS" "P")
   (command "._UCS" "P")
  )
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  ;(setq *error* nil)
  (print msg)
 )

 (command "._UCS" "W")

 (command "._UNDO" "M")

 (setq ENT (car (entsel "\nSelect vertical curve :")))
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (/= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (princ "\n*** Entity not a polyline ***")
    (progn
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P2 (cdr (assoc 10 ENTLIST)))
     (if (/= nil P2)
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P3 (cdr (assoc 10 ENTLIST)))
       (if (/= nil P3)
        (progn
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
         (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
          (setq P2 P3)
          (setq P3 (cdr (assoc 10 ENTLIST)))
          (setq ENT (entnext ENT))
          (setq ENTLIST (entget ENT))
         )
        )
       )
      )
     )
     (if (and (/= nil P1) (/= nil P2) (/= nil P3))
      (progn
       (setq VEXAG (getreal (strcat "\nEnter vertical exageration (" (rtos 10.0) ") : ")))
       (if (= nil VEXAG) (setq VEXAG 10.0))
       (setq X1 (nth 0 P1))
       (setq Y1 (/ (nth 1 P1) VEXAG))
       (setq X2 (nth 0 P2))
       (setq Y2 (/ (nth 1 P2) VEXAG))
       (setq X3 (nth 0 P3))
       (setq Y3 (/ (nth 1 P3) VEXAG))
       (setq G1 (/ (- Y2 Y1) (- X2 X1)))
       (setq G2 (/ (- Y3 Y2) (- X3 X2)))
       (setq G (getreal (strcat "\nG1 = " (rtos (* G1 100.0)) ", G2 = " (rtos (* G2 100.0)) ", enter slope (%) : ")))
       (if (/= G nil)
        (progn
         (setq G (/ G 100.0))
         (setq A (/ (- G2 G1) (- X3 X1) 2.0))
         (setq B (/ (- G2 (* G1 (/ X3 X1))) (- 1.0 (/ X3 X1))))
         (setq C (- Y1 (+ (* A X1 X1) (* B X1))))
         (setq X (+ X1 (* (/ (- G G1) (- G2 G1)) (- X3 X1))))
         (setq Y (+ (* A X X) (* B X) C))
         (setq L (getdist (strcat "\nEnter length (" (rtos (abs (- X3 X1))) ") : ")))
         (if (= nil L) (setq L (abs (- X3 X1))))
         (setq P1 (list (- X (/ L 2.0))
                        (* (- Y (* (/ L 2.0) G)) VEXAG)))
         (setq P2 (list (+ X (/ L 2.0))
                        (* (+ Y (* (/ L 2.0) G)) VEXAG)))
         (command "._LINE" P1 P2 "")
        )
       )
      )
     )
    )
   )
  )
 )

 (command "._UCS" "P")
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 0/12/18
;
;     VCTAN returns the tangent from a point to a vertical curve
;
(defun C:VCTAN (/ A B C ENT ENTLIST G1 G2 P P1 P2 P3 PE RFL:PVILIST SA SB SC X X0A X0B X1 X2 X3 Y Y0A Y0B Y1 Y2 Y3 TMP)
 (setq P (getvar "LASTPOINT"))
 (setq X (nth 0 P))
 (setq Y (nth 1 P))
 (setq ENT (entsel "\nSelect vertical curve :"))
 (setq PE (cadr ENT))
 (setq ENT (car ENT))
 (if (and (/= nil ENT) (/= nil P))
  (progn
   (setq P1 nil P2 nil P3 nil)
   (setq ENTLIST (entget ENT))
   (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (progn
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
     (setq P2 (cdr (assoc 10 ENTLIST)))
     (if (/= nil P2)
      (progn
       (setq ENT (entnext ENT))
       (setq ENTLIST (entget ENT))
       (setq P3 (cdr (assoc 10 ENTLIST)))
       (if (/= nil P3)
        (progn
         (setq ENT (entnext ENT))
         (setq ENTLIST (entget ENT))
         (while (/= "SEQEND" (cdr (assoc 0 ENTLIST)))
          (setq P2 P3)
          (setq P3 (cdr (assoc 10 ENTLIST)))
          (setq ENT (entnext ENT))
          (setq ENTLIST (entget ENT))
         )
        )
       )
      )
     )
    )
   )
   (if (= "AECC_PROFILE" (cdr (assoc 0 ENTLIST)))
    (progn
     (setq RFL:PVILIST nil)
     (RFL:RPROFC3D ENT)
     (if (/= RFL:PVILIST nil)
      (progn
       (setq C 0)
       (while (< C (length RFL:PVILIST))
        
        
        (setq C (1+ C))
       )
      )
     )
    )
   )
   (if (and (/= nil P1) (/= nil P2) (/= nil P3))
    (progn
     (setq X1 (nth 0 P1))
     (setq Y1 (nth 1 P1))
     (setq X2 (nth 0 P2))
     (setq Y2 (nth 1 P2))
     (setq X3 (nth 0 P3))
     (setq Y3 (nth 1 P3))
     (setq G1 (/ (- Y2 Y1) (- X2 X1)))
     (setq G2 (/ (- Y3 Y2) (- X3 X2)))
     (setq A (/ (- G2 G1) (- X3 X1) 2.0))
     (setq B (/ (- G2 (* G1 (/ X3 X1))) (- 1.0 (/ X3 X1))))
     (setq C (- Y1 (+ (* A X1 X1) (* B X1))))
     (setq SA A)
     (setq SB (* -2.0 A X))
     (setq SC (- Y C (* B X)))
     (setq X0A (/ (+ (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
     (setq Y0A (+ (* A X0A X0A) (* B X0A) C))
     (setq X0B (/ (- (* -1.0 SB) (sqrt (- (* SB SB) (* 4.0 SA SC)))) (* 2.0 SA)))
     (setq Y0B (+ (* A X0B X0B) (* B X0B) C))
     (if (> X0A X0B)
      (progn
       (setq TMP X0A)
       (setq X0A X0B)
       (setq X0B TMP)
       (setq TMP Y0A)
       (setq Y0A Y0B)
       (setq Y0B TMP)
      )
     )
     (princ "\nPick side :")
     (while (= (car (setq TMP (grread nil 1))) 5)
     )
     (if (= (car TMP) 3)
      (if (< (nth 0 (car (cdr TMP))) X)
       (list X0A Y0A)
       (list X0B Y0B)
      )
      nil
     )
    )
    nil
   )
  )
 )
)(defun C:VCURVE (/ A ACTIVEDOC ACTIVESPACE B C CMDECHO D ENT ENTLIST G G1 G2 P P1 P2 P3 P4 PP
                   OSMODE TMP VEXAG X Y Z)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))

 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )
 
 (setq ENT (car (entsel "\nSelect first tangent :")))
 (if (/= nil ENT)
  (progn
   (setq ENTLIST (entget ENT))
   (if (= (cdr (assoc 0 ENTLIST)) "LINE")
    (progn
     (command "._LIST" ENT)
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq P2 (cdr (assoc 11 ENTLIST)))
     (setq ENT (car (entsel "\nSelect second tangent :")))
     (if (/= nil ENT)
      (progn
       (setq ENTLIST (entget ENT))
       (if (= (cdr (assoc 0 ENTLIST)) "LINE")
        (progn
         (command ENT)
         (setq P3 (cdr (assoc 10 ENTLIST)))
         (setq P4 (cdr (assoc 11 ENTLIST)))
         (setq P (inters P1 P2 P3 P4 nil))
         (if (/= nil P)
          (progn
           (setq VEXAG (getreal (strcat "\nEnter vertical exageration <" (rtos (if RFL:PROFDEFLIST (cdr (assoc "VEXAG" RFL:PROFDEFLIST)) 10.0)) "> :")))
           (if (= VEXAG nil) (setq VEXAG (if RFL:PROFDEFLIST (cdr (assoc "VEXAG" RFL:PROFDEFLIST)) 10.0)))
           (if (/= VEXAG nil)
            (progn
             (if (> VEXAG 0.0)
              (progn
               (if (> (distance P2 P) (distance P1 P))
                (setq P1 P2)
               )
               (if (> (distance P3 P) (distance P4 P))
                (setq P4 P3)
               )
               (setq K nil)
               (setq L nil)
               (setq PP nil)
               (setq G1 (/ (- (nth 1 P) (nth 1 P1))
                           (- (nth 0 P) (nth 0 P1))
                           VEXAG
                        )
               )
               (setq G2 (/ (- (nth 1 P4) (nth 1 P))
                           (- (nth 0 P4) (nth 0 P))
                           VEXAG
                        )
               )
               (while (or (= K nil) (= L nil) (= PP nil))
                (if (= L nil)
                 (progn
                  (setq L (getdist "\nEnter vertical curve 'L' (<return> for 'K') :"))
                  (if (= L nil)
                   (progn
                    (setq L -1.0)
                    (setq K nil)
                    (setq PP -1.0)
                   )
                   (progn
                    (setq K (abs (/ L (- G2 G1) 100.0)))
                    (setq PP -1.0)
                   )
                  )
                 )
                 (progn
                  (if (= K nil)
                   (progn
                    (setq K (getreal "\nEnter vertical curve 'K' (<return> for 'P') :"))
                    (if (= K nil)
                     (progn
                      (setq L -1.0)
                      (setq K -1.0)
                      (setq PP nil)
                     )
                     (progn
                      (setq L (abs (* K (- G2 G1) 100.0)))
                      (setq REP (getreal (strcat "\nL = " (rtos L) ", enter new value or <return> to accept :")))
                      (if (/= nil REP)
                       (progn
                        (setq L REP)
                        (setq K (abs (/ L (- G2 G1) 100.0)))
                       )
                      )
                      (setq PP -1.0)
                     )
                    )
                   )
                   (progn
                    (setq PP (getpoint "\nEnter through point (<return> for 'L') :"))
                    (if (= PP nil)
                     (progn
                      (setq L nil)
                      (setq K -1.0)
                      (setq PP -1.0)
                     )
                     (progn
                      (setq D (- (nth 0 P) (nth 0 PP)))
                      (setq G (- G2 G1))
                      (setq Z (- (/ (nth 1 PP) VEXAG)
                                 (- (/ (nth 1 P) VEXAG)
                                    (* G1 D)
                                 )
                              )
                      )
                      (setq A 0.25)
                      (setq B (* -1.0
                                 (+ D
                                    (/ (* 2.0 Z)
                                       G
                                    )
                                 )
                              )
                      )
                      (setq C (* D D))
                      (setq TMP (- (* B B) (* 4.0 A C)))
                      (if (< TMP 0.0)
                       (progn
                        (princ "\n*** No solution ***")
                        (setq L -1.0)
                        (setq K -1.0)
                        (setq PP nil)
                       )
                       (progn
                        (setq L (/ (- (sqrt TMP) B) (* 2.0 A)))
                        (if (< L 0.0)
                         (progn
                          (princ "\n*** No solution ***")
                          (setq L -1.0)
                          (setq K -1.0)
                          (setq PP nil)
                         )
                         (progn
                          (setq REP (getreal (strcat "\nL = " (rtos L) ", enter new value or <return> to accept :")))
                          (if (/= nil REP)
                           (progn
                            (setq L REP)
                           )
                          )
                          (setq K (abs (/ L (- G2 G1) 100.0)))
                         )
                        )
                       )
                      )
                     )
                    )
                   )
                  )
                 )
                )
               )
               (command)
               (setvar "OSMODE" 0)
               (setvar "ATTREQ" 0)
               (if (= nil (tblsearch "BLOCK" "PVI2")) (RFL:MAKEENT "PVI2"))
               (vla-insertblock ACTIVESPC
                                (vlax-3D-point P)
                                "PVI2"
                                25.4
                                25.4
                                25.4
                                0.0
               )
               (setq ENT (entlast))
               (setq ENTLIST (entget ENT))
               (if (= (cdr (assoc 66 ENTLIST)) 1)
                (progn
                 (setq ENT (entnext ENT))
                 (setq ENTLIST (entget ENT))
                 (while (/= (cdr (assoc 0 ENTLIST)) "SEQEND")
                  (if (= (cdr (assoc 2 ENTLIST)) "LENGTH")
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos L 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT)
                   )
                  )
                  (if (= (cdr (assoc 2 ENTLIST)) "K")
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos K 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT)
                   )
                  )
                  (setq ENT (entnext ENT))
                  (setq ENTLIST (entget ENT))
                 )
                )
               )
               (setvar "ATTREQ" 1)
               (setq P2 (list (- (nth 0 P) (/ L 2.0))
                              (- (nth 1 P) (* (/ L 2.0) G1 VEXAG))
                        )
               )
               (setq P3 (list (+ (nth 0 P) (/ L 2.0))
                              (+ (nth 1 P) (* (/ L 2.0) G2 VEXAG))
                        )
               )
               (RFL:DRAWPARABOLICVCURVE P2 P P3)
               (setvar "OSMODE" OSMODE)
              )
              (princ "\n**** NOT VALID ****")
             )
            )
           )
          )
          (princ "\n**** NO INTERSECTION FOUND ****")
         )
        )
        (princ "\n**** NOT A LINE ****")
       )
      )
     )
    )
    (princ "\n**** NOT A LINE ****")
   )
  )
 )
)
;
;
;   Program written by Robert Livingston, 99/12/03
;
;   C:VPL labels a selected point's station and elevation
;
(defun C:VPL (/ ANGBASE ANGDIR CMDECHO ENT ENTLIST OFFSET P1 P2 P3 SIGN STA STR STR2 STR3 STR4 *error* TMP Z)
 (defun *error* (msg)
  (terpri)
  ;(setq *error* nil)
 )
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)

 (defun SIGN (X)
  (if (< X 0)
   (eval -1)
   (eval 1)
  )
 )

 (if (= RFL:ELEVATION nil)
  (progn
   (princ "\n*****   Alignment utilities not loaded   *****")
  )
  (progn
   (if (= RFL:PROFDEFLIST nil) (RFL:PROFDEF))
   (setq P1 (getpoint "\nEnter point :"))
   (setq P2 (getpoint P1 "Second point for leader :"))
   (setq TMP (RFL:VPP P1))
   (setq STA (car TMP))
   (setq Z (cadr TMP))
   (setq STR (strcat "Sta.: " (RFL:STATXT STA)))
   (setq STR2 (strcat "Elev.: " (rtos Z)))
   (setq TMP (RFL:ELEVATION STA))
   (if (/= TMP nil)
    (setq STR3 (strcat "Ctrl.Elev.: " (rtos TMP)))
    (setq STR3 nil)
   )
   (setq TMP (RFL:SLOPE STA))
   (if (/= TMP nil)
    (setq STR4 (strcat "Ctrl.Grade: " (rtos (* 100.0 TMP)) "%"))
    (setq STR4 nil)
   )

   (command "LEADER" "_NON" P1 "_NON" P2 "" STR)
   (if (/= nil STR2) (command  STR2))
   (if (/= nil STR3) (command  STR3))
   (if (/= nil STR4) (command  STR4))
   (command "")
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
)
;
;
;   Program written by Robert Livingston, 98/06/11
;
;   WALIGN writes a horizontal alignment to file
;
;
(defun C:WALIGN (/ CMDECHO OUTFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
  (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
 )
 (if (= RFL:ALIGNLIST nil)
  (princ "\n*** NO ALIGNMENT EXISTS - USE RALIGN OR GALIGN ***\n")
  (progn
   (setq OUTFILENAME (getfiled "Select a Horizontal Alignment File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "hor" 1))
   (RFL:WALIGN OUTFILENAME)
  )
 )
 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   WALIGNB writes a horizontal alignment to a RFLALIGN Block
;
;
(defun C:WALIGNB (/ CMDECHO BLKENT BLKENTLIST ENT ENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (if (= nil RFL:ALIGNLIST)
   (RFL:RABKILL BLKENT "HOR")
   (RFL:WALIGNB BLKENT)
  )
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 98/05/13
;
;   C:WPROF writes a vertical alignment to file
;
;
(defun C:WPROF (/ CMDECHO OUTFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
  (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
 )
 (if (= RFL:PVILIST nil)
  (princ "\n*** NO VERTICAL EXISTS - USE RPROF OR GPROF ***\n")
  (progn
   (setq OUTFILENAME (getfiled "Select a Vertical Alignment File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "vrt" 1))
   (RFL:WPROF OUTFILENAME)
  )
 )
 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   WPROFB writes a vertical alinment to a RFLALIGN Block
;
;
(defun C:WPROFB (/ CMDECHO BLKENT BLKENTLIST ENT ENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (if (= nil RFL:PVILIST)
   (RFL:RABKILL BLKENT "VRT")
   (RFL:WPROFB BLKENT)
  )
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 98/05/13
;
;   C:WPROFOG writes a vertical alignment to file
;
;
(defun C:WPROFOG (/ C CMDECHO OUTFILE OUTFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (= RFL:OGLIST nil)
  (princ "\n*** NO OG EXISTS - USE GPROFOG ***\n")
  (progn
   (setq OUTFILENAME (getfiled "Select a Vertical OG File" "" "vrt" 1))
   (RFL:WPROFOG OUTFILENAME)
  )
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   WPROFOGB writes a OG vertical alinment to a RFLALIGN Block
;
;
(defun C:WPROFOGB (/ CMDECHO BLKENT BLKENTLIST ENT ENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (if (= nil RFL:OGLIST)
   (RFL:RABKILL BLKENT "OG")
   (RFL:WPROFOGB BLKENT)
  )
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;   Program written by Robert Livingston, 99/10/08
;
;   WSUPER writes the superelevation to file
;
;
(defun C:WSUPER (/ CMDECHO OUTFILENAME)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
  (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
 )
 (if (= RFL:SUPERLIST nil)
  (princ "\n*** NO SUPERELEVATION EXISTS - USE RSUPER OR GSUPER ***\n")
  (progn
   (setq OUTFILENAME (getfiled "Select a Superelevation File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "e" 1))
   (RFL:WSUPER OUTFILENAME)
  )
 )
 (setvar "CMDECHO" CMDECHO)
 nil
)
;
;
;   Program written by Robert Livingston, 2008/11/04
;
;   WSUPERB writes the superelevation to a RFLALIGN Block
;
;
(defun C:WSUPERB (/ CMDECHO BLKENT BLKENTLIST ENT ENTLIST)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)

 (setq BLKENT (car (entsel "\nSelect RFL Alignment Block : ")))
 (setq BLKENTLIST (entget BLKENT))
 (if (and (= "INSERT" (cdr (assoc 0 BLKENTLIST))) (= "RFLALIGN" (strcase (cdr (assoc 2 BLKENTLIST)))))
  (if (= nil RFL:SUPERLIST)
   (RFL:RABKILL BLKENT "E")
   (RFL:WSUPERB BLKENT)
  )
  (princ "\n*** NOT AN RFL ALIGNMENT BLOCK ***")
 )

 (setvar "CMDECHO" CMDECHO)
)
;
;
;     Program written by Robert Livingston, 2018-04-18
;
;     C:XYP is a loader for RFL:XYP
;
;
(defun C:XYP ()
 (RFL:XYP)
)
;
;
;     Program written by Robert Livingston, 2017-09-18
;
;     ROUNDABOUT is a collection of utilities for grading roundabouts
;
;
(setq RFL:ROUNDABOUTLIST nil)
(setq RFL:ROUNDABOUTP nil)
(setq RFL:ROUNDABOUTOCLIST nil)
(setq RFL:ROUNDABOUTICLIST nil)
(setq RFL:ROUNDABOUTMCLIST nil)
(setq RFL:ROUNDABOUTCCLIST nil)
(defun RFL:GETROUNDABOUTLIST (ENT / CENTERGRADE CUT CUTDITCHDEPTH CUTDITCHSLOPE CUTDITCHWIDTH ELEV ENTLIST FILL INNERGRADE GRADE NAME RCENTER RIN ROUT SLOPE)
 (setq RFL:ROUNDABOUTLIST nil)
 (setq CENTERGRADE nil
       CUT nil
       CUTDITCHDEPTH nil
       CUTDITCHSLOPE nil
       CUTDITCHWIDTH nil
       ELEV nil
       FILL nil
       INNERGRADE nil
       GRADE nil
       NAME nil
       RCENTER nil
       RIN nil
       ROUT nil
       SLOPE nil
 )
 (if (and (/= nil (setq ENTLIST (entget ENT))) (= "INSERT" (cdr (assoc 0 ENTLIST))) (= 1 (cdr (assoc 66 ENTLIST))))
  (progn
   (setq ENT (entnext ENT))
   (setq ENTLIST (entget ENT))
   (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
    (cond ((= "NAME" (strcase (cdr (assoc 2 ENTLIST))))
           (setq NAME (cdr (assoc 1 ENTLIST)))
          )
          ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq SLOPE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
           (setq ELEV (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "GRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq GRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "INNERGRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq INNERGRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CENTERGRADE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CENTERGRADE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "ROUT" (strcase (cdr (assoc 2 ENTLIST))))
           (setq ROUT (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "RIN" (strcase (cdr (assoc 2 ENTLIST))))
           (setq RIN (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "RCENTER" (strcase (cdr (assoc 2 ENTLIST))))
           (setq RCENTER (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "FILL" (strcase (cdr (assoc 2 ENTLIST))))
           (setq FILL (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUT" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUT (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHSLOPE" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHSLOPE (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHDEPTH" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHDEPTH (atof (cdr (assoc 1 ENTLIST))))
          )
          ((= "CUTDITCHWIDTH" (strcase (cdr (assoc 2 ENTLIST))))
           (setq CUTDITCHWIDTH (atof (cdr (assoc 1 ENTLIST))))
          )
    )
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
   )
   (if (or (= CENTERGRADE nil)
           (= CUT nil)
           (= CUTDITCHDEPTH nil)
           (= CUTDITCHSLOPE nil)
           (= CUTDITCHWIDTH nil)
           (= ELEV nil)
           (= FILL nil)
           (= INNERGRADE nil)
           (= GRADE nil)
           (= NAME nil)
           (= RCENTER nil)
           (= RIN nil)
           (= ROUT nil)
           (= SLOPE nil)
       )
    nil
    (progn
     (setq RFL:ROUNDABOUTLIST (list (cons "NAME" NAME)
                                    (cons "SLOPE" SLOPE)
                                    (cons "ELEV" ELEV)
                                    (cons "GRADE" GRADE)
                                    (cons "INNERGRADE" INNERGRADE)
                                    (cons "CENTERGRADE" CENTERGRADE)
                                    (cons "RCENTER" RCENTER)
                                    (cons "ROUT" ROUT)
                                    (cons "RIN" RIN)
                                    (cons "CUT" CUT)
                                    (cons "FILL" FILL)
                                    (cons "CUTDITCHSLOPE" CUTDITCHSLOPE)
                                    (cons "CUTDITCHDEPTH" CUTDITCHDEPTH)
                                    (cons "CUTDITCHWIDTH" CUTDITCHWIDTH)
                              )
     )
     T
    )
   )
  )
  nil
 )
)
(defun RFL:CALCROUNDABOUT (ENT NMAX / A ANG ELEV ENTLIST N RCENTER RIN ROUT SLOPE X Y Z)
 (if (= nil (RFL:GETROUNDABOUTLIST ENT))
  (princ "\nProblem accessing roundabout data!")
  (progn
   (setq ENTLIST (entget ENT))
   (setq ELEV (cdr (assoc "ELEV" RFL:ROUNDABOUTLIST)))
   (setq ANG (cdr (assoc 50 ENTLIST)))
   (setq RFL:ROUNDABOUTP (cdr (assoc 10 ENTLIST)))
   (setq RFL:ROUNDABOUTP (list (car RFL:ROUNDABOUTP) (cadr RFL:ROUNDABOUTP) ELEV))
   
   ; Compute outer circle elevations
   (setq SLOPE (cdr (assoc "SLOPE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTOCLIST nil)
   (setq ROUT (cdr (assoc "ROUT" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car RFL:ROUNDABOUTP) (* ROUT (cos (+ A ANG)))))
    (setq Y (+ (cadr RFL:ROUNDABOUTP) (* ROUT (sin (+ A ANG)))))
    (setq Z (- ELEV (* (/ SLOPE 100.0) (* ROUT (cos A)))))
    (setq RFL:ROUNDABOUTOCLIST (append RFL:ROUNDABOUTOCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute inner circle elevations
   (setq SLOPE (cdr (assoc "GRADE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTICLIST nil)
   (setq RIN (cdr (assoc "RIN" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car RFL:ROUNDABOUTP) (* RIN (cos (+ A ANG)))))
    (setq Y (+ (cadr RFL:ROUNDABOUTP) (* RIN (sin (+ A ANG)))))
    (setq Z (+ (caddr (nth N RFL:ROUNDABOUTOCLIST)) (* (/ SLOPE 100.0) (- ROUT RIN))))
    (setq RFL:ROUNDABOUTICLIST (append RFL:ROUNDABOUTICLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute mount circle elevations
   (setq SLOPE (cdr (assoc "INNERGRADE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTMCLIST nil)
   (setq RCENTER (cdr (assoc "RCENTER" RFL:ROUNDABOUTLIST)))
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (+ (car RFL:ROUNDABOUTP) (* RCENTER (cos (+ A ANG)))))
    (setq Y (+ (cadr RFL:ROUNDABOUTP) (* RCENTER (sin (+ A ANG)))))
    (setq Z (+ (caddr (nth N RFL:ROUNDABOUTICLIST)) (* (/ SLOPE 100.0) (- RIN RCENTER))))
    (setq RFL:ROUNDABOUTMCLIST (append RFL:ROUNDABOUTMCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
   ; Compute center circle elevations
   (setq SLOPE (cdr (assoc "CENTERGRADE" RFL:ROUNDABOUTLIST)))
   (setq RFL:ROUNDABOUTCCLIST nil)
   (setq N 0)
   (while (< N NMAX)
    (setq A (/ (* 2.0 pi N) NMAX))
    (setq X (car RFL:ROUNDABOUTP))
    (setq Y (cadr RFL:ROUNDABOUTP))
    (setq Z (+ (caddr (nth N RFL:ROUNDABOUTMCLIST)) (* (/ SLOPE 100.0) (- RCENTER 0.0))))
    (setq RFL:ROUNDABOUTCCLIST (append RFL:ROUNDABOUTCCLIST (list (list X Y Z))))
    (setq N (1+ N))
   )
  )
 )
)
(defun RFL:CALCROUNDABOUTZ (ENT P / A ANG ELEV ENTLIST PO PI RCENTER RIN ROUT SLOPE X Y Z ZOUT ZIN ZMOUNT ZCENTER)
 (setq Z nil)
 (if (= nil (RFL:GETROUNDABOUTLIST ENT))
  (princ "\nProblem accessing roundabout data!")
  (progn
   (setq ENTLIST (entget ENT))
   (setq ELEV (cdr (assoc "ELEV" RFL:ROUNDABOUTLIST)))
   (setq ANG (cdr (assoc 50 ENTLIST)))
   (setq RFL:ROUNDABOUTP (cdr (assoc 10 ENTLIST)))
   (setq RFL:ROUNDABOUTP (list (car RFL:ROUNDABOUTP) (cadr RFL:ROUNDABOUTP) ELEV))
   (setq D (distance RFL:ROUNDABOUTP P))
   (setq A (- (angle RFL:ROUNDABOUTP P) ANG))
   
   (setq ROUT (cdr (assoc "ROUT" RFL:ROUNDABOUTLIST)))
   (setq RIN (cdr (assoc "RIN" RFL:ROUNDABOUTLIST)))
   (setq RCENTER (cdr (assoc "RCENTER" RFL:ROUNDABOUTLIST)))
   
   ; Compute outer circle elevation
   (setq SLOPE (cdr (assoc "SLOPE" RFL:ROUNDABOUTLIST)))
   (setq ZOUT (- ELEV (* (/ SLOPE 100.0) (* ROUT (cos A)))))
   
   ; Compute inner circle elevation
   (setq SLOPE (cdr (assoc "GRADE" RFL:ROUNDABOUTLIST)))
   (setq ZIN (+ ZOUT (* (/ SLOPE 100.0) (- ROUT RIN))))

   ; Compute mount circle elevation
   (setq SLOPE (cdr (assoc "INNERGRADE" RFL:ROUNDABOUTLIST)))
   (setq ZMOUNT (+ ZIN (* (/ SLOPE 100.0) (- RIN RCENTER))))

   ; Compute center circle elevation
   (setq SLOPE (cdr (assoc "CENTERGRADE" RFL:ROUNDABOUTLIST)))
   (setq ZCENTER (+ ZMOUNT (* (/ SLOPE 100.0) (- RCENTER 0.0))))
   
   (cond ((>= D RIN)
          (setq Z (+ ZIN (* (/ (- D RIN) (- ROUT RIN)) (- ZOUT ZIN))))
         )
         ((>= D RCENTER)
          (setq Z (+ ZMOUNT (* (/ (- D RCENTER) (- RIN RCENTER)) (- ZIN ZMOUNT))))
         )
         ((>= D 0.0)
          (setq Z (+ ZCENTER (* (/ (- D 0.0) (- RCENTER 0.0)) (- ZMOUNT ZCENTER))))
         )
   )
  )
 )
 Z
)
(defun C:DRAWROUNDABOUT (/ *error* A ANG ANGBASE ANGDIR CCLIST CMDECHO CUT CUTOS DRAW3DP ELEV ENT ENTLIST FILL FIXLIST FLAG ICLIST MLIST N NMAX NODE NODE1 NODE2 OBSURFACE OGLINE OGOFFSETLIST ORTHOMODE OCLIST OSMODE P P1 P2 PLIST PLISTD PREVENT R RCENTER REP RIN ROUT SLOPE SWATH TOELIST X Y Z Z1 Z1CUT Z2)
 (command "._UNDO" "M")
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGBASE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "OSMODE" OSMODE)
  (princ msg)
  ;(setq *error* nil)
 )
 (defun DRAW3DP (PLIST CLOSED / P)
  (command "._3DPOLY")
  (foreach P PLIST
   (command P)
  )
  (if CLOSED
   (command "C")
   (command "")
  )
  T
 )
 (defun FIXLIST (PLIST MINMAX / P Z)
  (setq TMPLIST nil Z nil)
  (if (= "MINIMUM" MINMAX)
   (setq Z (apply 'min (mapcar '(lambda (P) (caddr P)) PLIST)))
   (if (= "MAXIMUM" MINMAX)
    (setq Z (apply 'max (mapcar '(lambda (P) (caddr P)) PLIST)))
   )
  )
  (if Z
   (apply 'list (mapcar '(lambda (P) (list (car P) (cadr P) Z)) PLIST))
   PLIST
  )
 )
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 
 (setq PREVENT nil)
 (if (= nil (RFL:GETROUNDABOUTLIST (setq ENT (car (entsel "\nSelect roundabout block : ")))))
  (princ "\nProblem accessing roundabout data!")
  (progn
   (setq ELEV (cdr (assoc "ELEV" RFL:ROUNDABOUTLIST)))
   (setq ENTLIST (entget ENT))
   (setq NMAX 0)
   (while (< NMAX 3)
    (if (= nil (setq NMAX (getint "\nEnter number of circulatory segments <60> : ")))
     (setq NMAX 60)
    )
    (if (< NMAX 3) (princ "\nMust be at least 3!"))
   )
   (RFL:CALCROUNDABOUT ENT NMAX)
   (setq P (cdr (assoc 10 ENTLIST)))
   (setq P (list (car P) (cadr P) ELEV))
   (setq ANG (cdr (assoc 50 ENTLIST)))
   (if RFL:ROUNDABOUTCCLIST
    (progn
     (initget "GRADE MINIMUM MAXIMUM")
     (if (= nil (setq REP (getkword "\nInner apron: Use fixed grade, minimum or maximum (Grade/Minimum/<Maximum>) : ")))
      (setq REP "MAXIMUM")
     )
     (if (/= "GRADE" REP) (setq RFL:ROUNDABOUTCCLIST (FIXLIST RFL:ROUNDABOUTCCLIST REP)))
    )
   )
   ; Draw closed 3D outer, inner, and center circle polyline
   (DRAW3DP RFL:ROUNDABOUTOCLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (DRAW3DP RFL:ROUNDABOUTICLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   (DRAW3DP RFL:ROUNDABOUTMCLIST T)
   (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   ;(DRAW3DP RFL:ROUNDABOUTCCLIST T)
   ;(setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
   
   (setq TOELIST nil)
   (if (setq OBSURFACE (RFL:GETC3DSURFACE))
    (progn
     (setq SWATH 0.0)
     (while (<= SWATH 0.0)
      (if (= nil (setq SWATH (getdist "\nEnter swath distance <100.0> : ")))
       (setq SWATH 100.0)
       (if (<= SWATH 0.0) (princ "\nMust be greater then 0.0!"))
      )
     )
     (setq FILL (cdr (assoc "FILL" RFL:ROUNDABOUTLIST)))
     (setq CUT (cdr (assoc "CUT" RFL:ROUNDABOUTLIST)))
     (setq N 0)
     (while (< N NMAX)
      (setq A (/ (* 2.0 pi N) NMAX))
      (setq OGLINE nil)
      (setq P1 (nth N RFL:ROUNDABOUTOCLIST))
      (setq Z1 (caddr P1))
      (setq Z1CUT (- Z1 (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))))
      (setq CUTOS (+ (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                        (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                     )
                     (cdr (assoc "CUTDITCHWIDTH" RFL:ROUNDABOUTLIST))
                  )
      )
      (setq P1 (list (car P1) (cadr P1)))
      (setq P2 (list (+ (car P1) (* SWATH (cos (+ A ANG))))
                     (+ (cadr P1) (* SWATH (sin (+ A ANG))))
               )
      )
      (setq PLIST (list (nth N RFL:ROUNDABOUTCCLIST)
                        (nth N RFL:ROUNDABOUTMCLIST)
                        (nth N RFL:ROUNDABOUTICLIST)
                        (nth N RFL:ROUNDABOUTOCLIST)
                  )
      )
      (if (/= nil (setq OGLINE (RFL:GETSURFACELINE P1 P2 OBSURFACE)))
       (progn
        (setq OGOFFSETLIST nil)
        (foreach NODE OGLINE
         (setq OGOFFSETLIST (append OGOFFSETLIST (list (list (distance P1 (list (car NODE) (cadr NODE))) (caddr NODE)))))
        )
        (setq NODE1 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
              NODE2 (car OGOFFSETLIST)
              OGOFFSETLIST (cdr OGOFFSETLIST)
        )
        (setq FLAG T)
        (setq P2 nil)
        (setq PLISTD nil)
        (while (and FLAG NODE1 NODE2)
         (if (setq P2 (inters NODE1 NODE2 (list 0.0 Z1) (list SWATH (- Z1 (/ SWATH FILL)))))
          (progn
           (setq FLAG nil)
           (setq PLISTD (list (list (+ (car P1) (* (car P2) (cos (+ A ANG))))
                                    (+ (cadr P1) (* (car P2) (sin (+ A ANG))))
                                    (cadr P2)
                              )
                        )
           )
          )
         )
         (if (= nil P2)
          (if (and (setq P2 (inters NODE1 NODE2 (list CUTOS Z1CUT) (list SWATH (+ Z1CUT (/ (- SWATH CUTOS) CUT)))))
                   (<= CUTOS (car P2))
              )
           (progn
            (setq FLAG nil)
            (setq PLISTD (list (list (+ (car P1) 
                                        (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                                           (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                                           (cos (+ A ANG))
                                        )
                                     )
                                     (+ (cadr P1)
                                        (* (cdr (assoc "CUTDITCHSLOPE" RFL:ROUNDABOUTLIST)) 
                                           (cdr (assoc "CUTDITCHDEPTH" RFL:ROUNDABOUTLIST))
                                           (sin (+ A ANG))
                                        )
                                     )
                                     Z1CUT
                                )
                                (list (+ (car P1) 
                                         (* CUTOS
                                            (cos (+ A ANG))
                                         )
                                      )
                                      (+ (cadr P1)
                                         (* CUTOS
                                            (sin (+ A ANG))
                                         )
                                      )
                                      Z1CUT
                                )
                                (list (+ (car P1) (* (car P2) (cos (+ A ANG))))
                                      (+ (cadr P1) (* (car P2) (sin (+ A ANG))))
                                      (cadr P2)
                                )
                         )
            )
           )
          )
         )
         (setq NODE1 NODE2
               NODE2 (car OGOFFSETLIST)
               OGOFFSETLIST (cdr OGOFFSETLIST)
         )
        )
       )
      )
      (if PLISTD (setq PLIST (append PLIST PLISTD)))
      (if PLIST
       (progn
        (setq TOELIST (append TOELIST (list (last PLIST))))
        (DRAW3DP PLIST nil)
        (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
       )
      )
      (setq N (1+ N))
     )
     (if TOELIST
      (progn
       (DRAW3DP TOELIST T)
       (setq ENT (entlast))(RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      )
     )
    )
   )
  )
 )
 
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
 T
)
(defun C:FIXROUNDABOUT (/ *error* ACTIVEDOC ACTIVESPACE ANG ANGBASE ANGDIR D D1 D2 D3 ENT ENT2 ENTLIST ENTOBJ GRADE OBSURFACE P P1 P2 P3 Z Z1 Z2 Z3)
 (command "._UNDO" "M")
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (defun *error* (msg)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (princ msg)
  ;(setq *error* nil)
 )
 (vl-load-com)
 (setq ACTIVEDOC (vla-get-activedocument (vlax-get-acad-object)))
 (setq ACTIVESPC
       (vlax-get-property ACTIVEDOC
        (if (or (eq acmodelspace (vla-get-activespace ACTIVEDOC)) (eq :vlax-true (vla-get-mspace ACTIVEDOC)))
         'modelspace
         'paperspace
        )
       )
 )
 (if (setq ENT (car (entsel "\nSelect roundabout block : ")))
  (progn
   (setq ENTLIST (entget ENT))
   (if (and (= "INSERT" (cdr (assoc 0 ENTLIST)))
            (= "ROUNDABOUT" (strcase (cdr (assoc 2 ENTLIST))))
            (= 1 (cdr (assoc 66 ENTLIST)))
       )
    (progn
     (princ "\nNote: Selecting no surface will use elevation of selected points.")
     (setq OBSURFACE (RFL:GETC3DSURFACE))
     (princ "\nNote: 1 point  = roundabout elevation adjusted to elevation of point, slope set to 0.0%")
     (princ "\n      2 points = roundabout elevation adjusted to average elevation of points, slope and rotation adjusted")
     (princ "\n      3 points = roundabout elevation adjusted to elevation of point on plane, slope and rotation adjusted")
     (setq P1 nil P2 nil P3 nil)
     (if (/= nil (setq P1 (getpoint "\nSelect first point : ")))
      (if (= nil (setq P2 (getpoint "\nSelect second point (<return> for single point) : ")))
       (progn ; Single point
        (if OBSURFACE
         (setq P1 (list (car P1) (cadr P1))
               Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
         )
         (setq Z1 (caddr P1)
               P1 (list (car P1) (cadr P1))
         )
        )
        (if Z1
         (progn
          (setq ENT2 (entnext ENT))
          (setq ENTLIST (entget ENT2))
          (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
           (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                  (progn
                   (setq ENTLIST (subst (cons 1 (rtos Z1 2 8)) (assoc 1 ENTLIST) ENTLIST))
                   (entmod ENTLIST)
                   (entupd ENT2)
                   (entupd ENT)
                  )
                 )
           )
           (setq ENT2 (entnext ENT2))
           (setq ENTLIST (entget ENT2))
          )
         )
        )
       )
       (if (= nil (setq P3 (getpoint "\nSelect third point (<return> for two points) : ")))
        (progn ; Two points
         (if OBSURFACE
          (setq P1 (list (car P1) (cadr P1))
                Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
                P2 (list (car P2) (cadr P2))
                Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)
          )
          (setq Z1 (caddr P1)
                P1 (list (car P1) (cadr P1))
                Z2 (caddr P2)
                P2 (list (car P2) (cadr P2))
          )
         )
         (if (and Z1 Z2)
          (progn
           (setq ENTLIST (entget ENT))
           (setq P (cdr (assoc 10 ENTLIST)))
           (setq P (list (car P) (cadr P)))
           (if (< Z2 Z1)
            (setq ANG (angle P1 P2))
            (setq ANG (angle P2 P1))
           )
           (setq ENTOBJ (vlax-ename->vla-object ENT))
           (vlax-put-property ENTOBJ 'Rotation ANG)
           (setq D (distance P1 P2))
           (setq D1 (/ (+ (- (expt (distance P1 P) 2) (expt (distance P2 P) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P) 2) (expt (distance P1 P) 2)) (expt D 2)) (* 2 D)))
           (setq Z (+ Z1 (* (- Z2 Z1) (/ D1 D))))
           (setq GRADE (* 100.0 (/ (- (max Z1 Z2) (min Z1 Z2)) D)))
           (setq ENT2 (entnext ENT))
           (setq ENTLIST (entget ENT2))
           (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
            (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos Z 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
                  ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos GRADE 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
            )
            (setq ENT2 (entnext ENT2))
            (setq ENTLIST (entget ENT2))
           )
          )
         )
        )
        (progn ; Three points
         (if OBSURFACE
          (setq P1 (list (car P1) (cadr P1))
                Z1 (RFL:GETSURFACEPOINT P1 OBSURFACE)
                P2 (list (car P2) (cadr P2))
                Z2 (RFL:GETSURFACEPOINT P2 OBSURFACE)
                P3 (list (car P3) (cadr P3))
                Z3 (RFL:GETSURFACEPOINT P3 OBSURFACE)
          )
          (setq Z1 (caddr P1)
                P1 (list (car P1) (cadr P1))
                Z2 (caddr P2)
                P2 (list (car P2) (cadr P2))
                Z3 (caddr P3)
                P3 (list (car P3) (cadr P3))
          )
         )
         (if (and Z1 Z2 Z3)
          (progn
           (setq D (distance P1 P2))
           (setq D1 (/ (+ (- (expt (distance P1 P3) 2) (expt (distance P2 P3) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P3) 2) (expt (distance P1 P3) 2)) (expt D 2)) (* 2 D)))
           (setq D3 (sqrt (- (expt (distance P1 P3) 2) (expt D1 2))))
           (if (< (sin (- (angle P1 P2) (angle P1 P3))) 0.0) (setq D3 (* -1.0 D3)))
           (setq G1 (/ (- Z2 Z1) D))
           (setq P (list (+ (car P1) (* D1 (cos (angle P1 P2))))
                         (+ (cadr P1) (* D1 (sin (angle P1 P2))))
                   )
           )
           (setq Z (+ Z1 (* (- Z2 Z1) (/ D1 D))))
           (setq G2 (/ (- Z3 Z) D3))
           (setq ENTLIST (entget ENT))
           (setq P (cdr (assoc 10 ENTLIST)))
           (setq P (list (car P) (cadr P)))
           (setq D1 (/ (+ (- (expt (distance P1 P) 2) (expt (distance P2 P) 2)) (expt D 2)) (* 2 D)))
           (setq D2 (/ (+ (- (expt (distance P2 P) 2) (expt (distance P1 P) 2)) (expt D 2)) (* 2 D)))
           (setq D3 (sqrt (- (expt (distance P1 P) 2) (expt D1 2))))
           (if (< (sin (- (angle P1 P2) (angle P1 P))) 0.0) (setq D3 (* -1.0 D3)))
           (setq Z (+ Z1 (* D1 G1) (* D3 G2)))
           (setq GRADE (* 100.0 (sqrt (+ (expt G1 2) (expt G2 2)))))
           (setq ANG (+ 0.0 (- (angle P1 P2) (atan (/ G2 G1)))))
           (setq ENTOBJ (vlax-ename->vla-object ENT))
           (vlax-put-property ENTOBJ 'Rotation ANG)
           (setq ENT2 (entnext ENT))
           (setq ENTLIST (entget ENT2))
           (while (= "ATTRIB" (cdr (assoc 0 ENTLIST)))
            (cond ((= "ELEV" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos Z 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
                  ((= "SLOPE" (strcase (cdr (assoc 2 ENTLIST))))
                   (progn
                    (setq ENTLIST (subst (cons 1 (rtos GRADE 2 8)) (assoc 1 ENTLIST) ENTLIST))
                    (entmod ENTLIST)
                    (entupd ENT2)
                    (entupd ENT)
                   )
                  )
            )
            (setq ENT2 (entnext ENT2))
            (setq ENTLIST (entget ENT2))
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 T
)
(defun C:TPROFROUNDABOUT (/ *error* ANGBASE ANGDIR CMDECHO ENT INC ORTHOMODE OSMODE P STA STA1 STA2 TMP Z)
 (command "._UNDO" "M")
 (defun *error* (msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGBASE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "OSMODE" OSMODE)
  (princ msg)
  ;(setq *error* nil)
 )
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (if (and RFL:ALIGNLIST (RFL:GETROUNDABOUTLIST (setq ENT (car (entsel "\nSelect roundabout block : ")))))
  (progn
   (RFL:PROFDEF)
   (setq STA1 nil)
   (while (= nil STA1)
    (if (setq P (getpoint "\nStart point : "))
     (if (= nil (setq STA1 (car (RFL:STAOFF P))))
      (if (< (distance P (cadr (car RFL:ALIGNLIST))) (distance P (caddr (last RFL:ALIGNLIST))))
       (setq STA1 (caar RFL:ALIGNLIST))
       (setq STA1 (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
      )
     )
    )
   )
   (setq STA2 nil)
   (while (= nil STA2)
    (if (setq P (getpoint "\nEnd point : "))
     (if (= nil (setq STA2 (car (RFL:STAOFF P))))
      (if (< (distance P (cadr (car RFL:ALIGNLIST))) (distance P (caddr (last RFL:ALIGNLIST))))
       (setq STA2 (caar RFL:ALIGNLIST))
       (setq STA2 (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
      )
     )
    )
   )
   (setq INC 0.0)
   (while (<= INC 0.0)
    (if (= nil (setq INC (getdist "\nEnter increment <1> : ")))
     (setq INC 1.0)
    )
   )
   (if (< STA2 STA1) (setq TMP STA1 STA1 STA2 STA2 TMP))
   (setq STA (float (+ INC (* INC (fix (+ 0.5 (/ STA1 INC)))))))
   (command "._PLINE")
   (while (<= STA STA2)
    (if (setq P (RFL:XY (list STA 0.0)))
     (if (setq Z (RFL:CALCROUNDABOUTZ ENT P))
      (command (RFL:PROFPOINT STA Z))
     )
    )
    (setq STA (+ STA INC))
   )
   (command "")
  )
 )
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
 T
);
;
;     Program written by Robert Livingston, 2018-03-12
;
;     C:QSADD adds a surface to a selected cross section
;
;
(defun C:QSADD (/ *error* ANGBASE ANGDIR C CMDECHO ENT ENTLIST ENTSET GRIDLIST OBSURFACE ORTHOMODE OSMODE P P1 P2 STA)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 
 (defun *error* (msg)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (print msg)
 )
 
 (if RFL:ALIGNLIST
  (if (setq OBSURFACE (RFL:GETC3DSURFACE))
   (progn
    (setq C 0)
    (setq ENTSET (ssget '((0 . "INSERT"))))
    (while (< C (sslength ENTSET))
     (setq ENT (ssname ENTSET C)
           C (1+ C)
     )
     (if (setq GRIDLIST (RFL:GETGRID ENT))
      (progn
       (setq STA (atof (vl-string-subst "" "+" (vl-string-left-trim "Sta: " (cdr (assoc "TITLE" GRIDLIST))))))
       (if (and (>= STA (caar RFL:ALIGNLIST))
                (<= STA (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
           )
        (progn
         (setq P1 (RFL:XY (list STA (cdr (assoc "BX" GRIDLIST)))))
         (setq P2 (RFL:XY (list STA (+ (cdr (assoc "BX" GRIDLIST)) (cdr (assoc "W" GRIDLIST))))))
         (if (and P1 P2)
          (progn
           (setq PLIST (RFL:GETSURFACELINE P1 P2 OBSURFACE))
           (setq OSLIST nil)
           (foreach P PLIST
            (setq OSLIST (append OSLIST (list (list (+ (distance (list (car P) (cadr P)) P1) (cdr (assoc "BX" GRIDLIST))) (caddr P)))))
           )
           (if OSLIST
            (progn
             (command "._PLINE")
             (foreach P OSLIST
              (progn
               (command (list (+ (- (car (cdr (assoc "BP" GRIDLIST))) (cdr (assoc "BX" GRIDLIST))) (car P))
                              (+ (cadr (cdr (assoc "BP" GRIDLIST))) (* (cdr (assoc "VEXAG" GRIDLIST)) (- (cadr P) (cdr (assoc "BY" GRIDLIST)))))
                        )
               )
              )
             )
             (command "")
            )
           )
          )
         )
        )
        (princ "\n!!! STATION NOT WITHIN ALIGNMENT !!!")
       )
      )
     )
    )
   )
  )
  (princ "\n!!! No Alignment Defined !!!")
 )
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 T
);
;
;     Program written by Robert Livingston, 2016-09-22
;
;     C:QSDAYLIGHT is a utility for extracting and drawing daylight polylines on the plan
;
;
(defun C:QSDAYLIGHT (/ C C1 C2 DLIST1 DLIST2 ENT ENT1 ENT2 ENTLIST ENTSET NODE OSLIST ORTHOMODE OSMODE P PBASE PLIST1 PLIST2 REP STA TMP)
;(defun C:QSDAYLIGHT ()
 (setq OSMODE (getvar "OSMODE"))
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setq DLIST1 nil DLIST2 nil)
 (princ (strcat "\nMin alignment = " (RFL:STATXT (caar RFL:ALIGNLIST)) ", min profile = " (RFL:STATXT (caar RFL:PVILIST))))
 (C:QSECTION)
 (setq STA (cdr (assoc "STA" RFL:QSECTIONLIST)))
 (while STA
  (setq OSLIST nil PLIST1 nil PLIST2 nil TMP T)
  (setq PBASE (cadr (assoc "PBASE" RFL:QSECTIONLIST)))
  (setq ENTSET (cadr (assoc "ENTITIES" RFL:QSECTIONLIST)))
  (foreach NODE ENTSET
   (if (or (= "LWPOLYLINE" (cdr (assoc 0 (setq ENTLIST (entget (setq ENT (handent NODE)))))))
           (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
       )
    (if (= nil PLIST1)
     (setq PLIST1 (RFL:GETPLIST ENT))
     (if (= nil PLIST2)
      (setq PLIST2 (RFL:GETPLIST ENT))
      (setq TMP nil)
     )
    )
   )
  )
  (if (and TMP PLIST1 PLIST2)
   (progn
    (setq C1 1)
    (while (< C1 (length PLIST1))
     (setq C2 1)
     (while (< C2 (length PLIST2))
      (command "._DELAY" 0)
      (if (setq P (inters (nth (1- C1) PLIST1) (nth C1 PLIST1)
                          (nth (1- C2) PLIST2) (nth C2 PLIST2)
                  )
          )
       (setq OSLIST (append OSLIST (list (- (car P) (car PBASE)))))
      )
      (setq C2 (1+ C2))
     )
     (setq C1 (1+ C1))
    )
    (if OSLIST
     (progn
      (setq OSLIST (vl-sort OSLIST '<))
      (if (< (car OSLIST) 0.0)
       (if (setq P (RFL:XY (list STA (car OSLIST))))
        (progn
         (princ (strcat "\n  Left Offset = " (rtos (car OSLIST))))
         (setq DLIST1 (append DLIST1 (list P)))
        )
       )
      )
      (if (> (last OSLIST) 0.0)
       (if (setq P (RFL:XY (list STA (last OSLIST))))
        (progn
         (princ (strcat "\n  Right Offset = " (rtos (last OSLIST))))
         (setq DLIST2 (append DLIST2 (list P)))
        )
       )
      )
      (initget "Yes No")
      (if (= "No" (getkword "\nAdd another (<Yes>/No) ? "))
       (setq STA nil)
       (progn
        (C:QS+)
        (setq STA (cdr (assoc "STA" RFL:QSECTIONLIST)))
       )
      )
     )
    )
   )
   (setq STA nil)
  )
 )
 (setvar "ORTHOMODE" 0)
 (setvar "OSMODE" 0)
 (if (> (length DLIST1) 1)
  (progn
   (command "._PLINE")
   (foreach P DLIST1
    (command P)
   )
   (command "")
  )
 )
 (if (> (length DLIST2) 1)
  (progn
   (command "._PLINE")
   (foreach P DLIST2
    (command P)
   )
   (command "")
  )
 )
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
 nil
);
;
;     Program written by Robert Livingston, 2015-01-29
;
;     C:QSECTION is a utility for drawing a cross section at a specified station
;
;
(defun C:QSECTION (/ *error* ANGBASE ATTREQ CMDECHO DESLAYER DESLAYERENT GETQSECTIONLIST INC INFILE INFILE2 INFILENAME INLINE INLINE2 MATCHGRIDENT OGLAYER OGLAYERENT OSMODE ORTHOMODE PBASE SHEIGHT STA STA1 STA2 STALIST)
;(defun C:QSECTION ()
 (setq ATTREQ (getvar "ATTREQ"))
 (setvar "ATTREQ" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setq ORTHOMODE (getvar "ORTHOMODE"))

 (defun *error* (msg)
  (setvar "ATTREQ" ATTREQ)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (if (not INFILE) (close INFILE))
  (if (not INFILE2) (close INFILE2))
  ;(setq *error* nil)
  (print msg)
 )
 
 (defun GETQSECTIONLIST (/ DCIRCLE OBSURFACE REP SWATH THEIGHT VEXAG)
  (setq DCIRCLE nil)
  (setq RFL:QSECTIONALIGNLIST nil)
  (setq RFL:QSECTIONPROFILELIST nil)
  (setq VEXAG 10.0)
  (setq REP (getdist (strcat "\nVertical exaggeration <" (rtos VEXAG) "> : ")))
  (if (/= nil REP) (setq VEXAG REP))
  (setq SWATH 100.0)
  (setq REP (getdist (strcat "\nSwath width <" (rtos SWATH) "> : ")))
  (if (/= nil REP) (setq SWATH REP))
  (setq THEIGHT 5.0)
  (setq REP (getdist (strcat "\nText height <" (rtos THEIGHT) "> : ")))
  (if (/= nil REP) (setq THEIGHT REP))
  (initget "Yes No Block Template")
  (setq REP (getkword "\nDraw circle at design elevation (<Yes>/No/Block/Template) ? "))
  (if (= "No" REP)
   (setq DCIRCLE 0)
   (if (= "Block" REP)
    (progn
     (setq DCIRCLE nil)
     (while (= nil DCIRCLE)
      (setq DCIRCLE (car (entsel "\nSelect block (<return> to enter name) : ")))
      (if (= nil DCIRCLE)
       (setq DCIRCLE (getstring "\nBlock name : "))
       (setq DCIRCLE (cdr (assoc 2 (entget DCIRCLE))))
      )
      (if (/= nil DCIRCLE)
       (if (= nil (tblsearch "BLOCK" DCIRCLE))
        (setq DCIRCLE nil)
       )
      )
     )
    )
    (if (= "Template" REP)
     (progn
      (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
       (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
      )
      (setq INFILENAME (getfiled "Select a Template File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "tpl" 2))
      (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory INFILENAME) "\\"))
      (setq INFILE (open INFILENAME "r"))
      (while (setq INLINE (read-line INFILE))
       (if (= "STA" (RFL:COLUMN INLINE 1 ","))
        (progn
         (setq TPLLIST nil)
         (setq STALIST (list (atof (RFL:COLUMN INLINE 2 ",")) (atof (RFL:COLUMN INLINE 3 ","))))
         (setq INFILE2 (open (RFL:COLUMN INLINE 4 ",") "r"))
         (while (setq INLINE2 (read-line INFILE2))
          (setq TPLLIST (append TPLLIST (list INLINE2)))
         )
         (close INFILE2)
         (setq DCIRCLE (append DCIRCLE (list (list STALIST TPLLIST))))
        )
        (setq DCIRCLE (append DCIRCLE (list INLINE)))
       )
      )
      (close INFILE)
     )
     (setq DCIRCLE 1)
    )
   )
  )
  (setq OBSURFACE nil)
  (setq REP "Yes")
  (while (= "Yes" REP)
   (setq OBSURFACE (append OBSURFACE (list (RFL:GETC3DSURFACE))))
   (initget "Yes No")
   (setq REP (getkword "\nAdd another (Yes/<No>) : "))
  )
  (setq MATCHGRIDENT (car (entsel "\nSelect grid to match (<return> for none) : ")))
  (setq OGLAYER (if (setq OGLAYERENT (car (entsel "\nSelect OG layer to match (<return> for none) : ")))
                 (cdr (assoc 8 (entget OGLAYERENT)))
                 CLAYER
                )
  )
  (setq DESLAYER (if (setq DESLAYERENT (car (entsel "\nSelect design layer to match (<return> for none) : ")))
                  (cdr (assoc 8 (entget DESLAYERENT)))
                  CLAYER
                 )
  )
  (setq RFL:QSECTIONLIST (list (cons "VEXAG" VEXAG)
                               (cons "SWATH" SWATH)
                               (cons "THEIGHT" THEIGHT)
                               (cons "DCIRCLE" DCIRCLE)
                               (cons "OBSURFACE" OBSURFACE)
                               (cons "MATCHGRIDENT" MATCHGRIDENT)
                               (cons "OGLAYER" OGLAYER)
                               (cons "DESLAYER" DESLAYER)
                         )
  )
 )
 (if (= nil RFL:ALIGNLIST)
  (princ "\n!!! No Alignment Defined !!!")
  (progn
   (if (= nil RFL:QSECTIONLIST) (GETQSECTIONLIST))
   (while (= "" (setq STA (getstring "\nStation (<return> to pick point, 'P' to pick point, 'M' multiple stations) : ")))
    (GETQSECTIONLIST)
   )
   (if (= "P" (strcase (substr STA 1 1)))
    (setq STA (car (RFL:STAOFF (getpoint "\nPick point for section : "))))
    (if (= "M" (strcase (substr STA 1 1)))
     (setq STA (list (getreal "\nStart Station : ")
                     (getreal "\nEnd Station : ")
                     (getreal "\nStation Increment : ")
               )
     )
     (setq STA (atof STA))
    )
   )
   (setq PBASE (getpoint "\nBase point : "))
   (setvar "OSMODE" 0)
   (setvar "ORTHOMODE" 0)
   (if (listp STA)
    (progn
     (setq STA1 (car STA)
           STA2 (cadr STA)
           INC (caddr STA)
     )
     (setq SHEIGHT (getreal "\nSection height spacing : "))
     (setq STA STA1)
     (while (<= STA STA2)
      (RFL:QSECTION STA
                    (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                    PBASE
                    nil
                    (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                    (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                    (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                    (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
      )
      (setq STA (+ STA INC))
      (setq PBASE (list (car PBASE) (+ (cadr PBASE) SHEIGHT)))
     )
    )
    (RFL:QSECTION STA
                  (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                  PBASE
                  nil
                  (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                  (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                  (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                  (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
    )
   )
  )
 )
 (setvar "ATTREQ" ATTREQ)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (eval nil)
)
(defun RFL:QSECTION (STA SWATH PBASE ZBASE VEXAG THEIGHT DCIRCLE OBSURFACE / A ADDHANDLE AFLAG ALLIST ALSAVE C CLAYER D DX DY DY2 DZ ENT ENTLIST ENTSET H HANDENTLIST GETFIRSTLIST GETTPL ISABOVE NODE OX P P0 P1 P2 PA PB OSLIST OSLIST2 PLIST PVISAVE S1 S2 SLIST SLISTDEFAULT TLIST TLISTL TLISTCL TLISTFL TLISTR TLISTCR TLISTFR TMP TOL TX TY Z ZHEIGHT)
;(defun RFL:QSECTION (STA SWATH PBASE ZBASE VEXAG THEIGHT DCIRCLE OBSURFACE)
 (setq CLAYER (getvar "CLAYER"))
 (setq TOL 0.0001)
 (defun GETFIRSTLIST (OSLIST / FIRSTLIST)
  (setq FIRSTLIST nil)
  (while (and OSLIST
              (/= (car OSLIST) "NewLine")
         )
   (setq FIRSTLIST (append FIRSTLIST (list (car OSLIST))))
   (setq OSLIST (cdr OSLIST))
  )
  FIRSTLIST
 )
 (defun ISABOVE (P OSLIST / C RES)
  (if P
   (if OSLIST
    (progn
     (setq C 1)
     (while (< C (length OSLIST))
      (if (and (>= (car P) (car (nth (1- C) OSLIST)))
               (<= (car P) (car (nth C OSLIST)))
          )
       (if (> (cadr P)
              (+ (cadr (nth (1- C) OSLIST))
                 (* (- (car P) (car (nth (1- C) OSLIST)))
                    (/ (- (cadr (nth C OSLIST)) (cadr (nth (1- C) OSLIST)))
                       (- (car (nth C OSLIST)) (car (nth (1- C) OSLIST)))
                    )
                 )
              )
           )
        (setq RES T)
        (setq RES nil)
       )
      )
      (setq C (1+ C))
     )
    )
    (setq RES nil)
   )
   (setq RES nil)
  )
  RES
 )
 (if (or RFL:QSECTIONALIGNLIST RFL:QSECTIONPROFILELIST)
  (setq AFLAG nil)
  (setq AFLAG T)
 )
 (defun GETTPL (STA DCIRCLE / NODE TPLLIST)
  (if (listp (car DCIRCLE))
   (progn
    (setq TPLLIST nil)
    (foreach NODE DCIRCLE
     (if (and (>= STA (car (car NODE)))
              (< STA (cadr (car NODE)))
         )
      (setq TPLLIST (cadr NODE))
     )
    )
    TPLLIST
   )
   DCIRCLE
  )
 )
 (defun ADDHANDLE (/ C ENT FLAG NAME)
  (setq ENT (cdr (assoc 5 (entget (entlast)))))
  (setq C 0)
  (setq FLAG T)
  (while (and FLAG (< C (length HANDENTLIST)))
   (if (= ENT (nth C HANDENTLIST)) (setq FLAG nil))
   (setq C (+ C 1))
  )
  (if FLAG (setq HANDENTLIST (append HANDENTLIST (list ENT))))
 )
 (setq HANDENTLIST nil)
 (setq P0 (RFL:XY (list STA 0.0)))
 (setq P1 (RFL:XY (list STA (/ SWATH -2.0))))
 (setq P2 (RFL:XY (list STA (/ SWATH 2.0))))
 (setq PLIST nil)
 (foreach NODE OBSURFACE
  (setq PLIST (append PLIST (RFL:GETSURFACELINE P1 P2 NODE)))
  (setq PLIST (append PLIST (list "NewLine")))
 )
 (if (/= nil PLIST)
  (progn
   (if (= nil ZBASE)
    (progn
     (foreach P PLIST
      (if (/= "NewLine" P)
       (if (= nil ZBASE)
        (setq ZBASE (caddr P))
        (if (< (caddr P) ZBASE) (setq ZBASE (caddr P)))
       )
      )
     )
    )
   )
   (setq ZHEIGHT nil)
   (foreach P PLIST
    (if (/= "NewLine" P)
     (if (= nil ZHEIGHT)
      (setq ZHEIGHT (caddr P))
      (if (> (caddr P) ZHEIGHT) (setq ZHEIGHT (caddr P)))
     )
    )
   )
   (setq D (/ SWATH 2.0))
   (setq OSLIST nil)
   (foreach P PLIST
    (if (= P "NewLine")
     (setq OSLIST (append OSLIST (list "NewLine")))
     (setq OSLIST (append OSLIST (list (list (- (distance (list (car P) (cadr P)) P1) D) (caddr P)))))
    )
   )
   (setq Z (RFL:ELEVATION STA))
   (setq ENTLIST (list (cons 0 "TEXT")
                       (cons 1 (strcat "Sta: "
                                       (RFL:STATXT STA)
                                       (if Z
                                        (strcat " / Ctrl Elev: " (rtos Z))
                                        (strcat " / Text Elev: " (rtos ZBASE))
                                       )
                               )
                       )
                       (list 10 (car PBASE) (cadr PBASE) 0.0)
                       (list 11 (car PBASE) (cadr PBASE) 0.0)
                       (cons 40 (/ THEIGHT 10.0))
                       (cons 50 0.0)
                       (cons 72 4)
                 )
   )
   (entmake ENTLIST)
   (ADDHANDLE)
   (RFL:DRAWGRID (strcat "Sta: " (RFL:STATXT STA))                           ; Title Text
                 THEIGHT                                                     ; Title Height
                 THEIGHT                                                     ; Title OFFSET
                 (list (- (car PBASE) (/ SWATH 2.0)) (cadr PBASE))           ; Basepoint
                 (/ SWATH -2.0)                                              ; Base Station
                 ZBASE                                                       ; Base Elevation
                 SWATH                                                       ; Grid Width
                 (* (- ZHEIGHT ZBASE) VEXAG)                                 ; Grid Height
                 VEXAG                                                       ; Vertical Exageration
                 THEIGHT                                                     ; Text Height
                 THEIGHT                                                     ; Text OFFSET
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0)       ; Horizontal Grid
                 nil                                                         ; Horizontal Fine Grid
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0)       ; Horizontal Text
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0 VEXAG) ; Vertical Grid
                 nil                                                         ; Vertical Fine Grid
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0 VEXAG) ; Vertical Text
                 "PR-GRID"                                                   ; Grid Layer
                 (getvar "CLAYER")                                           ; Fine Grid Layer
                 (getvar "CLAYER")                                           ; Text Layer
                 nil                                                         ; Label as Station
                 1.0                                                         ; Master Scale
                 1                                                           ; Direction (1 = Left to Right, -1 = Right to Left)
   )
   (if (cdr (assoc "MATCHGRIDENT" RFL:QSECTIONLIST))
    (RFL:MATCHGRID (cdr (assoc "MATCHGRIDENT" RFL:QSECTIONLIST)) (entlast))
   )
   (ADDHANDLE)
   (if (cdr (assoc "OGLAYER" RFL:QSECTIONLIST))
    (setvar "CLAYER" (cdr (assoc "OGLAYER" RFL:QSECTIONLIST)))
   )
   (command "._PLINE")
   (foreach P OSLIST
    (progn
     (if (= "NewLine" P)
      (progn
       (command)
       ;(setq HANDENTLIST (append HANDENTLIST (list (cdr (assoc 5 (entget (entlast)))))))
       (ADDHANDLE)
       (command "._PLINE")
      )
      (command (list (+ (car PBASE) (car P))
                     (+ (cadr PBASE) (* VEXAG (- (cadr P) ZBASE)))
               )
      )
     )
    )
   )
   (command)
   (setq OSLIST2 OSLIST)
   (setq OSLIST (GETFIRSTLIST OSLIST))
   (setvar "CLAYER" CLAYER)
   ;(setq HANDENTLIST (append HANDENTLIST (list (cdr (assoc 5 (entget (entlast)))))))
   (if (listp DCIRCLE)
    (progn
     (if (/= nil Z)
      (progn
       (setq TLISTL nil
             TLISTCL nil
             TLISTFL nil
             TLISTR nil
             TLISTCR nil
             TLISTFR nil
             SLISTDEFAULT (list -2.0 -2.0)
       )
       (setq SLIST (RFL:SUPER STA))
       (foreach NODE (GETTPL STA DCIRCLE)
        (progn
         (setq DX nil DY nil)
         (cond ((= "S" (strcase (RFL:COLUMN NODE 1 ","))) ; S = Default Superelevation
                (setq SLISTDEFAULT (list (atof (RFL:COLUMN NODE 2 ",")) (atof (RFL:COLUMN NODE 3 ","))))
               )
               ((and (= "AP" (strcase (RFL:COLUMN NODE 1 ","))) ; AP = Polyline Alignments
                     AFLAG ; only redo if QSection reset
                )
                (progn
                 (princ "\nLoading control alignments .")
                 (setq ALSAVE RFL:ALIGNLIST)
                 (setq A (atoi (RFL:COLUMN NODE 2 ",")))
                 (setq TMP nil)
                 (if (setq ENTSET (ssget "X" (list (cons 0 "POLYLINE") (cons 8 (RFL:COLUMN NODE 3 ",")))))
                  (progn
                   (setq C 0)
                   (while (< C (sslength ENTSET))
                    (princ ".")
                    (setq ENT (ssname ENTSET C))
                    (command "._CONVERT" "P" "S" ENT "")
                    (setq C (1+ C))
                   )
                  )
                 )
                 (if (setq ENTSET (ssget "X" (list (cons 0 "LWPOLYLINE") (cons 8 (RFL:COLUMN NODE 3 ",")))))
                  (progn
                   (setq C 0)
                   (while (< C (sslength ENTSET))
                    (princ ".")
                    (setq ENT (ssname ENTSET C))
                    (if (setq RFL:ALIGNLIST (RFL:ALIGNDEF ENT (cdr (assoc 10 (entget ENT))) 0.0))
                     (setq TMP (append TMP (list RFL:ALIGNLIST)))
                    )
                    (setq C (1+ C))
                   )
                  )
                 )
                 (setq RFL:QSECTIONALIGNLIST (append RFL:QSECTIONALIGNLIST (list (list A TMP))))
                 (setq RFL:ALIGNLIST ALSAVE)
                )
               )
               ((= "L" (strcase (RFL:COLUMN NODE 1 ","))) ; L = Left control
                (progn
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                       ((= "A" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; A = Alignment offset
                        (progn
                         (setq A (atoi (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq TMP nil)
                         (setq ALSAVE RFL:ALIGNLIST)
                         (foreach RFL:ALIGNLIST (cadr (assoc A RFL:QSECTIONALIGNLIST))
                          (if (setq P (RFL:ALINTERS P0 P1 RFL:ALIGNLIST))
                           (setq TMP (append TMP (list P)))
                          )
                         )
                         (setq RFL:ALIGNLIST ALSAVE)
                         (if TMP
                          (progn
                           (setq P (caadar (vl-sort (mapcar '(lambda (A) (list (distance P0 A) (list A)))  TMP) '(lambda (A B) (< (car A) (car B))))))
                           (if (last TLISTL)
                            (setq DX (- (* -1.0 (car (last TLISTL))) (distance P0 P)))
                            (setq DX 0.0)
                           )
                          )
                          (setq DX 0.0)
                         )
                        )
                       )
                       ((= "Y" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                 )
                 (cond ((= "Y" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                       )
                       ((= "DS-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-L = Left depth super * -1.0
                        (setq DY (+ (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSL = Left depth super
                        (setq DY (+ (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-L = Left super * -1.0
                        (setq DY (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "SL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SL = Left Super
                        (setq DY (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "DS-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-R = Right depth super * -1.0
                        (setq DY (+ (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSR = Right depth super
                        (setq DY (+ (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-R = Right super * -1.0
                        (setq DY (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "SR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SR = Right super
                        (setq DY (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "OX" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; OX = Right offset at X:1
                        (setq OX (atof (substr (RFL:COLUMN NODE 3 ",") 3))
                              DX (/ DY (+ (/ 1.0 OX) (* 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT)))))
                              DY (+ DY (* -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT)) DX))
                        )
                       )
                 )
                 (if (= nil TLISTL)
                  (setq TLISTL (list (list DX (+ Z DY))))
                  (setq TLISTL (append TLISTL (list (list (+ (car (last TLISTL)) DX)  (+ (cadr (last TLISTL)) DY)))))
                 )
                )
               )
               ((= "CL" (strcase (RFL:COLUMN NODE 1 ","))) ; CL = Cut Slope Left
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTCL)
                          (setq PB (last TLISTCL))
                          (if (/= nil TLISTL)
                           (setq PB (last TLISTL))
                          )
                         )
                         (if PB
                          (progn
                           (setq P nil)
                           (setq PA (list (/ SWATH -2.0)
                                          (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C 1)
                           (while (< C (length OSLIST))
                            (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                             (setq P TMP)
                            )
                            (setq C (1+ C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PA (list (/ SWATH -2.0)
                                            (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C 1)
                             (while (< C (length OSLIST))
                              (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                               (setq P TMP)
                              )
                              (setq C (1+ C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PB))
                                  DY (- (cadr P) (cadr PB))
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTCL)
                   (if (= nil TLISTL)
                    (setq TLISTCL (list (list DX (+ Z DY))))
                    (setq TLISTCL (append TLISTCL (list (list (+ (car (last TLISTL)) DX)  (+ (cadr (last TLISTL)) DY)))))
                   )
                   (setq TLISTCL (append TLISTCL (list (list (+ (car (last TLISTCL)) DX)  (+ (cadr (last TLISTCL)) DY)))))
                  )
                 )
                )
               )
               ((= "FL" (strcase (RFL:COLUMN NODE 1 ","))) ; FL = Fill Slope Left
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTFL)
                          (setq PB (last TLISTFL))
                          (if (/= nil TLISTL)
                           (setq PB (last TLISTL))
                          )
                         )
                         (if PB
                          (progn
                           (setq P nil)
                           (setq PA (list (/ SWATH -2.0)
                                          (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C 1)
                           (while (< C (length OSLIST))
                            (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                             (setq P TMP)
                            )
                            (setq C (1+ C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PA (list (/ SWATH -2.0)
                                            (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C 1)
                             (while (< C (length OSLIST))
                              (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                               (setq P TMP)
                              )
                              (setq C (1+ C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PB))
                                  DY (- (cadr P) (cadr PB))
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTFL)
                   (if (= nil TLISTL)
                    (setq TLISTFL (list (list DX (+ Z DY))))
                    (setq TLISTFL (append TLISTFL (list (list (+ (car (last TLISTL)) DX)  (+ (cadr (last TLISTL)) DY)))))
                   )
                   (setq TLISTFL (append TLISTFL (list (list (+ (car (last TLISTFL)) DX)  (+ (cadr (last TLISTFL)) DY)))))
                  )
                 )
                )
               )
               ((= "R" (strcase (RFL:COLUMN NODE 1 ","))) ; R = Right control
                (progn
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                       ((= "A" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; A = Alignment offset
                        (progn
                         (setq A (atoi (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq TMP nil)
                         (setq ALSAVE RFL:ALIGNLIST)
                         (foreach RFL:ALIGNLIST (cadr (assoc A RFL:QSECTIONALIGNLIST))
                          (if (setq P (RFL:ALINTERS P0 P2 RFL:ALIGNLIST))
                           (setq TMP (append TMP (list P)))
                          )
                         )
                         (setq RFL:ALIGNLIST ALSAVE)
                         (if TMP
                          (progn
                           (setq P (caadar (vl-sort (mapcar '(lambda (A) (list (distance P0 A) (list A)))  TMP) '(lambda (A B) (< (car A) (car B))))))
                           (if (last TLISTR)
                            (setq DX (- (distance P0 P) (car (last TLISTR))))
                            (setq DX 0.0)
                           )
                          )
                          (setq DX 0.0)
                         )
                        )
                       )
                       ((= "Y" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                 )
                 (cond ((= "Y" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                       )
                       ((= "DS-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-L = Left depth super * -1.0
                        (setq DY (+ (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSL = Left depth super
                        (setq DY (+ (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-L = Left super * -1.0
                        (setq DY (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "SL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SL = Left Super
                        (setq DY (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "DS-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-R = Right depth super * -1.0
                        (setq DY (+ (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSR = Right depth super
                        (setq DY (+ (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-R = Right super * -1.0
                        (setq DY (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "SR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SR = Right super
                        (setq DY (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "OX" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; OX = Left offset at X:1
                        (setq OX (atof (substr (RFL:COLUMN NODE 3 ",") 3))
                              DX (/ DY (* -1.0 (+ (/ 1.0 OX) (* 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))))
                              DY (+ DY (* 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT)) DX))
                        )
                       )
                 )
                 (if (= nil TLISTR)
                  (setq TLISTR (list (list DX (+ Z DY))))
                  (setq TLISTR (append TLISTR (list (list (+ (car (last TLISTR)) DX)  (+ (cadr (last TLISTR)) DY)))))
                 )
                )
               )
               ((= "CR" (strcase (RFL:COLUMN NODE 1 ","))) ; CR = Cut Slope Right
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTCR)
                          (setq PA (last TLISTCR))
                          (if (/= nil TLISTR)
                           (setq PA (last TLISTR))
                          )
                         )
                         (if PA
                          (progn
                           (setq P nil)
                           (setq PB (list (/ SWATH 2.0)
                                          (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C (1- (length OSLIST)))
                           (while (> C 0)
                            (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                             (setq P TMP)
                            )
                            (setq C (1- C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PB (list (/ SWATH 2.0)
                                            (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C (1- (length OSLIST)))
                             (while (> C 0)
                              (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                               (setq P TMP)
                              )
                              (setq C (1- C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PA))  ;*****
                                  DY (- (cadr P) (cadr PA))  ;*****
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTCR)
                   (if (= nil TLISTR)
                    (setq TLISTCR (list (list DX (+ Z DY))))
                    (setq TLISTCR (append TLISTCR (list (list (+ (car (last TLISTR)) DX)  (+ (cadr (last TLISTR)) DY)))))
                   )
                   (setq TLISTCR (append TLISTCR (list (list (+ (car (last TLISTCR)) DX)  (+ (cadr (last TLISTCR)) DY)))))
                  )
                 )
                )
               )
               ((= "FR" (strcase (RFL:COLUMN NODE 1 ","))) ; FR = Fill Slope Right
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTFR)
                          (setq PA (last TLISTFR))
                          (if (/= nil TLISTR)
                           (setq PA (last TLISTR))
                          )
                         )
                         (if PA
                          (progn
                           (setq P nil)
                           (setq PB (list (/ SWATH 2.0)
                                          (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C (1- (length OSLIST)))
                           (while (> C 0)
                            (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                             (setq P TMP)
                            )
                            (setq C (1- C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PB (list (/ SWATH 2.0)
                                            (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C (1- (length OSLIST)))
                             (while (> C 0)
                              (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                               (setq P TMP)
                              )
                              (setq C (1- C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PA))  ;*****
                                  DY (- (cadr P) (cadr PA))  ;*****
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTFR)
                   (if (= nil TLISTR)
                    (setq TLISTFR (list (list DX (+ Z DY))))
                    (setq TLISTFR (append TLISTFR (list (list (+ (car (last TLISTR)) DX)  (+ (cadr (last TLISTR)) DY)))))
                   )
                   (setq TLISTFR (append TLISTFR (list (list (+ (car (last TLISTFR)) DX)  (+ (cadr (last TLISTFR)) DY)))))
                  )
                 )
                )
               )
         )
        )
       )
       (if (ISABOVE (last TLISTL) OSLIST)
        (setq TLISTL (append TLISTL TLISTFL))
        (setq TLISTL (append TLISTL TLISTCL))
       )
       (if (ISABOVE (last TLISTR) OSLIST)
        (setq TLISTR (append TLISTR TLISTFR))
        (setq TLISTR (append TLISTR TLISTCR))
       )
;       (if (and (= nil TLISTCL) (/= nil TLISTFL))
;        (setq TLISTL (append TLISTL TLISTFL))
;        (if (and (/= nil TLISTCL) (= nil TLISTFL))
;         (setq TLISTL (append TLISTL TLISTCL))
;         (if (and (/= nil TLISTCL) (/= nil TLISTFL))
;          (if (> (car (last TLISTCL)) (car (last TLISTFL)))
;           (setq TLISTL (append TLISTL TLISTCL))
;           (setq TLISTL (append TLISTL TLISTFL))
;          )
;         )
;        )
;       )
;       (if (and (= nil TLISTCR) (/= nil TLISTFR))
;        (setq TLISTR (append TLISTR TLISTFR))
;        (if (and (/= nil TLISTCR) (= nil TLISTFR))
;         (setq TLISTR (append TLISTR TLISTCR))
;         (if (and (/= nil TLISTCR) (/= nil TLISTFR))
;          (if (< (car (last TLISTCR)) (car (last TLISTFR)))
;           (setq TLISTR (append TLISTR TLISTCR))
;           (setq TLISTR (append TLISTR TLISTFR))
;          )
;         )
;        )
;       )
       (if (and (= nil TLISTL) (= nil TLISTR))
        (setq TLIST nil)
        (if (= nil TLISTL)
         (setq TLIST TLISTR)
         (if (= nil TLISTR)
          (setq TLIST (reverse TLISTL))
          (if (< (distance (car TLISTL) (car TLISTR)) TOL)
           (setq TLIST (append (reverse TLISTL) (cdr TLISTR)))
           (setq TLIST (append (reverse TLISTL) TLISTR))
          )
         )
        )
       )
       (if (/= nil TLIST)
        (progn
         (if (cdr (assoc "DESLAYER" RFL:QSECTIONLIST))
          (setvar "CLAYER" (cdr (assoc "DESLAYER" RFL:QSECTIONLIST)))
         )
         (command "._PLINE")
         (foreach P TLIST
          (command (list (+ (car PBASE) (car P))
                         (+ (cadr PBASE) (* VEXAG (- (cadr P) ZBASE)))
                   )
          )
         )
         (command "")
         (setvar "CLAYER" CLAYER)
         (ADDHANDLE)
        )
       )
      )
     )
    )
    (if (= 1 DCIRCLE)
     (if (/= nil Z)
      (progn
       (command "._CIRCLE"
                (list (car PBASE) (+ (cadr PBASE) (* VEXAG (- Z ZBASE))))
                THEIGHT
       )
       (ADDHANDLE)
      )
     )
     (if (/= 0 DCIRCLE)
      (if (/= nil Z)
       (progn
        (entmake (list (cons 0 "INSERT")
                       (cons 2 DCIRCLE)
                       (list 10 (car PBASE) (+ (cadr PBASE) (* VEXAG (- Z ZBASE))) 0.0)
                       (cons 41 1.0)
                       (cons 42 VEXAG)
                       (cons 43 1.0)
                       (cons 50 0.0)
                       (cons 70 0)
                 )
        )
        (ADDHANDLE)
       )
      )
     )
    )
   )
   (if (= nil (assoc "ENTITIES" RFL:QSECTIONLIST))
    (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (list "ENTITIES" HANDENTLIST))))
    (setq RFL:QSECTIONLIST (subst (list "ENTITIES" HANDENTLIST) (assoc "ENTITIES" RFL:QSECTIONLIST) RFL:QSECTIONLIST))
   )
   (if (= nil (assoc "PBASE" RFL:QSECTIONLIST))
    (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (list "PBASE" PBASE))))
    (setq RFL:QSECTIONLIST (subst (list "PBASE" PBASE) (assoc "PBASE" RFL:QSECTIONLIST) RFL:QSECTIONLIST))
   )
   (if (= nil (assoc "STA" RFL:QSECTIONLIST))
    (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (cons "STA" STA))))
    (setq RFL:QSECTIONLIST (subst (cons "STA" STA) (assoc "STA" RFL:QSECTIONLIST) RFL:QSECTIONLIST))
   )
  )
 )
)
(defun C:QS+ (/ ANGBASE ANGDIR CMDECHO INC NODE OSMODE ORTHOMODE REP)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (if (/= nil RFL:QSECTIONLIST)
  (if (/= nil (assoc "PBASE" RFL:QSECTIONLIST))
   (progn
    (if (= nil (cdr (assoc "INC" RFL:QSECTIONLIST)))
     (progn
      (setq INC 20.0)
      (setq REP (getdist (strcat "\nStation increment <" (rtos INC) "> : ")))
      (if (/= nil REP) (setq INC REP))
      (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (cons "INC" INC))))
     )
     (setq INC (cdr (assoc "INC" RFL:QSECTIONLIST)))
    )
    (foreach NODE (cadr (assoc "ENTITIES" RFL:QSECTIONLIST))
     (if (/= nil (entget (handent NODE))) (entdel (handent NODE)))
    )
    (RFL:QSECTION (+ (cdr (assoc "STA" RFL:QSECTIONLIST)) INC)
                  (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                  (cadr (assoc "PBASE" RFL:QSECTIONLIST))
                  nil
                  (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                  (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                  (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                  (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
    )
   )
  )
 )
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (eval nil)
)
(defun C:QS- (/ ANGBASE ANGDIR CMDECHO INC NODE OSMODE ORTHOMODE REP)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (if (/= nil RFL:QSECTIONLIST)
  (if (/= nil (assoc "PBASE" RFL:QSECTIONLIST))
   (progn
    (if (= nil (cdr (assoc "INC" RFL:QSECTIONLIST)))
     (progn
      (setq INC 20.0)
      (setq REP (getdist (strcat "\nStation increment <" (rtos INC) "> : ")))
      (if (/= nil REP) (setq INC REP))
      (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (cons "INC" INC))))
     )
     (setq INC (cdr (assoc "INC" RFL:QSECTIONLIST)))
    )
    (foreach NODE (cadr (assoc "ENTITIES" RFL:QSECTIONLIST))
     (if (/= nil (entget (handent NODE))) (entdel (handent NODE)))
    )
    (RFL:QSECTION (- (cdr (assoc "STA" RFL:QSECTIONLIST)) INC)
                  (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                  (cadr (assoc "PBASE" RFL:QSECTIONLIST))
                  nil
                  (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                  (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                  (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                  (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
    )
   )
  )
 )
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (eval nil)
);
;
;     Program written by Robert Livingston, 2015-10-02
;
;     C:LABELSIGHT is a utility for drawing the sight line from a given Station along a profile
;
(defun C:LABELSIGHT (/ D ENT PREVENT P ORTHOMODE OSMODE STA)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setq OSMODE (getvar "OSMODE"))
 (setq PREVENT nil)
 (if (= RFL:LABELSIGHTEYE nil)
  (progn
   (setq RFL:LABELSIGHTEYE (getdist "\nEye Height (1.05) : "))
   (if (= nil RFL:LABELSIGHTEYE) (setq RFL:LABELSIGHTEYE 1.05))
  )
 )
 (if (= RFL:LABELSIGHTTARGET nil)
  (progn
   (setq RFL:LABELSIGHTTARGET (getdist "\nTarget Height (0.38) : "))
   (if (= nil RFL:LABELSIGHTTARGET) (setq RFL:LABELSIGHTTARGET 0.38))
  )
 )
 (if (= RFL:LABELSIGHTMAX nil)
  (progn
   (setq RFL:LABELSIGHTMAX (getdist "\nMaximum Sight Check (250.0) : "))
   (if (= nil RFL:LABELSIGHTMAX) (setq RFL:LABELSIGHTMAX 250.0))
  )
 )
 (setq P (getpoint "\nSelect Profile Point (<return> to reset eye and target) : "))
 (if (= nil P)
  (progn
   (setq RFL:LABELSIGHTEYE nil)
   (setq RFL:LABELSIGHTTARGET nil)
   (setq RFL:LABELSIGHTMAX nil)
   (C:LABELSIGHT)
  )
  (progn
   (setvar "ORTHOMODE" 0)
   (setvar "OSMODE" 0)
   (setq STA (car (RFL:VPP P)))
   (if (or (= nil STA)
           (< STA (caar RFL:PVILIST))
           (> STA (car (last RFL:PVILIST)))
       )
    (progn
     (princ "\n*** Station out of range! ***\n")
     nil
    )
    (progn
     (setq D (RFL:SIGHTDISTPROF STA -1 RFL:LABELSIGHTEYE RFL:LABELSIGHTTARGET 1.0 RFL:LABELSIGHTMAX))
     (if (/= nil D)
      (progn
       (entmake)
       (entmake (list (cons 0 "LWPOLYLINE")
                      (cons 100 "AcDbEntity")
                      (cons 100 "AcDbPolyline")
                      (cons 90 4)
                      (append (list 10) (RFL:PROFPOINT (- STA D) (RFL:ELEVATION (- STA D))))
                      (append (list 10) (RFL:PROFPOINT (- STA D) (+ (RFL:ELEVATION (- STA D)) RFL:LABELSIGHTTARGET)))
                      (append (list 10) (RFL:PROFPOINT STA (+ (RFL:ELEVATION STA) RFL:LABELSIGHTEYE)))
                      (append (list 10) (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                )
       )
       (setq ENT (entlast))
       (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      )
     )
     (setq D (RFL:SIGHTDISTPROF STA 1 RFL:LABELSIGHTEYE RFL:LABELSIGHTTARGET 1.0 RFL:LABELSIGHTMAX))
     (if (/= nil D)
      (progn
       (entmake)
       (entmake (list (cons 0 "LWPOLYLINE")
                      (cons 100 "AcDbEntity")
                      (cons 100 "AcDbPolyline")
                      (cons 90 4)
                      (append (list 10) (RFL:PROFPOINT STA (RFL:ELEVATION STA)))
                      (append (list 10) (RFL:PROFPOINT STA (+ (RFL:ELEVATION STA) RFL:LABELSIGHTEYE)))
                      (append (list 10) (RFL:PROFPOINT (+ STA D) (+ (RFL:ELEVATION (+ STA D)) RFL:LABELSIGHTTARGET)))
                      (append (list 10) (RFL:PROFPOINT (+ STA D) (RFL:ELEVATION (+ STA D))))
                )
       )
       (setq ENT (entlast))
       (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      )
     )
    )
   )
  )
 )
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 2015-10-02
;
;     C:SIGHTDIST2CSV outputs a CSV file with the forward and back calculated maximum sight distance
;
;
(defun C:SIGHTDIST2CSV (/ *error* D1 D2 EYE INC INC2 F G GETF GETSSD MAXDIST OUTFILE R REACTION STA STAEND TARGET VDES)
 (defun *error* (msg)
  (close OUTFILE)
  (print msg)
  ;(setq *error* nil)
 )
 (defun GETF (VDES / )
  (cond ((<= VDES 30.0) 0.40)
        ((<= VDES 40.0) 0.38)
        ((<= VDES 50.0) 0.35)
        ((<= VDES 60.0) 0.33)
        ((<= VDES 70.0) 0.31)
        ((<= VDES 80.0) 0.30)
        ((<= VDES 90.0) 0.30)
        ((<= VDES 100.0) 0.29)
        ((<= VDES 110.0) 0.28)
        ((<= VDES 120.0) 0.28)
        ((<= VDES 130.0) 0.28)
        (T 0.28)
  )
 )
 (defun GETSSD (G / )
  (+ (* (/ 1.0 3.6) VDES REACTION)
     (/ (* VDES VDES) (* 2.0 9.81 3.6 3.6 (+ F G)))
  )
 )
 (if (= nil RFL:PVILIST)
  (princ "\n!!! NO PROFILE DEFINED !!!\n")
  (progn
   (setq VDES nil)
   (while (= (setq VDES (getdist "\nDesign speed (km/h) : ")) nil))
   (setq F (GETF VDES))
   (setq REACTION 0.0)
   (while (= REACTION 0.0)
    (setq REACTION (getdist "\nReaction time (seconds) <2.5> : "))
    (if (= REACTION nil) (setq REACTION 2.5))
   )
   (setq INC 0.0)
   (while (= INC 0.0)
    (setq INC (getdist "\nStation increment <10.0> : "))
    (if (= INC nil) (setq INC 10.0))
   )
   (setq INC2 0.0)
   (while (= INC2 0.0)
    (setq INC2 (getdist "\nSight increment <1.0> : "))
    (if (= INC2 nil) (setq INC2 1.0))
   )
   (setq TMP (+ INC (* INC (fix (/ (caar RFL:PVILIST) INC)))))
   (setq STA (getreal (strcat "\nStart Station <" (rtos TMP 2 3) "> : ")))
   (if (= nil STA) (setq STA TMP))
   (setq TMP (* INC (fix (/ (car (last RFL:PVILIST)) INC))))
   (setq STAEND (getreal (strcat "\nEnd Station <" (rtos TMP 2 3) "> : ")))
   (if (= nil STAEND) (setq STAEND TMP))
   (setq TMP 1.05)
   (setq EYE (getreal (strcat "\nEye Height <" (rtos TMP 2 3) "> : ")))
   (if (= nil EYE) (setq EYE TMP))
   (setq TMP 0.38)
   (setq TARGET (getreal (strcat "\nTarget Height <" (rtos TMP 2 3) "> : ")))
   (if (= nil TARGET) (setq TARGET TMP))
   (setq TMP 250.0)
   (setq MAXDIST (getreal (strcat "\nMaximum Sight Distance <" (rtos TMP 2 3) "> : ")))
   (if (= nil MAXDIST) (setq MAXDIST TMP))
   (princ (strcat "\nDistances stored in : " (getenv "UserProfile") "\\Documents\\" "SightDist.CSV\n"))
   (setq OUTFILE (open (strcat (getenv "UserProfile") "\\Documents\\" "SightDist.CSV") "w"))
   (princ (strcat "VDES =," (rtos VDES 2 8) "\n") OUTFILE)
   (princ (strcat "REACTION TIME =," (rtos REACTION 2 8) "\n") OUTFILE)
   (princ (strcat "F =," (rtos F 2 8) "\n") OUTFILE)
   (princ "STA,GRADE,SSD CALC AHEAD,SSD CALC BACK,SSD ACTUAL AHEAD,SSD ACTUAL BACK\n" OUTFILE)
   (while (<= STA STAEND)
    (grread T)
    (setq D1 (RFL:SIGHTDISTPROF STA 1.0 EYE TARGET INC2 MAXDIST))
    (setq D2 (RFL:SIGHTDISTPROF STA -1.0 EYE TARGET INC2 MAXDIST))
    (setq G (RFL:SLOPE STA))
    (princ (strcat (RFL:STATXT STA)
                   ", Grade = " (rtos (* G 100.0)) "%"
                   ", Calc Ahead = " (rtos (GETSSD G))
                   ", Calc Back = " (rtos (GETSSD (* -1.0 G)))
                   ", Actual Ahead = " (rtos D1)
                   ", Actual Back = " (rtos D2)
                   "\n"
           )
    )
    (princ (strcat (rtos STA 2 8) ","
                   (rtos G 2 8) ","
                   (rtos (GETSSD G) 2 8) ","
                   (rtos (GETSSD (* -1.0 G)) 2 8) ","
                   (rtos D1 2 8) ","
                   (rtos D2 2 8) "\n"
           )
           OUTFILE
    )
    (setq STA (+ STA INC))
   )
   (close OUTFILE)
  )
 )
  
 T
 );
;
;     Program written by Robert Livingston, 04-10-22
;
;     C:SIGHTLINE is a routine for drawing lines point to point along an alignment or path at a given length
;
;
(defun C:SIGHTLINE (/ *error* ALSAVE ANGBASE ANGDIR CMDECHO ENT ENT2 ENTLIST FR OS OSMODE P P1 P2 PM PREVENT
                      SIGHTDIST STA STA1 STA2 STAEND STAM STEP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ALSAVE RFL:ALIGNLIST)
 (setq PREVENT nil)

 (defun *error* (msg)
  (princ msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  ;(setq *error* nil)
 )

 (command "._UNDO" "M")

 (if (= nil RFL:ALIGNLIST)
  (progn
   (setq ENT (entsel "\nSelect polyline : "))
   (setq P (cadr ENT)
         P (list (car P) (cadr P))
         P1 nil
         P2 nil
         ENT (car ENT)
         ENTLIST (entget ENT)
   )
   (if (= (cdr (assoc 0 ENTLIST)) "POLYLINE")
    (progn
     (command "._CONVERT" "P" "S" ENT "")
     (setq ENTLIST (entget ENT))
    )
   )
   (if (= (cdr (assoc 0 ENTLIST)) "LWPOLYLINE")
    (progn
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq P2 (cdr (assoc 10 (reverse ENTLIST))))
     (if (< (distance P P1) (distance P P2))
      (setq P P1)
      (setq P P2)
     )
    )
   )
   (setq RFL:ALIGNLIST (RFL:ALIGNDEF ENT P 0.0))
  )
 )
 (if (= nil RFL:ALIGNLIST)
  (princ "\n!!!  No alignment defined or error selecting polyline !!!")
  (progn
   (initget "Forward Reverse")
   (setq FR (getkword "\nForward or Reverse <Forward> : "))
   (if (= nil FR) (setq FR "Forward"))
   (setq STA (getreal "\nEnter start chainage (<return> for alignment start/end) : "))
   (if (= STA nil)
    (progn
     (setq STA (caar RFL:ALIGNLIST))
     (setq STAEND STA)
     (if (= FR "Reverse")
      (setq STA (+ STA (RFL:GETALIGNLENGTH)))
      (setq STAEND (+ STAEND (RFL:GETALIGNLENGTH)))
     )
    )
   )
   (setq OS (getreal "\nOffset from centerline (-ve = left, +ve = right) <0.0> : "))
   (if (= nil OS) (setq OS 0.0))
   (setq STEP 0.0)
   (while (<= STEP 0.0) (setq STEP (getreal "\nEnter step size : ")))
   (setq SIGHTDIST 0.0)
   (while (<= SIGHTDIST 0.0) (setq SIGHTDIST (getreal "\nEnter sight distance : ")))
   (if (= FR "Reverse")
    (progn
     (setq STEP (* -1.0 STEP))
     (setq SIGHTDIST (* -1.0 SIGHTDIST))
    )
   )
   (setq STOPFLAG nil)
   (while (= STOPFLAG nil)
    (setq P (RFL:XY (list STA OS)))
    (if (/= nil P)
     (progn
      (setq STA1 (+ STA STEP))
      (setq P1 (RFL:XY (list STA1 OS)))
      (while (/= nil P1)
       (setq STA2 (+ STA1 STEP))
       (if (= FR "Forward")
        (setq STA2 (min STAEND STA2))
        (setq STA2 (max STAEND STA2))
       )
       (setq P2 (RFL:XY (list STA2 OS)))
       (if (/= P2 nil)
        (if (> (distance P P2) (abs SIGHTDIST))
         (progn
          (while (> (abs (- STA1 STA2)) RFL:TOL)
           (setq STAM (/ (+ STA1 STA2) 2.0))
           (setq PM (RFL:XY (list STAM OS)))
           (if (< (abs SIGHTDIST) (distance P PM))
            (setq STA2 STAM P2 PM)
            (setq STA1 STAM P1 PM)
           )
          )
          (entmake (list (cons 0 "LINE")
                         (append (list 10) P (list 0.0))
                         (append (list 11) PM (list 0.0))
                   )
          )
          (setq ENT (entlast))
          (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
          (setq P1 nil)
         )
        )
       )
       (if (/= P1 nil)
        (progn
         (setq STA1 (+ STA1 STEP))
         (setq P1 (RFL:XY (list STA1 OS)))
        )
       )
      )
     )
    )
    (setq STA (+ STA STEP))
    (if (= FR "Forward")
     (if (> STA STAEND) (setq STOPFLAG T))
     (if (< STA STAEND) (setq STOPFLAG T))
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setq RFL:ALIGNLIST ALSAVE)
 nil
);
;
;     Program written by Robert Livingston, 12-01-31
;
;     C:SIGHTLINE3D is a routine for drawing lines point to point along an alignment at a given length and checking for elevation conflicts
;
;
(defun C:SIGHTLINE3D (/ *error* 3DPENT 3DPENTLIST 3DPFLAG ALSAVE BARRIERFLAG BELOWFLAG BELOWLIST DIST DISTMIN PVISAVE ESAVE ANGBASE ANGDIR BARRIERAL BARRIERALLIST
                        CECOLOR CMDECHO CONTROLAL DRAWLINES ENT ENT2 ENTLIST GETBARRIERALLIST GETFROMLIST GETPTZ HEYE HTARGET HBARRIER L LAYERFLAG
                        OBSURFACE OSMODE P P1 P2 SIGHTAL STA STEP STEPFINE TMP TMPENT TOL)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq CECOLOR (getvar "CECOLOR"))
 (setq CLAYER (getvar "CLAYER"))
 (setq TOL 0.000001)

 (setq ALSAVE RFL:ALIGNLIST PVISAVE RFL:PVILIST ESAVE RFL:SUPERLIST)

 (defun *error* (msg)
  (princ msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  (setvar "CECOLOR" CECOLOR)
  (setvar "CLAYER" CLAYER)
  (setq RFL:ALIGNLIST ALSAVE RFL:PVILIST PVISAVE RFL:SUPERLIST ESAVE)
  ;(setq *error* nil)
 )

 (if (= nil VLAX-CREATE-OBJECT) (vl-load-com))

 (defun GETBARRIERALLIST ()
  (while (/= (setq ENT2 (car (entsel "\nSelect barrier polyline (<Return> when done) : "))) nil)
   (if (= nil ENT)
    (setq HBARRIER 0.0)
    (progn
     (setq HBARRIER (getreal "\nEnter target height (median = 0.810 / shoulder = 0.690) <0.690> : "))
     (if (= nil HBARRIER) (setq HBARRIER 0.690))
    )
   )
   (setq ENTLIST (entget ENT2))
   (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (progn
     (command "._CONVERT" "P" "S" ENT2 "")
     (setq ENTLIST (entget ENT2))
    )
   )
   (if (/= "LWPOLYLINE" (cdr (assoc 0 ENTLIST)))
    (progn
     (princ "*** ERROR : NOT A POLYLINE ***")
    )
    (progn
     (setq BARRIERALLIST (append BARRIERALLIST (list (list HBARRIER (RFL:ALIGNDEF ENT2 (cdr (assoc 10 ENTLIST)) 0.0)))))
    )
   )
  )
 )

 (defun GETPTZ (P / OFFSETC STAC SUPERC TMP Z ZC)
  (setq RFL:ALIGNLIST CONTROLAL)
  (setq Z nil)
  (setq TMP (RFL:STAOFF P))
  (if (/= nil TMP)
   (progn
    (setq STAC (car TMP))
    (setq OFFSETC (cadr TMP))
    (setq ZC (RFL:ELEVATION STAC))
    (if (/= nil ZC)
      (progn
      (setq SUPERC (RFL:SUPER STAC))
      (if (/= nil SUPERC)
       (progn
        (if (< OFFSETC 0.0)
         (setq SUPERC (car SUPERC))
         (setq SUPERC (cadr SUPERC))
        )
        (setq Z (+ ZC (* (abs OFFSETC) SUPERC 0.01)))
       )
      )
     )
    )
   )
  )
  (setq RFL:ALIGNLIST SIGHTAL)
  (setq Z Z)
 )

 (defun DRAWLINES (CHECKBARRIER CHECKELEV OBSURFACE / ENT FILEFIRST INFILE INLINE NODE NODEAL OUTFILE P P1 P2 PCHECK PM PREVENT STA STA1 STA2 STAM STAEND Z1 Z2 ZC ZC1 ZC2)
  (setq PREVENT nil)
  (setq RFL:ALIGNLIST SIGHTAL)
  (setq STA (caar RFL:ALIGNLIST))
  (setq STAEND (+ STA (RFL:GETALIGNLENGTH)))
  (setq FILEFIRST T)
  (while (and (< STA STAEND)
              (>= DIST DISTMIN))
   (if LAYERFLAG
    (progn
     (if (= nil (tblsearch "LAYER" (strcat CLAYER "_" (itoa (fix DIST)))))
      (progn
;       (command "._LAYER" "M" (strcat CLAYER "_" (itoa (fix DIST))) "Off" (strcat CLAYER "_" (itoa (fix DIST))) "Yes" "")
       (entmake (list (cons 0 "LAYER")
                      (cons 100 "AcDbSymbolTableRecord")
                      (cons 100 "AcDbLayerTableRecord")
                      (cons 2 (strcat CLAYER "_" (itoa (fix DIST))))
                      (cons 62 -7)
                      (cons 70 0)
                )
       )
      )
     )
     (princ "\r                                      ")
     (princ (strcat "\rSolving for : " (itoa (fix DIST))))
     (setvar "CLAYER" (strcat CLAYER "_" (itoa (fix DIST))))
    )
   )
   (setq BELOWFLAG nil)
   (setq P (RFL:XY (list STA 0.0)))
   (if (/= nil P)
    (progn
     (setq STAM (RFL:SIGHTDIST STA DIST))
     (if (= STAM nil)
      (setq PM nil)
      (setq PM (RFL:XY (list STAM 0.0)))
     )
     (if (/= nil PM)
      (progn
       (setq Z1 0.0 Z2 0.0)
       (if CHECKELEV
        (progn
         (setq Z1 (GETPTZ P))
         (setq Z2 (GETPTZ PM))
         (if (or (= nil Z1) (= nil Z2))
          (setq Z1 0.0 Z2 0.0)
         (setq Z1 (+ Z1 HEYE) Z2 (+ Z2 HTARGET))
         )
        )
       )
       (setq BARRIERFLAG nil)
       (if CHECKBARRIER
        (foreach NODE2 BARRIERALLIST
         (progn
          (setq HBARRIER (car NODE2))
          (setq BARRIERAL (cadr NODE2))
          (foreach NODE BARRIERAL
           (progn
            (setq PCHECK (RFL:INTERS2 (list 0.0 P PM 0.0) NODE))
            (if (/= nil PCHECK)
             (progn
              (setq BARRIERFLAG T)
              (setq ZC1 0.0 ZC2 0.0)
              (setvar "CECOLOR" "RGB:255,255,0")
              (if (listp (car PCHECK))
               (progn
                (if (/= Z1 0.0)
                 (progn
                  (setq ZC (GETPTZ (car PCHECK)))
                  (setq ZC1 (+ ZC HBARRIER))
                  (setq ZC2 (+ Z1 (* (- Z2 Z1) (/ (distance P (car PCHECK)) (distance P PM)))))
                  (if (> ZC2 ZC1)
                   (setvar "CECOLOR" "RGB:0,255,0")
                   (setvar "CECOLOR" "RGB:255,0,0")
                  )
                 )
                )
;                (command "._POINT" (list (car (car PCHECK)) (cadr (car PCHECK)) ZC2))
                (entmake (list (cons 0 "POINT")
                               (append (list 10) (list (car (car PCHECK)) (cadr (car PCHECK)) ZC2))
                         )
                )
                (setq ENT (entlast))
                (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
                (if (/= Z1 0.0)
                 (progn
                  (setq ZC (GETPTZ (cadr PCHECK)))
                  (setq ZC1 (+ ZC HBARRIER))
                  (setq ZC2 (+ Z1 (* (- Z2 Z1) (/ (distance P (cadr PCHECK)) (distance P PM)))))
                  (if (> ZC2 ZC1)
                   (setvar "CECOLOR" "RGB:0,255,0")
                   (setvar "CECOLOR" "RGB:255,0,0")
                  )
                 )
                )
;                (command "._POINT" (list (car (cadr PCHECK)) (cadr (cadr PCHECK)) ZC2))
                (entmake (list (cons 0 "POINT")
                               (append (list 10) (list (car (cadr PCHECK)) (cadr (cadr PCHECK)) ZC2))
                         )
                )
                (setq ENT (entlast))
                (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
               )
               (progn
                (if (/= Z1 0.0)
                 (progn
                  (setq ZC (GETPTZ PCHECK))
                  (setq ZC1 (+ ZC HBARRIER))
                  (setq ZC2 (+ Z1 (* (- Z2 Z1) (/ (distance P PCHECK) (distance P PM)))))
                  (if (> ZC2 ZC1)
                   (setvar "CECOLOR" "RGB:0,255,0")
                   (setvar "CECOLOR" "RGB:255,0,0")
                  )
                 )
                )
                (if (/= "RGB:0,255,0" (getvar "CECOLOR")) (setq BELOWFLAG T))
;                (command "._POINT" (list (car PCHECK) (cadr PCHECK) ZC2))
                (entmake (list (cons 0 "POINT")
                               (append (list 10) (list (car PCHECK) (cadr PCHECK) ZC2))
                         )
                )
                (setq ENT (entlast))
                (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
               )
              )
              (setvar "CECOLOR" CECOLOR)
             )
            )
           )
          )
         )
        )
       )
       (if BARRIERFLAG (setvar "CECOLOR" "RGB:255,255,0"))
;       (command "._LINE" (list (car P) (cadr P) Z1) (list (car PM) (cadr PM) Z2) "")
       (entmake (list (cons 0 "LINE")
                      (append (list 10) (list (car P) (cadr P) Z1))
                      (append (list 11) (list (car PM) (cadr PM) Z2))
                )
       )
       (setvar "CECOLOR" CECOLOR)
       (if (= nil OBSURFACE)
        (progn
         (setq ENT (entlast))
         (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
        )
        (progn
         (setq ENT (entlast))
         (if (= T (RFL:SURFACELINE OBSURFACE ENT)) (setq BELOWFLAG T))
         (entdel ENT)
         (setq ENT (entlast))
         ;(RFL:PUTPREVENT (RFL:GETFIRSTENT ENT) PREVENT)(RFL:PUTNEXTENT PREVENT (RFL:GETFIRSTENT ENT))(setq PREVENT ENT)
        )
       )
      )
     )
    )
   )
   (setq BELOWLIST (append BELOWLIST (list (list STA BELOWFLAG))))
   (setq STA (+ STA STEP))
   (if (>= STA STAEND)
    (progn
     (if FILEFIRST
      (progn
       (princ (strcat "\nSight distances stored in : " (getenv "UserProfile") "\\Documents\\" "SIGHTLINE3D.CSV\n"))
       (setq OUTFILE (open (strcat (getenv "UserProfile") "\\Documents\\" "SIGHTLINE3D.CSV") "w"))
       (princ (strcat "Station,Offset," (rtos DIST 2 3)) OUTFILE)
       (foreach NODE BELOWLIST
        (progn
         (setq RFL:ALIGNLIST SIGHTAL)
         (setq P (RFL:XY (list (car NODE) 0.0)))
         (if (= CONTROLAL nil)
          (progn
           (setq P (list (car NODE) 0.0))
          )
          (progn
           (setq RFL:ALIGNLIST CONTROLAL)
           (setq P (RFL:STAOFF P))
           (setq RFL:ALIGNLIST SIGHTAL)
          )
         )
         (princ (strcat "\n" (rtos (car P) 2 3) "," (rtos (cadr P) 2 3)) OUTFILE)
         (if (cadr NODE)
          (princ ",ISSUE" OUTFILE)
          (princ ",OK" OUTFILE)
         )
        )
       )
       (close OUTFILE)
       (setq RFL:ALIGNLIST SIGHTAL)
       (setq FILEFIRST nil)
      )
      (progn
       (setq INFILE (open (strcat (getenv "UserProfile") "\\Documents\\" "SIGHTLINE3D.CSV") "r"))
       (setq INLINE (read-line INFILE))
       (setq OUTFILE (open (strcat (getenv "UserProfile") "\\Documents\\" "SIGHTLINE3Dtmp.CSV") "w"))
       (princ (strcat INLINE "," (rtos DIST 2 3)) OUTFILE)
       (foreach NODE BELOWLIST
        (if (/= nil (setq INLINE (read-line INFILE)))
         (progn
          (if (cadr NODE)
           (princ (strcat "\n" INLINE ",ISSUE") OUTFILE)
           (princ (strcat "\n" INLINE ",OK") OUTFILE)
          )
         )
        )
       )
       (close INFILE)
       (close OUTFILE)
       (vl-file-delete (strcat (getenv "UserProfile") "\\Documents\\" "SIGHTLINE3D.CSV"))
       (vl-file-rename (strcat (getenv "UserProfile") "\\Documents\\" "SIGHTLINE3Dtmp.CSV")
                       (strcat (getenv "UserProfile") "\\Documents\\" "SIGHTLINE3D.CSV")
       )
      )
     )
     (setq BELOWLIST nil)
     (setq STA (caar RFL:ALIGNLIST))
     (setq DIST (- DIST STEP))
    )
   )
  )
 )

 (command "._UNDO" "M")

 (setq BELOWLIST nil)
 (setq ENT (entsel "\nSelect lane center polyline (near start point) : "))
 (if (/= nil ENT)
  (progn
   (setq P (cadr ENT))
   (setq ENT (car ENT))
   (setq ENTLIST (entget ENT))
   (setq 3DPFLAG nil)
   (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
    (if (/= 0 (logand (cdr (assoc 70 ENTLIST)) 8))
     (progn
      (initget "Yes No")
      (if (= "Yes" (getkword "\nA 3D POLYLINE has been selected would you like to use it for horizontal and vertical control (Y/N) : "))
       (setq 3DPFLAG ENT)
       (alert "Entity must be a 2D POLYLINE!")
      )
     )
     (progn
      (command "._CONVERT" "P" "S" ENT "")
      (setq ENTLIST (entget ENT))
     )
    )
   )
   (if (and (= nil 3DPFLAG) (/= "LWPOLYLINE" (cdr (assoc 0 ENTLIST))))
    (progn
     (princ "*** ERROR : NOT A 2D POLYLINE ***")
    )
    (progn
     (if (/= nil 3DPFLAG)
      (progn
       (setq 3DPENT (entnext ENT))
       (setq 3DPENTLIST (entget 3DPENT))
       (setq P1 (cdr (assoc 10 3DPENTLIST)))
       (setq P1 (list (car P1) (cadr P1)))
       (command "._PLINE")
       (while (= "VERTEX" (cdr (assoc 0 3DPENTLIST)))
        (setq P2 (cdr (assoc 10 3DPENTLIST)))
        (setq P2 (list (car P2) (cadr P2)))
        (command P2)
        (setq 3DPENT (entnext 3DPENT))
        (setq 3DPENTLIST (entget 3DPENT))
       )
       (command "")
       (setq ENT (entlast))
       (setq ENTLIST (entget ENT))
       (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
        (progn
         (command "._CONVERT" "P" "S" ENT "")
         (setq ENTLIST (entget ENT))
        )
       )
      )
     )
     (setq P1 (cdr (assoc 10 ENTLIST)))
     (setq P2 (cdr (assoc 10 (reverse ENTLIST))))
     (if (< (distance P P1) (distance P P2))
      (setq SIGHTAL (RFL:ALIGNDEF ENT P1 0.0))
      (setq SIGHTAL (RFL:ALIGNDEF ENT P2 0.0))
     )
     (if (/= nil 3DPENT)
      (entdel ENT)
     )
     (setq DIST 0.0)
     (while (or (= DIST 0.0) (= DIST nil))
      (setq TMP (getdist "\nEnter sight length <250.0> : "))
      (if (= nil TMP)
       (setq DIST 250.0)
       (setq DIST TMP)
      )
     )
     (setq DISTMIN 0.0)
     (while (or (= DISTMIN 0.0) (= DISTMIN nil))
      (setq TMP (getdist (strcat "\nEnter minimum sight length for iterative analysis <" (rtos DIST 2 1) "> : ")))
      (if (= nil TMP)
       (setq DISTMIN DIST)
       (setq DISTMIN TMP)
      )
      (if (> DISTMIN DIST) (setq DISTMIN 0.0))
     )
     (if (= DISTMIN DIST)
      (setq LAYERFLAG nil)
      (setq LAYERFLAG T)
     )
     (setq STEP 0.0)
     (while (or (= STEP 0.0) (= STEP nil))
      (setq TMP (getdist "\nEnter step size <10.0> : "))
      (if (= nil TMP)
       (setq STEP 10.0)
       (setq STEP TMP)
      )
     )
     (setq RFL:ALIGNLIST nil RFL:PVILIST nil RFL:SUPERLIST nil)
     (if (= nil 3DPFLAG)
      (progn
       (setq ENT (car (entsel "Select RAB alignment control block (or <Return> for 2D sightlines) : ")))
       (if (/= nil ENT)
        (progn
         (RFL:RALIGNB ENT)
         (RFL:RPROFB ENT)
         (RFL:RSUPERB ENT)
        )
       )
      )
      (progn
       (setq STA 0.0)
       (setq RFL:ALIGNLIST nil)
       (setq ENT (entnext 3DPFLAG))
       (setq ENTLIST (entget ENT))
       (setq P1 (cdr (assoc 10 ENTLIST)))
       (setq Z1 (caddr P1))
       (setq P1 (list (car P1) (cadr P1)))
       (setq RFL:PVILIST (list (list STA Z1 "L" 0.0)))
       (while (= "VERTEX" (cdr (assoc 0 ENTLIST)))
        (setq ENT (entnext ENT))
        (setq ENTLIST (entget ENT))
        (if (= "VERTEX" (cdr (assoc 0 ENTLIST)))
         (progn
          (setq P2 (cdr (assoc 10 ENTLIST)))
          (setq Z2 (caddr P2))
          (setq P2 (list (car P2) (cadr P2)))
          (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list STA P1 P2 0.0))))
          (setq STA (+ STA (distance P1 P2)))
          (setq RFL:PVILIST (append RFL:PVILIST (list (list STA Z2 "L" 0.0))))
          (setq P1 P2)
          (setq Z1 Z2)
         )
        )
       )
       (setq RFL:SUPERLIST (list (list -1e9 0.0 0.0) (list 1e9 0.0 0.0)))
      )
     )
     (setq OBSURFACE nil)
     (setq BARRIERALLIST nil)
     (if (or (= nil RFL:ALIGNLIST) (= nil RFL:PVILIST) (= nil RFL:SUPERLIST))
      (progn
       (GETBARRIERALLIST)
       (if (= nil BARRIERALLIST)
        (progn
; Lines Only
         (DRAWLINES nil nil OBSURFACE)
        )
        (progn
; Barrier
         (DRAWLINES T nil OBSURFACE)
        )
       )
      )
      (progn
; Solve full 3D
       (setq CONTROLAL RFL:ALIGNLIST)
       (setq HEYE (getreal "\nEnter eye height <1.050> : "))
       (if (= nil HEYE) (setq HEYE 1.05))
       (setq HTARGET (getreal "\nEnter target height <0.150> : "))
       (if (= nil HTARGET) (setq HTARGET 0.15))
       (initget "Yes No")
       (if (= "Yes" (getkword "\nCompare lines to surface (Yes/<No>) : "))
        (progn
         (setq OBSURFACE (RFL:GETC3DSURFACE))
        )
       )
       (GETBARRIERALLIST)
       (if (= nil BARRIERALLIST)
        (progn
         (DRAWLINES nil T OBSURFACE)
        )
        (progn
         (DRAWLINES T T OBSURFACE)
        )
       )
      )
     )
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "CECOLOR" CECOLOR)
 (setvar "CLAYER" CLAYER)
 (setq RFL:ALIGNLIST ALSAVE RFL:PVILIST PVISAVE RFL:SUPERLIST ESAVE)
 BELOWLIST
)
;
;
;     Program written by Robert Livingston, 2010-12-08
;
;     CSIGHTLINEPROF is a routine for drawing lines point to point along a profile at a given length, eye height and target height
;
;
(defun C:SIGHTLINEPROF (/ *error* ANGBASE ANGDIR CMDECHO ENT EYE FR OSMODE P P1 P2 PM PREVENT
                          SIGHTDIST STA STA1 STA2 STAEND STAM STEP TARGET TMP Z)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq PREVENT nil)

 (defun *error* (msg)
  (princ msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  ;(setq *error* nil)
 )

 (command "._UNDO" "M")

 (RFL:PROFDEF)
 (if (= nil RFL:PVILIST)
  (princ "\n!!!  No profile defined  !!!")
  (progn
   (initget "Forward Reverse")
   (setq FR (getkword "\nForward or Reverse <Forward> : "))
   (if (= nil FR) (setq FR "Forward"))
   (setq STA (getreal "\nEnter start chainage (<return> for profile start) : "))
   (if (= STA nil)
    (setq STA (caar RFL:PVILIST))
   )
   (setq STAEND (getreal "\nEnter end chainage (<return> for profile end) : "))
   (if (= STAEND nil)
    (setq STAEND (car (last RFL:PVILIST)))
   )
   (if (= FR "Reverse")
    (progn
     (setq TMP STA)
     (setq STA STAEND)
     (setq STAEND TMP)
    )
   )
   (setq EYE (getreal "\nEye height (<return> = 1.05) : "))
   (if (= nil EYE) (setq EYE 1.05))
   (setq TARGET (getreal "\nTarget height (<return> = 0.38) : "))
   (if (= nil TARGET) (setq TARGET 0.38))
   (setq STEP 0.0)
   (while (<= STEP 0.0) (setq STEP (getreal "\nEnter step size : ")))
   (setq SIGHTDIST 0.0)
   (while (<= SIGHTDIST 0.0) (setq SIGHTDIST (getreal "\nEnter sight distance : ")))
   (if (= FR "Reverse")
    (progn
     (setq STEP (* -1.0 STEP))
     (setq SIGHTDIST (* -1.0 SIGHTDIST))
    )
   )
   (setq STOPFLAG nil)
   (while (= STOPFLAG nil)
    (setq Z (RFL:ELEVATION STA))
    (if (/= nil Z)
     (progn
      (setq P1 (RFL:PROFPOINT STA (+ Z EYE)))
      (setq Z (RFL:ELEVATION (+ STA SIGHTDIST)))
      (if (/= nil Z)
       (progn
        (setq P2 (RFL:PROFPOINT (+ STA SIGHTDIST) (+ Z TARGET)))
        (entmake (list (cons 0 "LINE")
                       (append (list 10) P1)
                       (append (list 11) P2)
                 )
        )
        (setq ENT (entlast))
        (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
       )
      )
     )
    )
    (setq STA (+ STA STEP))
    (if (= FR "Forward")
     (if (> STA STAEND) (setq STOPFLAG T))
     (if (< STA STAEND) (setq STOPFLAG T))
    )
   )
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 13-03-26
;
;     C:SIGHTLINEPROFMAX is a routine for finding the longest point to point sightline along a profile
;
;
(defun C:SIGHTLINEPROFMAX (/ *error* ANGBASE ANGDIR CHECKELEVATIONS C C1 C2 CMDECHO CONTINUEFLAG ELEVLIST ENT EYE FR OSMODE OUTFILE
                             P P1 P2 PINWHEEL PM PREVENT SIGHTDIST SIGHTDISTMIN STA STA1 STA2 STAEND STASTART STEP STEPCHECK
                             TARGET TMP Z Z1 Z2)
;(defun C:SIGHTLINEPROFMAX ()
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)

 (setq PREVENT nil)
 
 (defun *error* (msg)
  (princ msg)
  (close OUTFILE)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  ;(setq *error* nil)
 )

 (defun PINWHEEL ()
  (if (= PINWHEELCH nil)
   (setq PINWHEELCH "|")
  )
  (setq PINWHEELCH (cond ((= PINWHEELCH "|") "/")
                         ((= PINWHEELCH "/") "-")
                         ((= PINWHEELCH "-") "\\")
                         ((= PINWHEELCH "\\") "|")))
  (princ "\r")
  (princ PINWHEELCH)
 )

 (defun CHECKELEVATIONS (/ C DELTA Z Z1 Z2)
  (setq RES T)
  (setq Z1 (+ (cadr (nth C1 ELEVLIST)) EYE))
  (setq Z2 (+ (cadr (nth C2 ELEVLIST)) TARGET))
  (setq DELTA (/ (- Z2 Z1) (- C2 C1)))
  (setq C (+ C1 1))
  (while (and RES (< C C2))
   (setq Z (+ Z1 (* (- C C1) DELTA)))
   (if (< Z (cadr (nth C ELEVLIST))) (setq RES nil))
   (setq C (+ C 1))
  )
  (eval RES)
 )
 
 (command "._UNDO" "M")

 (setq SIGHTDISTMIN nil)
 (setq ELEVLIST nil)
 
 (if (= nil RFL:PVILIST)
  (princ "\n!!!  No profile defined  !!!")
  (progn
   (RFL:PROFDEF)
   (initget "Forward Reverse")
   (setq FR (getkword "\nForward or Reverse <Forward> : "))
   (if (= nil FR) (setq FR "Forward"))
   (setq STASTART (getreal "\nEnter start chainage (<return> for profile start) : "))
   (if (= STASTART nil)
    (setq STASTART (caar RFL:PVILIST))
   )
   (setq STAEND (getreal "\nEnter end chainage (<return> for profile end) : "))
   (if (= STAEND nil)
    (setq STAEND (car (last RFL:PVILIST)))
   )
   (setq EYE (getreal "\nEye height (<return> = 1.05) : "))
   (if (= nil EYE) (setq EYE 1.05))
   (setq TARGET (getreal "\nTarget height (<return> = 0.38) : "))
   (if (= nil TARGET) (setq TARGET 0.38))
   (setq STEP (getreal "\nEnter step size (<return> = 5.0) : "))
   (if (= nil STEP) (setq STEP 5.0))
;   (setq STEPCHECK (getreal "\nEnter check step size (<return> = 1.0) : "))
;   (if (= nil STEPCHECK) (setq STEPCHECK 1.0))
   (setq STEPCHECK (/ STEP 10.0))
   (setq SIGHTDIST (getreal "\nEnter maximum sight distance for checking (<return> = 250.0) : "))
   (if (= nil SIGHTDIST) (setq SIGHTDIST 250.0))
   (princ (strcat "\nSight distances stored in : " (getenv "UserProfile") "\\Documents\\" "SIGHTLINEPROFMAX.CSV\n"))
   (setq OUTFILE (open (strcat (getenv "UserProfile") "\\Documents\\" "SIGHTLINEPROFMAX.CSV") "w"))
   (princ "Computing ground/design elevations.")
   (setq STA STASTART)
   (while (<= STA STAEND)
    (PINWHEEL)
    (setq Z (RFL:ELEVATION STA))
    (if (/= nil Z)
     (setq ELEVLIST (append ELEVLIST (list (list STA Z))))
    )
    (setq STA (+ STA STEPCHECK))
   )
   (princ "\n")
   (if (= FR "Reverse") (setq ELEVLIST (reverse ELEVLIST)))
   (setq C1 0)
   (while (< (+ C1 1) (length ELEVLIST))
    (setq C2 (+ C1 1))
    (setq Z1 (cadr (nth C1 ELEVLIST)))
    (setq Z2 (cadr (nth C2 ELEVLIST)))
    (setq CONTINUEFLAG T)
    (while (and (CHECKELEVATIONS) CONTINUEFLAG (<= (abs (- (car (nth C2 ELEVLIST)) (car (nth C1 ELEVLIST)))) SIGHTDIST))
     (PINWHEEL)
     (setq C2 (+ C2 1))
     (if (= C2 (length ELEVLIST)) (setq CONTINUEFLAG nil))
    )
    (setq C2 (- C2 1))
    (if CONTINUEFLAG
     (progn
      (setq P1 (RFL:PROFPOINT (car (nth C1 ELEVLIST)) (+ (cadr (nth C1 ELEVLIST)) EYE)))
      (setq P2 (RFL:PROFPOINT (car (nth C2 ELEVLIST)) (+ (cadr (nth C2 ELEVLIST)) TARGET)))
      (entmake (list (cons 0 "LINE")
                     (append (list 10) (list (car P1) (cadr P1) 0.0))
                     (append (list 11) (list (car P2) (cadr P2) 0.0))
               )
      )
      (setq ENT (entlast))
      (RFL:PUTPREVENT ENT PREVENT)(RFL:PUTNEXTENT PREVENT ENT)(setq PREVENT ENT)
      (princ (strcat (rtos (car (nth C1 ELEVLIST)) 2 8) "," (rtos (abs (- (car (nth C2 ELEVLIST)) (car (nth C1 ELEVLIST)))) 2 8) "\n") OUTFILE)
      (if (= nil SIGHTDISTMIN)
       (setq SIGHTDISTMIN (abs (- (car (nth C2 ELEVLIST)) (car (nth C1 ELEVLIST)))))
       (if (< (abs (- (car (nth C2 ELEVLIST)) (car (nth C1 ELEVLIST)))) SIGHTDISTMIN)
        (setq SIGHTDISTMIN (abs (- (car (nth C2 ELEVLIST)) (car (nth C1 ELEVLIST)))))
       )
      )
     )
     (progn
     )
    )
    (setq C1 (+ C1 10))
   )
  )
 )
; (alert (strcat "Minimum sight distance = " (rtos SIGHTDISTMIN 2 1)))
 
 (close OUTFILE)
 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
);
;
;     Program written by Robert Livingston, 2013-02-20
;
;     C:STOPSIGHT3D is a routine for drawing lines from a point to points along an LWPolyline and checking for elevation conflicts
;
;
(defun C:STOPSIGHT3D (/ *error* ALSAVE ANALYZELEFT ANALYZERIGHT ANGBASE ANGDIR BELOWFLAG CECOLOR CLAYER DMAX ELEV ENT ENTLIST HEYE HTARGET INC INCLAYER LANE OBSURFACE OSMODE ORTHOMODE OS P P1 P2 PLONG PEYE PTARGET STA STASTART STAMAX STEP)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq CLAYER (getvar "CLAYER"))
 (setq CECOLOR (getvar "CECOLOR"))
 (setq TOL 0.000001)
 (setq ALSAVE RFL:ALIGNLIST)
 (command "._UNDO" "M")
 
 (defun *error* (msg)
  (princ msg)
  (setvar "CMDECHO" CMDECHO)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (setvar "CLAYER" CLAYER)
  (setvar "CECOLOR" CECOLOR)
  (setq RFL:ALIGNLIST ALSAVE PVILIST PVISAVE SUPERLIST ESAVE)
  ;(setq *error* nil)
 )

 (if (= nil VLAX-CREATE-OBJECT) (vl-load-com))

 (setq OBSURFACE (RFL:GETC3DSURFACE))
 
 (if (= nil OBSURFACE)
  (progn
   (princ "\n!!! Error getting surface !!!")
  )
  (progn
   (setq ENT (entsel "\nSelect target center polyline : "))
   (if (/= nil ENT)
    (progn
     (setq P (cadr ENT))
     (setq ENT (car ENT))
     (setq ENTLIST (entget ENT))
     (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
      (progn
       (command "._CONVERT" "P" "S" ENT "")
       (setq ENTLIST (entget ENT))
      )
     )
     (if (/= "LWPOLYLINE" (cdr (assoc 0 ENTLIST)))
      (progn
       (princ "\n!!! Not a 2D Polyline !!!")
      )
      (progn
       (setq P1 (cdr (assoc 10 ENTLIST)))
       (setq P2 (cdr (assoc 10 (reverse ENTLIST))))
       (if (< (distance P P1) (distance P P2))
        (setq RFL:ALIGNLIST (RFL:ALIGNDEF ENT P1 0.0))
        (setq RFL:ALIGNLIST (RFL:ALIGNDEF ENT P2 0.0))
       )
       (if (= nil RFL:ALIGNLIST)
        (progn
         (princ "\n!!! Error generating target path !!!")
        )
        (progn
         (initget "Inside Outside Both")
         (setq ANALYZELEFT (getkword "\nLeft of eye analysis (<Inside> / Outside / Both) : "))
         (if (= nil ANALYZELEFT) (setq ANALYZELEFT "Inside"))
         (initget "Inside Outside Both")
         (setq ANALYZERIGHT (getkword "\nRight of eye analysis (Inside / <Outside> / Both) : "))
         (if (= nil ANALYZERIGHT) (setq ANALYZERIGHT "Outside"))
         (setq HEYE (getreal "\nEnter eye height <1.050> : "))
         (if (= nil HEYE) (setq HEYE 1.05))
         (setq HTARGET (getreal "\nEnter target height <0.380> : "))
         (if (= nil HTARGET) (setq HTARGET 0.38))
         (setq LANE (getreal "\nEnter lane width (note: target OS = lane / 2.0) <3.70> : "))
         (setq DMAX 0.0)
         (while (< DMAX TOL) (setq DMAX (getdist "\nEnter maximum sightline length : ")))
         (if (= nil LANE) (setq LANE 3.70))
         (setq STEP nil)
         (setq STEP (getdist "\nEnter step size <1.0> : "))
         (if (= nil STEP) (setq STEP 1.0))
         (initget "Yes No")
         (setq INCLAYER (getkword "\nIncriment layers (<Yes>/No) : "))
         (if (or (= nil INCLAYER) (= "Yes" INCLAYER))
          (progn
           (setq INCLAYER (getint "\nEnter start layer number suffix (<1>) : "))
           (if (= nil INCLAYER) (setq INCLAYER 1))
          )
         )
         (while (/= nil (setq PEYE (getpoint "\nEye point : ")))
          (setvar "OSMODE" 0)
          (if (/= "No" INCLAYER)
           (progn
            (if (= nil (tblsearch "LAYER" (strcat CLAYER "_" (itoa INCLAYER))))
             (progn
              (entmake (list (cons 0 "LAYER")
                             (cons 100 "AcDbSymbolTableRecord")
                             (cons 100 "AcDbLayerTableRecord")
                             (cons 2 (strcat CLAYER "_" (itoa INCLAYER)))
                             (cons 70 0)
                       )
              )
              (setvar "CLAYER" (strcat CLAYER "_" (itoa INCLAYER)))
             )
             (setvar "CLAYER" (strcat CLAYER "_" (itoa INCLAYER)))
            )
            (setq INCLAYER (+ INCLAYER 1))
           )
          )
          (setq P1 (RFL:STAOFF PEYE))
          (if (= nil P1)
           (princ "\n!!! Point not adjacent to target line !!!")
           (progn
            (setq ELEV (vlax-invoke-method OBSURFACE "FindElevationAtXY" (car PEYE) (cadr PEYE)))
            (if (= nil ELEV)
             (progn
              (princ "\n!!! Error getting eye surface elevation !!!")
             )
             (progn
              (setq PEYE (list (car PEYE) (cadr PEYE) (+ ELEV HEYE)))
              (setq STASTART (car P1))
              ; Left - Inside
              (if (or (= "Both" ANALYZELEFT) (= "Inside" ANALYZELEFT))
               (progn
                (if (< (cadr P1) 0.0)
                 (progn
                  (setq OS (* -0.5 LANE))
                  (setq INC STEP)
                 )
                 (progn
                  (setq OS (* 0.5 LANE))
                  (setq INC (* -1.0 STEP))
                 )
                )
                (setq STA STASTART)
                (setq PTARGET (RFL:XY (list STA OS)))
                (setq BELOWFLAG nil)
                (setq PLONG PTARGET)
                (while (/= nil PTARGET)
                 (setq ELEV (vlax-invoke-method OBSURFACE "FindElevationAtXY" (car PTARGET) (cadr PTARGET)))
                 (if (/= nil ELEV)
                  (progn
                   (setq PTARGET (list (car PTARGET) (cadr PTARGET) (+ ELEV HTARGET)))
                   (command "._LINE" PEYE PTARGET "")
                   (setq ENT (entlast))
                   (if BELOWFLAG
                    (progn
                     (RFL:SURFACELINE OBSURFACE ENT)
                    )
                    (progn
                     (setq BELOWFLAG (RFL:SURFACELINE OBSURFACE ENT))
                     (if (not BELOWFLAG)
                      (setq PLONG PTARGET)
                     )
                    )
                   )
                   (entdel ENT)
                  )
                 )
                 (setq STA (+ STA INC))
                 (setq PTARGET (RFL:XY (list STA OS)))
                 (if (/= nil PTARGET)
                  (if (> (distance (list (car PEYE) (cadr PEYE)) (list (car PTARGET) (cadr PTARGET))) DMAX)
                   (progn
                    (if (= nil BELOWFLAG) (setq BELOWFLAG "MAX"))
                    (setq PTARGET nil)
                   )
                  )
                 )
                )
                (if (/= nil PLONG)
                 (progn
                  (command "._DIMALIGNED" (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG)) (list (car PEYE) (cadr PEYE)))
                  (setq ENT (entlast))
                  (setq ENTLIST (entget ENT))
                  (setq ENTLIST (subst (cons 1 (strcat "Max. Sight Distance "
                                                       (if (= "MAX" BELOWFLAG)
                                                        (strcat "> " (rtos DMAX 2 0))
                                                        (strcat "= " (rtos (distance (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG))) 2 0))
                                                       )
                                               )
                                       )
                                       (assoc 1 ENTLIST)
                                       ENTLIST
                                )
                  )
                  (entmod ENTLIST)
                  (entupd ENT)
                 )
                )
               )
              )
              ; Left - Outside
              (if (or (= "Both" ANALYZELEFT) (= "Outside" ANALYZELEFT))
               (progn
                (if (< (cadr P1) 0.0)
                 (progn
                  (setq OS (* 0.5 LANE))
                  (setq INC STEP)
                 )
                 (progn
                  (setq OS (* -0.5 LANE))
                  (setq INC (* -1.0 STEP))
                 )
                )
                (setq STA STASTART)
                (setq PTARGET (RFL:XY (list STA OS)))
                (setq BELOWFLAG nil)
                (setq PLONG PTARGET)
                (while (/= nil PTARGET)
                 (setq ELEV (vlax-invoke-method OBSURFACE "FindElevationAtXY" (car PTARGET) (cadr PTARGET)))
                 (if (/= nil ELEV)
                  (progn
                   (setq PTARGET (list (car PTARGET) (cadr PTARGET) (+ ELEV HTARGET)))
                   (command "._LINE" PEYE PTARGET "")
                   (setq ENT (entlast))
                   (if BELOWFLAG
                    (progn
                     (RFL:SURFACELINE OBSURFACE ENT)
                    )
                    (progn
                     (setq BELOWFLAG (RFL:SURFACELINE OBSURFACE ENT))
                     (if (not BELOWFLAG)
                      (setq PLONG PTARGET)
                     )
                    )
                   )
                   (entdel ENT)
                  )
                 )
                 (setq STA (+ STA INC))
                 (setq PTARGET (RFL:XY (list STA OS)))
                 (if (/= nil PTARGET)
                  (if (> (distance (list (car PEYE) (cadr PEYE)) (list (car PTARGET) (cadr PTARGET))) DMAX)
                   (progn
                    (if (= nil BELOWFLAG) (setq BELOWFLAG "MAX"))
                    (setq PTARGET nil)
                   )
                  )
                 )
                )
                (if (/= nil PLONG)
                 (progn
                  (command "._DIMALIGNED" (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG)) (list (car PEYE) (cadr PEYE)))
                  (setq ENT (entlast))
                  (setq ENTLIST (entget ENT))
                  (setq ENTLIST (subst (cons 1 (strcat "Max. Sight Distance "
                                                       (if (= "MAX" BELOWFLAG)
                                                        (strcat "> " (rtos DMAX 2 0))
                                                        (strcat "= " (rtos (distance (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG))) 2 0))
                                                       )
                                               )
                                       )
                                       (assoc 1 ENTLIST)
                                       ENTLIST
                                )
                  )
                  (entmod ENTLIST)
                  (entupd ENT)
                 )
                )
               )
              )
              ; Right - Inside
              (if (or (= "Both" ANALYZERIGHT) (= "Inside" ANALYZERIGHT))
               (progn
                (if (< (cadr P1) 0.0)
                 (progn
                  (setq OS (* 0.5 LANE))
                  (setq INC (* -1.0 STEP))
                 )
                 (progn
                  (setq OS (* -0.5 LANE))
                  (setq INC STEP)
                 )
                )
                (setq STA STASTART)
                (setq PTARGET (RFL:XY (list STA OS)))
                (setq BELOWFLAG nil)
                (setq PLONG PTARGET)
                (while (/= nil PTARGET)
                 (setq ELEV (vlax-invoke-method OBSURFACE "FindElevationAtXY" (car PTARGET) (cadr PTARGET)))
                 (if (/= nil ELEV)
                  (progn
                   (setq PTARGET (list (car PTARGET) (cadr PTARGET) (+ ELEV HTARGET)))
                   (command "._LINE" PEYE PTARGET "")
                   (setq ENT (entlast))
                   (if BELOWFLAG
                    (progn
                     (RFL:SURFACELINE OBSURFACE ENT)
                    )
                    (progn
                     (setq BELOWFLAG (RFL:SURFACELINE OBSURFACE ENT))
                     (if (not BELOWFLAG)
                      (setq PLONG PTARGET)
                     )
                    )
                   )
                   (entdel ENT)
                  )
                 )
                 (setq STA (+ STA INC))
                 (setq PTARGET (RFL:XY (list STA OS)))
                 (if (/= nil PTARGET)
                  (if (> (distance (list (car PEYE) (cadr PEYE)) (list (car PTARGET) (cadr PTARGET))) DMAX)
                   (progn
                    (if (= nil BELOWFLAG) (setq BELOWFLAG "MAX"))
                    (setq PTARGET nil)
                   )
                  )
                 )
                )
                (if (/= nil PLONG)
                 (progn
                  (command "._DIMALIGNED" (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG)) (list (car PEYE) (cadr PEYE)))
                  (setq ENT (entlast))
                  (setq ENTLIST (entget ENT))
                  (setq ENTLIST (subst (cons 1 (strcat "Max. Sight Distance "
                                                       (if (= "MAX" BELOWFLAG)
                                                        (strcat "> " (rtos DMAX 2 0))
                                                        (strcat "= " (rtos (distance (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG))) 2 0))
                                                       )
                                               )
                                       )
                                       (assoc 1 ENTLIST)
                                       ENTLIST
                                )
                  )
                  (entmod ENTLIST)
                  (entupd ENT)
                 )
                )
               )
              )
              ; Right - Outside
              (if (or (= "Both" ANALYZERIGHT) (= "Outside" ANALYZERIGHT))
               (progn
                (if (< (cadr P1) 0.0)
                 (progn
                  (setq OS (* 0.5 LANE))
                  (setq INC (* -1.0 STEP))
                 )
                 (progn
                  (setq OS (* -0.5 LANE))
                  (setq INC STEP)
                 )
                )
                (setq STA STASTART)
                (setq PTARGET (RFL:XY (list STA OS)))
                (setq BELOWFLAG nil)
                (setq PLONG PTARGET)
                (while (/= nil PTARGET)
                 (setq ELEV (vlax-invoke-method OBSURFACE "FindElevationAtXY" (car PTARGET) (cadr PTARGET)))
                 (if (/= nil ELEV)
                  (progn
                   (setq PTARGET (list (car PTARGET) (cadr PTARGET) (+ ELEV HTARGET)))
                   (command "._LINE" PEYE PTARGET "")
                   (setq ENT (entlast))
                   (if BELOWFLAG
                    (progn
                     (RFL:SURFACELINE OBSURFACE ENT)
                    )
                    (progn
                     (setq BELOWFLAG (RFL:SURFACELINE OBSURFACE ENT))
                     (if (not BELOWFLAG)
                      (setq PLONG PTARGET)
                     )
                    )
                   )
                   (entdel ENT)
                  )
                 )
                 (setq STA (+ STA INC))
                 (setq PTARGET (RFL:XY (list STA OS)))
                 (if (/= nil PTARGET)
                  (if (> (distance (list (car PEYE) (cadr PEYE)) (list (car PTARGET) (cadr PTARGET))) DMAX)
                   (progn
                    (if (= nil BELOWFLAG) (setq BELOWFLAG "MAX"))
                    (setq PTARGET nil)
                   )
                  )
                 )
                )
                (if (/= nil PLONG)
                 (progn
                  (command "._DIMALIGNED" (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG)) (list (car PEYE) (cadr PEYE)))
                  (setq ENT (entlast))
                  (setq ENTLIST (entget ENT))
                  (setq ENTLIST (subst (cons 1 (strcat "Max. Sight Distance "
                                                       (if (= "MAX" BELOWFLAG)
                                                        (strcat "> " (rtos DMAX 2 0))
                                                        (strcat "= " (rtos (distance (list (car PEYE) (cadr PEYE)) (list (car PLONG) (cadr PLONG))) 2 0))
                                                       )
                                               )
                                       )
                                       (assoc 1 ENTLIST)
                                       ENTLIST
                                )
                  )
                  (entmod ENTLIST)
                  (entupd ENT)
                 )
                )
               )
              )
             )
            )
           )
          )
          (setvar "OSMODE" OSMODE)
         )
        )
       )
      )
     )
    )
   )        
  )
 )

 (setvar "CMDECHO" CMDECHO)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "CLAYER" CLAYER)
 (setvar "CECOLOR" CECOLOR)
 (setq RFL:ALIGNLIST ALSAVE)
);
;
;     Program written by Robert Livingston 2013-02-12
;
;     RFL:SIGHTDIST returns a station that is DIST away from STA
;
;
(if RFL:SIGHTDIST (princ "\nRFL:SIGHTDIST already loaded...")
(defun RFL:SIGHTDIST (STA DIST / P P1 P2 PM POUT STA1 STA2 STAM)
 (if (= RFL:ALIGNLIST nil)
  nil
  (if (or (< STA (caar RFL:ALIGNLIST)) (> STA (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH))))
   nil
   (if (> DIST 0.0)
    (if (setq P (RFL:XY (list STA 0.0)))
     (progn
      (setq STA1 STA)
      (setq P1 P)
      (setq STA2 (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)))
      (setq P2 (caddr (last RFL:ALIGNLIST)))
      (if (> (distance P P2) DIST)
       (progn
        (while (> (abs (- STA2 STA1)) RFL:TOL)
         (setq STAM (/ (+ STA1 STA2) 2.0))
         (setq PM (RFL:XY (list STAM 0.0)))
         (if (> (distance P PM) DIST)
          (progn
           (setq P2 PM)
           (setq STA2 STAM)
          )
          (progn
           (setq P1 PM)
           (setq STA1 STAM)
          )
         )
        )
        STAM
       )
       nil
      )
     )
     nil
    )
    (if (setq P (RFL:XY (list STA 0.0)))
     (progn
      (setq DIST (* DIST -1.0))
      (setq STA1 STA)
      (setq P1 P)
      (setq STA2 (caar RFL:ALIGNLIST))
      (setq P2 (cadar RFL:ALIGNLIST))
      (if (> (distance P P2) DIST)
       (progn
        (while (> (abs (- STA2 STA1)) RFL:TOL)
         (setq STAM (/ (+ STA1 STA2) 2.0))
         (setq PM (RFL:XY (list STAM 0.0)))
         (if (> (distance P PM) DIST)
          (progn
           (setq P2 PM)
           (setq STA2 STAM)
          )
          (progn
           (setq P1 PM)
           (setq STA1 STAM)
          )
         )
        )
        STAM
       )
       nil
      )
     )
     nil
    )
   )
  )
 )
)
);
;
;     Program written by Robert Livingston, 2015-10-02
;
;     RFL:SIGHTDISTPROF is a utility for calculating the sight distance from a given Station along a profile
;
;     STA : Station of Eye
;     DIR : Direction, 1 = Up Chainage, -1 = Down Chainage
;     EYE : Eye Height
;     TARGET : Target Height
;     STEP : Increment
;     MAXDIST : Maximum distance to check
;
(defun RFL:SIGHTDISTPROF (STA DIR EYE TARGET STEP MAXDIST / CHECKSIGHT SIGHTDIST STASTART STAEND STOPFLAG ZLIST)
;(defun SIGHTDISTPROF (STA DIR EYE TARGET STEP MAXDIST)
 (defun CHECKSIGHT (/ C NODE S STA1 STA2 SLOPE Z1 Z2)
  (setq STA1 (caar ZLIST))
  (setq Z1 (+ (cadar ZLIST) EYE))
  (setq STA2 (car (last ZLIST)))
  (setq Z2 (+ (cadr (last ZLIST)) TARGET))
  (setq S (/ (- Z2 Z1) (- STA2 STA1)))
  (setq C 0)
  (while (and (< C (length ZLIST))
              (<= (cadr (nth C ZLIST)) (+ Z1 (* (- (car (nth C ZLIST)) STA1) S)))
         )
   (setq C (+ C 1))
  )
  (if (= C (length ZLIST))
   T
   nil
  )
 )
 (setq STA (float STA))
 (setq DIR (float DIR))
 (setq EYE (float EYE))
 (setq TARGET (float TARGET))
 (setq STEP (float STEP))
 (setq MAXDIST (float MAXDIST))
 (if (= nil RFL:PVILIST)
  (progn
   (princ "\n***** No Profile Defined! *****\n")
   nil
  )
  (if (or (< STA (caar RFL:PVILIST)) (> STA (car (last RFL:PVILIST))))
   (progn
    (princ "\n***** Station Outside Of Profile! *****\n")
    nil
   )
   (progn
    (setq STASTART STA)
    (setq ZLIST (list (list STA (RFL:ELEVATION STA))))
    (setq STA (+ STA (* DIR STEP)))
    (setq ZLIST (append ZLIST (list (list STA (RFL:ELEVATION STA)))))
    (while (and (CHECKSIGHT) 
                (<= (abs (- STA STASTART)) MAXDIST)
                (>= STA (+ (caar RFL:PVILIST) STEP))
                (<= STA (- (car (last RFL:PVILIST)) STEP))
           )
     
     (setq STA (+ STA (* DIR STEP)))
     (setq ZLIST (append ZLIST (list (list STA (RFL:ELEVATION STA)))))
    )
    (setq STA (- STA (* DIR STEP)))
    (abs (- STA STASTART))
   )
  )
 )  
)
;
;
;     Program written by Robert Livingston 2013-02-12
;
;     RFL:SURFACELINE returns a list of surface points (Civil 3D) sampled from endpoints of line entity
;
;
(defun RFL:SURFACELINE (OBSURFACE ENT / BELOWFLAG C CECOLOR CENT CLAYER COLORA COLORB ELEVL ENTLIST H H1 H2 LTOTAL L1 L2 LAYERA LAYERB OBSURFACE OGLINE OGLINELIST OGOFFSETLIST OSMODE ORTHOMODE P PBASE P1 P2 POINTL PREVENT Z Z1 Z2)
 (setq PREVENT nil)
 (setq BELOWFLAG nil)
 (defun ELEVL (L LTOTAL Z1 Z2 / )
  (+ Z1 (* (/ L LTOTAL) (- Z2 Z1)))
 )
 (defun POINTL (L LTOTAL P1 P2 Z)
  (list (+ (car P1) (* (/ L LTOTAL) (- (car P2) (car P1))))
        (+ (cadr P1) (* (/ L LTOTAL) (- (cadr P2) (cadr P1))))
        Z
  )
 )
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq CECOLOR (getvar "CECOLOR"))
 (setq COLORA "RGB:0,255,0")
 (setq COLORB "RGB:255,0,0")
 (setq CLAYER (getvar "CLAYER"))
 (setq LAYERA (strcat CLAYER "_ABOVE"))
 (setq LAYERB (strcat CLAYER "_BELOW"))
 (if (= nil (tblsearch "LAYER" LAYERA))
  (entmake (list (cons 0 "LAYER")
                 (cons 100 "AcDbSymbolTableRecord")
                 (cons 100 "AcDbLayerTableRecord")
                 (cons 2 LAYERA)
                 (cons 62 -7)
                 (cons 70 0)
           )
  )
 )
 (if (= nil (tblsearch "LAYER" LAYERB))
  (entmake (list (cons 0 "LAYER")
                 (cons 100 "AcDbSymbolTableRecord")
                 (cons 100 "AcDbLayerTableRecord")
                 (cons 2 LAYERB)
                 (cons 62 -7)
                 (cons 70 0)
           )
  )
 )
 (setq OGLINE nil)
 (setq OGLINELIST nil)
 (setq OGOFFSETLIST nil)
 (if (/= nil ENT) (setq ENTLIST (entget ENT)))
 (if (and (/= nil OBSURFACE) (= "LINE" (cdr (assoc 0 ENTLIST))))
  (progn
   (setq P1 (cdr (assoc 10 ENTLIST)))
   (setq P2 (cdr (assoc 11 ENTLIST)))
   (setq OGLINE (vlax-invoke-method OBSURFACE "SampleElevations" (car P1) (cadr p1) (car P2) (cadr p2)))
   (if (/= nil OGLINE)
    (if (/= 0 (vlax-variant-type OGLINE))
     (progn
      (setq OGLINELIST nil)
      (setq OGLINE (vlax-variant-value OGLINE))
      (setq C (vlax-safearray-get-l-bound OGLINE 1))
      (while (<= C (vlax-safearray-get-u-bound OGLINE 1))
       (setq OGLINELIST (append OGLINELIST (list (list (vlax-safearray-get-element OGLINE C)
                                                       (vlax-safearray-get-element OGLINE (+ C 1))
                                                       (vlax-safearray-get-element OGLINE (+ C 2))
                                                 )
                                           )
                        )
       )
       (setq C (+ C 3))
      )
      (setq C 0)
      (while (< C (length OGLINELIST))
       (setq P (nth C OGLINELIST))
       (setq P (list (car P) (cadr P)))
       (setq OGOFFSETLIST (append OGOFFSETLIST
                                  (list (list (distance (list (car P1) (cadr P1)) P)
                                              (last (nth C OGLINELIST))
                                        )
                                  )
                          )
       )
       (setq C (+ C 1))
      )
     )
    )
   )
  )
 )
 (if (/= nil OGOFFSETLIST)
  (progn
   (setq C 1)
   (setq Z1 (caddr P1))
   (setq P1 (list (car P1) (cadr P1)))
   (setq Z2 (caddr P2))
   (setq P2 (list (car P2) (cadr P2)))
   (setq LTOTAL (distance P1 P2))
   (setq PBASE (list 0 Z1))
   (while (< C (length OGOFFSETLIST))
    (if (/= nil (setq P (inters (list 0 Z1)
                                (list LTOTAL Z2)
                                (nth (- C 1) OGOFFSETLIST)
                                (nth C OGOFFSETLIST))))
     (progn
      (if (> (ELEVL (car (nth (- C 1) OGOFFSETLIST)) LTOTAL Z1 Z2) (cadr (nth (- C 1) OGOFFSETLIST)))
       (progn
        (setvar "CECOLOR" COLORA)
        (setvar "CLAYER" LAYERA)
       )
       (progn
        (setq BELOWFLAG T)
        (setvar "CECOLOR" COLORB)
        (setvar "CLAYER" LAYERB)
       )
      )
      (entmake (list (cons 0 "LINE")
                     (append (list 10) (POINTL (car PBASE) LTOTAL P1 P2 (cadr PBASE)))
                     (append (list 11) (POINTL (car P) LTOTAL P1 P2 (cadr P)))
               )
      )
      (setq CENT (entlast))
      (RFL:PUTPREVENT CENT PREVENT)(RFL:PUTNEXTENT PREVENT CENT)(setq PREVENT CENT)
      (setq PBASE P)
     )
    )
    (setq C (+ C 1))
   )
   (if (> (ELEVL (car (last OGOFFSETLIST)) LTOTAL Z1 Z2) (cadr (last OGOFFSETLIST)))
    (progn
     (setvar "CECOLOR" COLORA)
     (setvar "CLAYER" LAYERA)
    )
    (progn
     (setq BELOWFLAG T)
     (setvar "CECOLOR" COLORB)
     (setvar "CLAYER" LAYERB)
    )
   )
   (entmake (list (cons 0 "LINE")
                  (append (list 10) (POINTL (car PBASE) LTOTAL P1 P2 (cadr PBASE)))
                  (append (list 11) (POINTL (car (last OGOFFSETLIST)) LTOTAL P1 P2 Z2))
            )
   )
   (setq CENT (entlast))
   (RFL:PUTPREVENT CENT PREVENT)(RFL:PUTNEXTENT PREVENT CENT)(setq PREVENT CENT)
  )
 )
 (setvar "CECOLOR" CECOLOR)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (setvar "CLAYER" CLAYER)
 BELOWFLAG
);
;
;     Program written by Robert Livingston, 2015-08-28
;
;     C:BARRIERWARRANT is a utility for analysing cross section and outputting a .csv to be used in the Barrier Warrant spreadsheet
;
;
(defun C:BARRIERWARRANT (/ *error* ANGBASE ANGDIR ATTREQ CMDECHO DAYLIGHTLIST GETDAYLIGHT NODE
                           OBSURFACE ORTHOMODE OSMODE OUTFILE REP ROADW S SECTIONLIST SECTIONSET
                           SLOPECUT SLOPEFILL STA STAEND STASTART STEP SUPERL SUPERR SWATH TMP Z)
 (setq ATTREQ (getvar "ATTREQ"))
 (setvar "ATTREQ" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)

 (defun *error* (msg)
  (setvar "ATTREQ" ATTREQ)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (close OUTFILE)
  (print msg)
 )

 (defun GETDAYLIGHT (SECTIONLIST Z ROADWL SLOPECUTL SLOPEFILLL SUPERL ROADWR SLOPECUTR SLOPEFILLR SUPERR / C P1L P2LC P2LF P2RC P2RF PL PR TMP)
  (setq PL nil)
  (setq P1L (list (* -1.0 ROADWL) (+ Z (* ROADWL SUPERL 0.01))))
  (setq TMP (caar SECTIONLIST))
  (setq P2LC (list TMP (+ Z (/ (- (car P1L) TMP) SLOPECUTL))))
  (setq P2LF (list TMP (+ Z (/ (- TMP (car P1L)) SLOPEFILLL))))
  (setq PR nil)
  (setq P1R (list ROADWR (+ Z (* ROADWR SUPERR 0.01))))
  (setq TMP (car (last SECTIONLIST)))
  (setq P2RC (list TMP (+ Z (/ (- TMP (car P1R)) SLOPECUTR))))
  (setq P2RF (list TMP (+ Z (/ (- (car P1R) TMP) SLOPEFILLR))))
  (setq C 1)
  (while (and (< C (length SECTIONLIST)) (< (car (nth (- C 1) SECTIONLIST)) 0.0))
   (if (setq TMP (inters P1L P2LC (nth (- C 1) SECTIONLIST) (nth C SECTIONLIST)))
    (if (<= (car TMP) (* ROADWL -1.0))
     (setq PL TMP)
    )
   )
   (if (setq TMP (inters P1L P2LF (nth (- C 1) SECTIONLIST) (nth C SECTIONLIST)))
    (if (<= (car TMP) (* ROADWL -1.0))
     (setq PL TMP)
    )
   )
   (setq C (+ C 1))
  )
  (setq C (- (length SECTIONLIST) 1))
  (while (and (> C 0) (> (car (nth C SECTIONLIST)) 0.0))
   (if (setq TMP (inters P1R P2RC (nth (- C 1) SECTIONLIST) (nth C SECTIONLIST)))
    (if (>= (car TMP) ROADWL)
     (setq PR TMP)
    )
   )
   (if (setq TMP (inters P1R P2RF (nth (- C 1) SECTIONLIST) (nth C SECTIONLIST)))
    (if (>= (car TMP) ROADWL)
     (setq PR TMP)
    )
   )
   (setq C (- C 1))
  )
  (list P1L PL P1R PR)
 )

 (if RFL:ALIGNLIST
  (if RFL:PVILIST
   (if (setq OBSURFACE (RFL:GETC3DSURFACE))
    (progn
     (setq SWATH 250.0)
     (if (setq REP (getdist (strcat "\nEnter swath width : <" (rtos SWATH) "> : ")))
      (setq SWATH REP)
     )
     (setq ROADW 10.0)
     (setq SLOPECUT 2.0)
     (setq SLOPEFILL 2.0)
     (if (setq REP (getdist (strcat "\nEnter road width <" (rtos ROADW) "> : ")))
      (setq ROADW REP)
     )
     (if (setq REP (getdist (strcat "\nEnter cut slope X:1 <" (rtos SLOPECUT) "> : ")))
      (setq SLOPECUT REP)
     )
     (if (setq REP (getdist (strcat "\nEnter fill slope X:1 <" (rtos SLOPEFILL) "> : ")))
      (setq SLOPEFILL REP)
     )
     (setq STEP 20.0)
     (if (setq REP (getdist (strcat "\nEnter station step size : <" (rtos STEP) "> : ")))
      (setq STEP REP)
     )
     (setq STASTART (max (caar RFL:ALIGNLIST) (caar RFL:PVILIST)))
     (if (= nil (setq REP (getdist (strcat "\nEnter start station (min = " (rtos STASTART) ") <" (rtos (float (* STEP (+ 1 (fix (/ STASTART STEP)))))) "> : "))))
      (setq STASTART (float (* STEP (+ 1 (fix (/ STASTART STEP))))))
     )
     (setq STAEND (min (+ (caar RFL:ALIGNLIST) (RFL:GETALIGNLENGTH)) (car (last RFL:PVILIST))))
     (if (= nil (setq REP (getdist (strcat "\nEnter start end (max = " (rtos STAEND) ") <" (rtos (float (* STEP (fix (/ STAEND STEP))))) "> : "))))
      (setq STAEND (float (* STEP (fix (/ STAEND STEP)))))
     )
     (setq SECTIONSET (RFL:GETSECTIONSET STASTART STAEND SWATH STEP OBSURFACE RFL:ALIGNLIST))
     (setq STA STASTART)
     (princ (strcat "\nFile written to: " (getenv "UserProfile") "\\Documents\\" "BarrierWarrant.CSV"))
     (setq OUTFILE (open (strcat (getenv "UserProfile") "\\Documents\\" "BarrierWarrant.CSV") "w"))
     (while (<= STA STAEND)
      (princ (strcat "\nSta : " (RFL:STATXT STA)))
      (setq SECTIONLIST (cadr (assoc STA SECTIONSET)))
      (if SECTIONLIST
       (progn
        (setq Z (RFL:ELEVATION STA))
        (if RFL:SUPERLIST
         (if (setq S (RFL:SUPER STA))
          (setq SUPERL (car S) SUPERR (cadr S))
          (setq SUPERL 0.0 SUPERR 0.0)
         )
         (setq SUPERL 0.0 SUPERR 0.0)
        )
        (setq TMP (GETDAYLIGHT SECTIONLIST Z (/ ROADW 2.0) SLOPECUT SLOPEFILL SUPERL (/ ROADW 2.0) SLOPECUT SLOPEFILL SUPERR))
        (princ (strcat "\nSta : " (RFL:STATXT STA) ", R : " (rtos (RFL:GETRADIUS STA) 2 3) ", Grade : " (rtos (* (RFL:SLOPE STA) 100.0) 2 3) ", L Fill : " (rtos (- (cadr (car TMP)) (cadr (cadr TMP))) 2 3) ", R Fill = " (rtos (- (cadr (caddr TMP)) (cadr (cadddr TMP))) 2 3)))
        (princ (strcat (rtos STA 2 8) "," (rtos (RFL:GETRADIUS STA) 2 8) "," (rtos (* (RFL:SLOPE STA) 100.0) 2 8) "," (rtos (- (cadr (car TMP)) (cadr (cadr TMP))) 2 8) "," (rtos (- (cadr (caddr TMP)) (cadr (cadddr TMP))) 2 8) "\n") OUTFILE)
       )
      )
      (setq STA (+ STA STEP))
     )
     (close OUTFILE)
    )
    (princ "\n!!! No Surface Selected !!!")
   )
   (princ "\n!!! No Profile Defined !!!")
  )
  (princ "\n!!! No Alignment Defined !!!")
 )
 (setvar "ATTREQ" ATTREQ)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
)