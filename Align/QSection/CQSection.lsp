;
;
;     Program written by Robert Livingston, 2015-01-29
;
;     C:QSECTION is a utility for drawing a cross section at a specified station
;
;
(defun C:QSECTION (/ *error* ANGBASE ATTREQ CMDECHO GETQSECTIONLIST INC INFILE INFILE2 INFILENAME INLINE INLINE2 OSMODE ORTHOMODE PBASE SHEIGHT STA STA1 STA2 STALIST)
;(defun C:QSECTION ()
 (setq ATTREQ (getvar "ATTREQ"))
 (setvar "ATTREQ" 0)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setq ORTHOMODE (getvar "ORTHOMODE"))

 (defun *error* (msg)
  (setvar "ATTREQ" ATTREQ)
  (setvar "ANGBASE" ANGBASE)
  (setvar "ANGDIR" ANGDIR)
  (setvar "CMDECHO" CMDECHO)
  (setvar "OSMODE" OSMODE)
  (setvar "ORTHOMODE" ORTHOMODE)
  (if (not INFILE) (close INFILE))
  (if (not INFILE2) (close INFILE2))
  ;(setq *error* nil)
  (print msg)
 )
 
 (defun GETQSECTIONLIST (/ DCIRCLE OBSURFACE REP SWATH THEIGHT VEXAG)
  (setq DCIRCLE nil)
  (setq RFL:QSECTIONALIGNLIST nil)
  (setq RFL:QSECTIONPROFILELIST nil)
  (setq VEXAG 10.0)
  (setq REP (getdist (strcat "\nVertical exaggeration <" (rtos VEXAG) "> : ")))
  (if (/= nil REP) (setq VEXAG REP))
  (setq SWATH 100.0)
  (setq REP (getdist (strcat "\nSwath width <" (rtos SWATH) "> : ")))
  (if (/= nil REP) (setq SWATH REP))
  (setq THEIGHT 5.0)
  (setq REP (getdist (strcat "\nText height <" (rtos THEIGHT) "> : ")))
  (if (/= nil REP) (setq THEIGHT REP))
  (initget "Yes No Block Template")
  (setq REP (getkword "\nDraw circle at design elevation (<Yes>/No/Block/Template) ? "))
  (if (= "No" REP)
   (setq DCIRCLE 0)
   (if (= "Block" REP)
    (progn
     (setq DCIRCLE nil)
     (while (= nil DCIRCLE)
      (setq DCIRCLE (car (entsel "\nSelect block (<return> to enter name) : ")))
      (if (= nil DCIRCLE)
       (setq DCIRCLE (getstring "\nBlock name : "))
       (setq DCIRCLE (cdr (assoc 2 (entget DCIRCLE))))
      )
      (if (/= nil DCIRCLE)
       (if (= nil (tblsearch "BLOCK" DCIRCLE))
        (setq DCIRCLE nil)
       )
      )
     )
    )
    (if (= "Template" REP)
     (progn
      (if (= (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") nil)
       (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" "")
      )
      (setq INFILENAME (getfiled "Select a Template File" (vl-registry-read "HKEY_CURRENT_USER\\rflAlignDirectory") "tpl" 2))
      (vl-registry-write "HKEY_CURRENT_USER\\rflAlignDirectory" "" (strcat (vl-filename-directory INFILENAME) "\\"))
      (setq INFILE (open INFILENAME "r"))
      (while (setq INLINE (read-line INFILE))
       (if (= "STA" (RFL:COLUMN INLINE 1 ","))
        (progn
         (setq TPLLIST nil)
         (setq STALIST (list (atof (RFL:COLUMN INLINE 2 ",")) (atof (RFL:COLUMN INLINE 3 ","))))
         (setq INFILE2 (open (RFL:COLUMN INLINE 4 ",") "r"))
         (while (setq INLINE2 (read-line INFILE2))
          (setq TPLLIST (append TPLLIST (list INLINE2)))
         )
         (close INFILE2)
         (setq DCIRCLE (append DCIRCLE (list (list STALIST TPLLIST))))
        )
        (setq DCIRCLE (append DCIRCLE (list INLINE)))
       )
      )
      (close INFILE)
     )
     (setq DCIRCLE 1)
    )
   )
  )
  (setq OBSURFACE nil)
  (setq REP "Yes")
  (while (= "Yes" REP)
   (setq OBSURFACE (append OBSURFACE (list (RFL:GETC3DSURFACE))))
   (initget "Yes No")
   (setq REP (getkword "\nAdd another (Yes/<No>) : "))
  )
  (setq MATCHGRIDENT (car (entsel "\nSelect grid to match (<return> for none) : ")))
  (setq OGLAYERENT (car (entsel "\nSelect OG layer to match (<return> for none) : ")))
  (setq DESLAYERENT (car (entsel "\nSelect design layer to match (<return> for none) : ")))
  (setq RFL:QSECTIONLIST (list (cons "VEXAG" VEXAG)
                               (cons "SWATH" SWATH)
                               (cons "THEIGHT" THEIGHT)
                               (cons "DCIRCLE" DCIRCLE)
                               (cons "OBSURFACE" OBSURFACE)
                               (cons "MATCHGRIDENT" MATCHGRIDENT)
                               (cons "OGLAYER" (cdr (assoc 8 (entget OGLAYERENT))))
                               (cons "DESLAYER" (cdr (assoc 8 (entget DESLAYERENT))))
                         )
  )
 )
 (if (= nil RFL:ALIGNLIST)
  (princ "\n!!! No Alignment Defined !!!")
  (progn
   (if (= nil RFL:QSECTIONLIST) (GETQSECTIONLIST))
   (while (= "" (setq STA (getstring "\nStation (<return> to pick point, 'P' to pick point, 'M' multiple stations) : ")))
    (GETQSECTIONLIST)
   )
   (if (= "P" (strcase (substr STA 1 1)))
    (setq STA (car (RFL:STAOFF (getpoint "\nPick point for section : "))))
    (if (= "M" (strcase (substr STA 1 1)))
     (setq STA (list (getreal "\nStart Station : ")
                     (getreal "\nEnd Station : ")
                     (getreal "\nStation Increment : ")
               )
     )
     (setq STA (atof STA))
    )
   )
   (setq PBASE (getpoint "\nBase point : "))
   (setvar "OSMODE" 0)
   (setvar "ORTHOMODE" 0)
   (if (listp STA)
    (progn
     (setq STA1 (car STA)
           STA2 (cadr STA)
           INC (caddr STA)
     )
     (setq SHEIGHT (getreal "\nSection height spacing : "))
     (setq STA STA1)
     (while (<= STA STA2)
      (RFL:QSECTION STA
                    (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                    PBASE
                    nil
                    (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                    (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                    (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                    (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
      )
      (setq STA (+ STA INC))
      (setq PBASE (list (car PBASE) (+ (cadr PBASE) SHEIGHT)))
     )
    )
    (RFL:QSECTION STA
                  (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                  PBASE
                  nil
                  (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                  (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                  (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                  (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
    )
   )
  )
 )
 (setvar "ATTREQ" ATTREQ)
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (eval nil)
)
(defun RFL:QSECTION (STA SWATH PBASE ZBASE VEXAG THEIGHT DCIRCLE OBSURFACE / A ADDHANDLE AFLAG ALLIST ALSAVE C CLAYER D DX DY DY2 DZ ENT ENTLIST ENTSET H HANDENTLIST GETTPL ISABOVE NODE OX P P0 P1 P2 PA PB OSLIST PLIST PVISAVE S1 S2 SLIST SLISTDEFAULT TLIST TLISTL TLISTCL TLISTFL TLISTR TLISTCR TLISTFR TMP TOL TX TY Z ZHEIGHT)
;(defun RFL:QSECTION (STA SWATH PBASE ZBASE VEXAG THEIGHT DCIRCLE OBSURFACE)
 (setq CLAYER (getvar "CLAYER"))
 (setq TOL 0.0001)
 (defun ISABOVE (P OSLIST / C RES)
  (if P
   (if OSLIST
    (progn
     (setq C 1)
     (while (< C (length OSLIST))
      (if (and (>= (car P) (car (nth (1- C) OSLIST)))
               (<= (car P) (car (nth C OSLIST)))
          )
       (if (> (cadr P)
              (+ (cadr (nth (1- C) OSLIST))
                 (* (- (car P) (car (nth (1- C) OSLIST)))
                    (/ (- (cadr (nth C OSLIST)) (cadr (nth (1- C) OSLIST)))
                       (- (car (nth C OSLIST)) (car (nth (1- C) OSLIST)))
                    )
                 )
              )
           )
        (setq RES T)
        (setq RES nil)
       )
      )
      (setq C (1+ C))
     )
    )
    (setq RES nil)
   )
   (setq RES nil)
  )
  RES
 )
 (if (or RFL:QSECTIONALIGNLIST RFL:QSECTIONPROFILELIST)
  (setq AFLAG nil)
  (setq AFLAG T)
 )
 (defun GETTPL (STA DCIRCLE / NODE TPLLIST)
  (if (listp (car DCIRCLE))
   (progn
    (setq TPLLIST nil)
    (foreach NODE DCIRCLE
     (if (and (>= STA (car (car NODE)))
              (< STA (cadr (car NODE)))
         )
      (setq TPLLIST (cadr NODE))
     )
    )
    TPLLIST
   )
   DCIRCLE
  )
 )
 (defun ADDHANDLE (/ C ENT FLAG NAME)
  (setq ENT (cdr (assoc 5 (entget (entlast)))))
  (setq C 0)
  (setq FLAG T)
  (while (and FLAG (< C (length HANDENTLIST)))
   (if (= ENT (nth C HANDENTLIST)) (setq FLAG nil))
   (setq C (+ C 1))
  )
  (if FLAG (setq HANDENTLIST (append HANDENTLIST (list ENT))))
 )
 (setq HANDENTLIST nil)
 (setq P0 (RFL:XY (list STA 0.0)))
 (setq P1 (RFL:XY (list STA (/ SWATH -2.0))))
 (setq P2 (RFL:XY (list STA (/ SWATH 2.0))))
 (setq PLIST nil)
 (foreach NODE OBSURFACE
  (setq PLIST (append PLIST (RFL:GETSURFACELINE P1 P2 NODE)))
  (setq PLIST (append PLIST (list "NewLine")))
 )
 (if (/= nil PLIST)
  (progn
   (if (= nil ZBASE)
    (progn
     (foreach P PLIST
      (if (/= "NewLine" P)
       (if (= nil ZBASE)
        (setq ZBASE (caddr P))
        (if (< (caddr P) ZBASE) (setq ZBASE (caddr P)))
       )
      )
     )
    )
   )
   (setq ZHEIGHT nil)
   (foreach P PLIST
    (if (/= "NewLine" P)
     (if (= nil ZHEIGHT)
      (setq ZHEIGHT (caddr P))
      (if (> (caddr P) ZHEIGHT) (setq ZHEIGHT (caddr P)))
     )
    )
   )
   (setq D (/ SWATH 2.0))
   (setq OSLIST nil)
   (foreach P PLIST
    (if (= P "NewLine")
     (setq OSLIST (append OSLIST (list "NewLine")))
     (setq OSLIST (append OSLIST (list (list (- (distance (list (car P) (cadr P)) P1) D) (caddr P)))))
    )
   )
   (setq Z (RFL:ELEVATION STA))
   (setq ENTLIST (list (cons 0 "TEXT")
                       (cons 1 (strcat "Sta: "
                                       (RFL:STATXT STA)
                                       (if Z
                                        (strcat " / Ctrl Elev: " (rtos Z))
                                        (strcat " / Text Elev: " (rtos ZBASE))
                                       )
                               )
                       )
                       (list 10 (car PBASE) (cadr PBASE) 0.0)
                       (list 11 (car PBASE) (cadr PBASE) 0.0)
                       (cons 40 (/ THEIGHT 10.0))
                       (cons 50 0.0)
                       (cons 72 4)
                 )
   )
   (entmake ENTLIST)
   (ADDHANDLE)
   (RFL:DRAWGRID (strcat "Sta: " (RFL:STATXT STA))                           ; Title Text
                 THEIGHT                                                     ; Title Height
                 THEIGHT                                                     ; Title OFFSET
                 (list (- (car PBASE) (/ SWATH 2.0)) (cadr PBASE))           ; Basepoint
                 (/ SWATH -2.0)                                              ; Base Station
                 ZBASE                                                       ; Base Elevation
                 SWATH                                                       ; Grid Width
                 (* (- ZHEIGHT ZBASE) VEXAG)                                 ; Grid Height
                 VEXAG                                                       ; Vertical Exageration
                 THEIGHT                                                     ; Text Height
                 THEIGHT                                                     ; Text OFFSET
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0)       ; Horizontal Grid
                 nil                                                         ; Horizontal Fine Grid
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0)       ; Horizontal Text
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0 VEXAG) ; Vertical Grid
                 nil                                                         ; Vertical Fine Grid
                 (/ (expt 10.0 (fix (/ (log SWATH) (log 10.0)))) 10.0 VEXAG) ; Vertical Text
                 "PR-GRID"                                                   ; Grid Layer
                 (getvar "CLAYER")                                           ; Fine Grid Layer
                 (getvar "CLAYER")                                           ; Text Layer
                 nil                                                         ; Label as Station
                 1.0                                                         ; Master Scale
                 1                                                           ; Direction (1 = Left to Right, -1 = Right to Left)
   )
   (if (cdr (assoc "MATCHGRIDENT" RFL:QSECTIONLIST))
    (RFL:MATCHGRID (cdr (assoc "MATCHGRIDENT" RFL:QSECTIONLIST)) (entlast))
   )
   (ADDHANDLE)
   (if (cdr (assoc "OGLAYER" RFL:QSECTIONLIST))
    (setvar "CLAYER" (cdr (assoc "OGLAYER" RFL:QSECTIONLIST)))
   )
   (command "._PLINE")
   (foreach P OSLIST
    (progn
     (if (= "NewLine" P)
      (progn
       (command)
       ;(setq HANDENTLIST (append HANDENTLIST (list (cdr (assoc 5 (entget (entlast)))))))
       (ADDHANDLE)
       (command "._PLINE")
      )
      (command (list (+ (car PBASE) (car P))
                     (+ (cadr PBASE) (* VEXAG (- (cadr P) ZBASE)))
               )
      )
     )
    )
   )
   (command)
   (setvar "CLAYER" CLAYER)
   ;(setq HANDENTLIST (append HANDENTLIST (list (cdr (assoc 5 (entget (entlast)))))))
   (if (listp DCIRCLE)
    (progn
     (if (/= nil Z)
      (progn
       (setq TLISTL nil
             TLISTCL nil
             TLISTFL nil
             TLISTR nil
             TLISTCR nil
             TLISTFR nil
             SLISTDEFAULT (list -2.0 -2.0)
       )
       (setq SLIST (RFL:SUPER STA))
       (foreach NODE (GETTPL STA DCIRCLE)
        (progn
         (setq DX nil DY nil)
         (cond ((= "S" (strcase (RFL:COLUMN NODE 1 ","))) ; S = Default Superelevation
                (setq SLISTDEFAULT (list (atof (RFL:COLUMN NODE 2 ",")) (atof (RFL:COLUMN NODE 3 ","))))
               )
               ((and (= "AP" (strcase (RFL:COLUMN NODE 1 ","))) ; AP = Polyline Alignments
                     AFLAG ; only redo if QSection reset
                )
                (progn
                 (princ "\nLoading control alignments .")
                 (setq ALSAVE RFL:ALIGNLIST)
                 (setq A (atoi (RFL:COLUMN NODE 2 ",")))
                 (setq TMP nil)
                 (if (setq ENTSET (ssget "X" (list (cons 0 "POLYLINE") (cons 8 (RFL:COLUMN NODE 3 ",")))))
                  (progn
                   (setq C 0)
                   (while (< C (sslength ENTSET))
                    (princ ".")
                    (setq ENT (ssname ENTSET C))
                    (command "._CONVERT" "P" "S" ENT "")
                    (setq C (1+ C))
                   )
                  )
                 )
                 (if (setq ENTSET (ssget "X" (list (cons 0 "LWPOLYLINE") (cons 8 (RFL:COLUMN NODE 3 ",")))))
                  (progn
                   (setq C 0)
                   (while (< C (sslength ENTSET))
                    (princ ".")
                    (setq ENT (ssname ENTSET C))
                    (if (setq RFL:ALIGNLIST (RFL:ALIGNDEF ENT (cdr (assoc 10 (entget ENT))) 0.0))
                     (setq TMP (append TMP (list RFL:ALIGNLIST)))
                    )
                    (setq C (1+ C))
                   )
                  )
                 )
                 (setq RFL:QSECTIONALIGNLIST (append RFL:QSECTIONALIGNLIST (list (list A TMP))))
                 (setq RFL:ALIGNLIST ALSAVE)
                )
               )
               ((= "L" (strcase (RFL:COLUMN NODE 1 ","))) ; L = Left control
                (progn
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                       ((= "A" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; A = Alignment offset
                        (progn
                         (setq A (atoi (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq TMP nil)
                         (setq ALSAVE RFL:ALIGNLIST)
                         (foreach RFL:ALIGNLIST (cadr (assoc A RFL:QSECTIONALIGNLIST))
                          (if (setq P (RFL:ALINTERS P0 P1 RFL:ALIGNLIST))
                           (setq TMP (append TMP (list P)))
                          )
                         )
                         (setq RFL:ALIGNLIST ALSAVE)
                         (if TMP
                          (progn
                           (setq P (caadar (vl-sort (mapcar '(lambda (A) (list (distance P0 A) (list A)))  TMP) '(lambda (A B) (< (car A) (car B))))))
                           (if (last TLISTL)
                            (setq DX (- (* -1.0 (car (last TLISTL))) (distance P0 P)))
                            (setq DX 0.0)
                           )
                          )
                          (setq DX 0.0)
                         )
                        )
                       )
                       ((= "Y" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                 )
                 (cond ((= "Y" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                       )
                       ((= "DS-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-L = Left depth super * -1.0
                        (setq DY (+ (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSL = Left depth super
                        (setq DY (+ (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-L = Left super * -1.0
                        (setq DY (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "SL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SL = Left Super
                        (setq DY (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "DS-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-R = Right depth super * -1.0
                        (setq DY (+ (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSR = Right depth super
                        (setq DY (+ (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-R = Right super * -1.0
                        (setq DY (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "SR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SR = Right super
                        (setq DY (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "OX" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; OX = Right offset at X:1
                        (setq OX (atof (substr (RFL:COLUMN NODE 3 ",") 3))
                              DX (/ DY (+ (/ 1.0 OX) (* 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT)))))
                              DY (+ DY (* -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT)) DX))
                        )
                       )
                 )
                 (if (= nil TLISTL)
                  (setq TLISTL (list (list DX (+ Z DY))))
                  (setq TLISTL (append TLISTL (list (list (+ (car (last TLISTL)) DX)  (+ (cadr (last TLISTL)) DY)))))
                 )
                )
               )
               ((= "CL" (strcase (RFL:COLUMN NODE 1 ","))) ; CL = Cut Slope Left
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTCL)
                          (setq PB (last TLISTCL))
                          (if (/= nil TLISTL)
                           (setq PB (last TLISTL))
                          )
                         )
                         (if PB
                          (progn
                           (setq P nil)
                           (setq PA (list (/ SWATH -2.0)
                                          (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C 1)
                           (while (and (< C (length OSLIST))
                                       (/= "NewLine" (nth C OSLIST))
                                  )
                            (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                             (setq P TMP)
                            )
                            (setq C (1+ C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PA (list (/ SWATH -2.0)
                                            (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C 1)
                             (while (and (< C (length OSLIST))
                                         (/= "NewLine" (nth C OSLIST))
                                    )
                              (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                               (setq P TMP)
                              )
                              (setq C (1+ C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PB))
                                  DY (- (cadr P) (cadr PB))
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTCL)
                   (if (= nil TLISTL)
                    (setq TLISTCL (list (list DX (+ Z DY))))
                    (setq TLISTCL (append TLISTCL (list (list (+ (car (last TLISTL)) DX)  (+ (cadr (last TLISTL)) DY)))))
                   )
                   (setq TLISTCL (append TLISTCL (list (list (+ (car (last TLISTCL)) DX)  (+ (cadr (last TLISTCL)) DY)))))
                  )
                 )
                )
               )
               ((= "FL" (strcase (RFL:COLUMN NODE 1 ","))) ; FL = Fill Slope Left
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTFL)
                          (setq PB (last TLISTFL))
                          (if (/= nil TLISTL)
                           (setq PB (last TLISTL))
                          )
                         )
                         (if PB
                          (progn
                           (setq P nil)
                           (setq PA (list (/ SWATH -2.0)
                                          (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C 1)
                           (while (and (< C (length OSLIST))
                                       (/= "NewLine" (nth C OSLIST))
                                  )
                            (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                             (setq P TMP)
                            )
                            (setq C (1+ C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PA (list (/ SWATH -2.0)
                                            (+ (cadr PB) (/ (- (car PB) (/ SWATH -2.0)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C 1)
                             (while (and (< C (length OSLIST))
                                         (/= "NewLine" (nth C OSLIST))
                                    )
                              (if (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                               (setq P TMP)
                              )
                              (setq C (1+ C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PB))
                                  DY (- (cadr P) (cadr PB))
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTFL)
                   (if (= nil TLISTL)
                    (setq TLISTFL (list (list DX (+ Z DY))))
                    (setq TLISTFL (append TLISTFL (list (list (+ (car (last TLISTL)) DX)  (+ (cadr (last TLISTL)) DY)))))
                   )
                   (setq TLISTFL (append TLISTFL (list (list (+ (car (last TLISTFL)) DX)  (+ (cadr (last TLISTFL)) DY)))))
                  )
                 )
                )
               )
               ((= "R" (strcase (RFL:COLUMN NODE 1 ","))) ; R = Right control
                (progn
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                       ((= "A" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; A = Alignment offset
                        (progn
                         (setq A (atoi (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq TMP nil)
                         (setq ALSAVE RFL:ALIGNLIST)
                         (foreach RFL:ALIGNLIST (cadr (assoc A RFL:QSECTIONALIGNLIST))
                          (if (setq P (RFL:ALINTERS P0 P2 RFL:ALIGNLIST))
                           (setq TMP (append TMP (list P)))
                          )
                         )
                         (setq RFL:ALIGNLIST ALSAVE)
                         (if TMP
                          (progn
                           (setq P (caadar (vl-sort (mapcar '(lambda (A) (list (distance P0 A) (list A)))  TMP) '(lambda (A B) (< (car A) (car B))))))
                           (if (last TLISTR)
                            (setq DX (- (distance P0 P) (car (last TLISTR))))
                            (setq DX 0.0)
                           )
                          )
                          (setq DX 0.0)
                         )
                        )
                       )
                       ((= "Y" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                       )
                 )
                 (cond ((= "Y" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 1))) ; Y = Y offset
                        (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                       )
                       ((= "DS-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-L = Left depth super * -1.0
                        (setq DY (+ (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSL = Left depth super
                        (setq DY (+ (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-L" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-L = Left super * -1.0
                        (setq DY (* DX -0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "SL" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SL = Left Super
                        (setq DY (* DX 0.01 (if SLIST (car SLIST) (car SLISTDEFAULT))))
                       )
                       ((= "DS-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DS-R = Right depth super * -1.0
                        (setq DY (+ (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 5))))
                       )
                       ((= "DSR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; DSR = Right depth super
                        (setq DY (+ (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))) (atof (substr (RFL:COLUMN NODE 3 ",") 4))))
                       )
                       ((= "S-R" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 3))) ; S-R = Right super * -1.0
                        (setq DY (* DX -0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "SR" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; SR = Right super
                        (setq DY (* DX 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))
                       )
                       ((= "OX" (strcase (substr (RFL:COLUMN NODE 3 ",") 1 2))) ; OX = Left offset at X:1
                        (setq OX (atof (substr (RFL:COLUMN NODE 3 ",") 3))
                              DX (/ DY (* -1.0 (+ (/ 1.0 OX) (* 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT))))))
                              DY (+ DY (* 0.01 (if SLIST (cadr SLIST) (cadr SLISTDEFAULT)) DX))
                        )
                       )
                 )
                 (if (= nil TLISTR)
                  (setq TLISTR (list (list DX (+ Z DY))))
                  (setq TLISTR (append TLISTR (list (list (+ (car (last TLISTR)) DX)  (+ (cadr (last TLISTR)) DY)))))
                 )
                )
               )
               ((= "CR" (strcase (RFL:COLUMN NODE 1 ","))) ; CR = Cut Slope Right
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTCR)
                          (setq PA (last TLISTCR))
                          (if (/= nil TLISTR)
                           (setq PA (last TLISTR))
                          )
                         )
                         (if PA
                          (progn
                           (setq P nil)
                           (setq PB (list (/ SWATH 2.0)
                                          (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C (1- (length OSLIST)))
                           (while (> C 0)
                            (if (and (/= "NewLine" (nth C OSLIST))
                                     (/= "NewLine" (nth (1- C) OSLIST))
                                     (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                                )
                             (setq P TMP)
                            )
                            (setq C (1- C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PB (list (/ SWATH 2.0)
                                            (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C (1- (length OSLIST)))
                             (while (> C 0)
                              (if (and (/= "NewLine" (nth C OSLIST))
                                       (/= "NewLine" (nth (1- C) OSLIST))
                                       (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                                  )
                               (setq P TMP)
                              )
                              (setq C (1- C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PA))  ;*****
                                  DY (- (cadr P) (cadr PA))  ;*****
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTCR)
                   (if (= nil TLISTR)
                    (setq TLISTCR (list (list DX (+ Z DY))))
                    (setq TLISTCR (append TLISTCR (list (list (+ (car (last TLISTR)) DX)  (+ (cadr (last TLISTR)) DY)))))
                   )
                   (setq TLISTCR (append TLISTCR (list (list (+ (car (last TLISTCR)) DX)  (+ (cadr (last TLISTCR)) DY)))))
                  )
                 )
                )
               )
               ((= "FR" (strcase (RFL:COLUMN NODE 1 ","))) ; FR = Fill Slope Right
                (progn
                 (setq DX nil DY nil)
                 (cond ((= "X" (strcase (substr (RFL:COLUMN NODE 2 ",") 1 1))) ; X = X offset
                        (progn
                         (setq DX (atof (substr (RFL:COLUMN NODE 2 ",") 2)))
                         (setq DY (atof (substr (RFL:COLUMN NODE 3 ",") 2)))
                        )
                       )
                       (T  ;  Cut/Fill only accept DX/DY offsets, if not will look for toe
                           ;  
                        (progn
                         (setq PA nil PB nil P nil)
                         (if (/= nil TLISTFR)
                          (setq PA (last TLISTFR))
                          (if (/= nil TLISTR)
                           (setq PA (last TLISTR))
                          )
                         )
                         (if PA
                          (progn
                           (setq P nil)
                           (setq PB (list (/ SWATH 2.0)
                                          (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 2 ","))))
                                    )
                           )
                           (setq C (1- (length OSLIST)))
                           (while (> C 0)
                            (if (and (/= "NewLine" (nth C OSLIST))
                                     (/= "NewLine" (nth (1- C) OSLIST))
                                     (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                                )
                             (setq P TMP)
                            )
                            (setq C (1- C))
                           )
                           (if (= nil P)
                            (progn
                             (setq PB (list (/ SWATH 2.0)
                                            (+ (cadr PA) (/ (- (/ SWATH 2.0) (car PA)) (atof (RFL:COLUMN NODE 3 ","))))
                                      )
                             )
                             (setq C (1- (length OSLIST)))
                             (while (> C 0)
                              (if (and (/= "NewLine" (nth C OSLIST))
                                       (/= "NewLine" (nth (1- C) OSLIST))
                                       (setq TMP (inters PA PB (nth (1- C) OSLIST) (nth C OSLIST)))
                                  )
                               (setq P TMP)
                              )
                              (setq C (1- C))
                             )
                            )
                           )
                           (if P
                            (setq DX (- (car P) (car PA))  ;*****
                                  DY (- (cadr P) (cadr PA))  ;*****
                            )
                           )
                          )
                         )
                        )
                       )
                 )
                 (if (and DX DY)
                  (if (= nil TLISTFR)
                   (if (= nil TLISTR)
                    (setq TLISTFR (list (list DX (+ Z DY))))
                    (setq TLISTFR (append TLISTFR (list (list (+ (car (last TLISTR)) DX)  (+ (cadr (last TLISTR)) DY)))))
                   )
                   (setq TLISTFR (append TLISTFR (list (list (+ (car (last TLISTFR)) DX)  (+ (cadr (last TLISTFR)) DY)))))
                  )
                 )
                )
               )
         )
        )
       )
       (if (ISABOVE (last TLISTL) OSLIST)
        (setq TLISTL (append TLISTL TLISTFL))
        (setq TLISTL (append TLISTL TLISTCL))
       )
       (if (ISABOVE (last TLISTR) OSLIST)
        (setq TLISTR (append TLISTR TLISTFR))
        (setq TLISTR (append TLISTR TLISTCR))
       )
;       (if (and (= nil TLISTCL) (/= nil TLISTFL))
;        (setq TLISTL (append TLISTL TLISTFL))
;        (if (and (/= nil TLISTCL) (= nil TLISTFL))
;         (setq TLISTL (append TLISTL TLISTCL))
;         (if (and (/= nil TLISTCL) (/= nil TLISTFL))
;          (if (> (car (last TLISTCL)) (car (last TLISTFL)))
;           (setq TLISTL (append TLISTL TLISTCL))
;           (setq TLISTL (append TLISTL TLISTFL))
;          )
;         )
;        )
;       )
;       (if (and (= nil TLISTCR) (/= nil TLISTFR))
;        (setq TLISTR (append TLISTR TLISTFR))
;        (if (and (/= nil TLISTCR) (= nil TLISTFR))
;         (setq TLISTR (append TLISTR TLISTCR))
;         (if (and (/= nil TLISTCR) (/= nil TLISTFR))
;          (if (< (car (last TLISTCR)) (car (last TLISTFR)))
;           (setq TLISTR (append TLISTR TLISTCR))
;           (setq TLISTR (append TLISTR TLISTFR))
;          )
;         )
;        )
;       )
       (if (and (= nil TLISTL) (= nil TLISTR))
        (setq TLIST nil)
        (if (= nil TLISTL)
         (setq TLIST TLISTR)
         (if (= nil TLISTR)
          (setq TLIST (reverse TLISTL))
          (if (< (distance (car TLISTL) (car TLISTR)) TOL)
           (setq TLIST (append (reverse TLISTL) (cdr TLISTR)))
           (setq TLIST (append (reverse TLISTL) TLISTR))
          )
         )
        )
       )
       (if (/= nil TLIST)
        (progn
         (if (cdr (assoc "DESLAYER" RFL:QSECTIONLIST))
          (setvar "CLAYER" (cdr (assoc "DESLAYER" RFL:QSECTIONLIST)))
         )
         (command "._PLINE")
         (foreach P TLIST
          (command (list (+ (car PBASE) (car P))
                         (+ (cadr PBASE) (* VEXAG (- (cadr P) ZBASE)))
                   )
          )
         )
         (command "")
         (setvar "CLAYER" CLAYER)
         (ADDHANDLE)
        )
       )
      )
     )
    )
    (if (= 1 DCIRCLE)
     (if (/= nil Z)
      (progn
       (command "._CIRCLE"
                (list (car PBASE) (+ (cadr PBASE) (* VEXAG (- Z ZBASE))))
                THEIGHT
       )
       (ADDHANDLE)
      )
     )
     (if (/= 0 DCIRCLE)
      (if (/= nil Z)
       (progn
        (entmake (list (cons 0 "INSERT")
                       (cons 2 DCIRCLE)
                       (list 10 (car PBASE) (+ (cadr PBASE) (* VEXAG (- Z ZBASE))) 0.0)
                       (cons 41 1.0)
                       (cons 42 VEXAG)
                       (cons 43 1.0)
                       (cons 50 0.0)
                       (cons 70 0)
                 )
        )
        (ADDHANDLE)
       )
      )
     )
    )
   )
   (if (= nil (assoc "ENTITIES" RFL:QSECTIONLIST))
    (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (list "ENTITIES" HANDENTLIST))))
    (setq RFL:QSECTIONLIST (subst (list "ENTITIES" HANDENTLIST) (assoc "ENTITIES" RFL:QSECTIONLIST) RFL:QSECTIONLIST))
   )
   (if (= nil (assoc "PBASE" RFL:QSECTIONLIST))
    (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (list "PBASE" PBASE))))
    (setq RFL:QSECTIONLIST (subst (list "PBASE" PBASE) (assoc "PBASE" RFL:QSECTIONLIST) RFL:QSECTIONLIST))
   )
   (if (= nil (assoc "STA" RFL:QSECTIONLIST))
    (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (cons "STA" STA))))
    (setq RFL:QSECTIONLIST (subst (cons "STA" STA) (assoc "STA" RFL:QSECTIONLIST) RFL:QSECTIONLIST))
   )
  )
 )
)
(defun C:QS+ (/ ANGBASE ANGDIR CMDECHO INC NODE OSMODE ORTHOMODE REP)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (if (/= nil RFL:QSECTIONLIST)
  (if (/= nil (assoc "PBASE" RFL:QSECTIONLIST))
   (progn
    (if (= nil (cdr (assoc "INC" RFL:QSECTIONLIST)))
     (progn
      (setq INC 20.0)
      (setq REP (getdist (strcat "\nStation increment <" (rtos INC) "> : ")))
      (if (/= nil REP) (setq INC REP))
      (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (cons "INC" INC))))
     )
     (setq INC (cdr (assoc "INC" RFL:QSECTIONLIST)))
    )
    (foreach NODE (cadr (assoc "ENTITIES" RFL:QSECTIONLIST))
     (if (/= nil (entget (handent NODE))) (entdel (handent NODE)))
    )
    (RFL:QSECTION (+ (cdr (assoc "STA" RFL:QSECTIONLIST)) INC)
                  (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                  (cadr (assoc "PBASE" RFL:QSECTIONLIST))
                  nil
                  (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                  (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                  (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                  (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
    )
   )
  )
 )
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (eval nil)
)
(defun C:QS- (/ ANGBASE ANGDIR CMDECHO INC NODE OSMODE ORTHOMODE REP)
 (setq ANGBASE (getvar "ANGBASE"))
 (setvar "ANGBASE" 0.0)
 (setq ANGDIR (getvar "ANGDIR"))
 (setvar "ANGDIR" 1)
 (setq CMDECHO (getvar "CMDECHO"))
 (setvar "CMDECHO" 0)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (if (/= nil RFL:QSECTIONLIST)
  (if (/= nil (assoc "PBASE" RFL:QSECTIONLIST))
   (progn
    (if (= nil (cdr (assoc "INC" RFL:QSECTIONLIST)))
     (progn
      (setq INC 20.0)
      (setq REP (getdist (strcat "\nStation increment <" (rtos INC) "> : ")))
      (if (/= nil REP) (setq INC REP))
      (setq RFL:QSECTIONLIST (append RFL:QSECTIONLIST (list (cons "INC" INC))))
     )
     (setq INC (cdr (assoc "INC" RFL:QSECTIONLIST)))
    )
    (foreach NODE (cadr (assoc "ENTITIES" RFL:QSECTIONLIST))
     (if (/= nil (entget (handent NODE))) (entdel (handent NODE)))
    )
    (RFL:QSECTION (- (cdr (assoc "STA" RFL:QSECTIONLIST)) INC)
                  (cdr (assoc "SWATH" RFL:QSECTIONLIST))
                  (cadr (assoc "PBASE" RFL:QSECTIONLIST))
                  nil
                  (cdr (assoc "VEXAG" RFL:QSECTIONLIST))
                  (cdr (assoc "THEIGHT" RFL:QSECTIONLIST))
                  (cdr (assoc "DCIRCLE" RFL:QSECTIONLIST))
                  (cdr (assoc "OBSURFACE" RFL:QSECTIONLIST))
    )
   )
  )
 )
 (setvar "ANGBASE" ANGBASE)
 (setvar "ANGDIR" ANGDIR)
 (setvar "CMDECHO" CMDECHO)
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (eval nil)
)